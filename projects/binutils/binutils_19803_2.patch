From 1c8c1643c1643fd8d49561ab5a9c4fe48d292614 Mon Sep 17 00:00:00 2001
From: Nick Clifton <nickc@redhat.com>
Date: Mon, 4 Apr 2016 12:53:33 +0100
Subject: [PATCH] More fixes for COFF/PE lanker garbage collection.

            PR 19803
            * emultempl/pe.em (change_undef): New function.  Encapsulates
            duplicated code in pe_fixup_stdcalls and adds the newly defined
            sym to the gc root list.
            (pe_fixup_stdcall): Use the new function.
            * pe-dll.c (process_def_file_and_drectve); Add alias of exported
            symbol to gc root list.

diff --git a/ld/emultempl/pe.em b/ld/emultempl/pe.em
index bddd9a8607..a7a5ba6ef6 100644
--- a/ld/emultempl/pe.em
+++ b/ld/emultempl/pe.em
@@ -1060,10 +1060,38 @@ pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
   return TRUE;
 }
 
+/* Change UNDEF to a defined symbol, taking data from SYM.  */
+
+static void
+change_undef (struct bfd_link_hash_entry * undef,
+	      struct bfd_link_hash_entry * sym)
+{
+  static bfd_boolean  gave_warning_message = FALSE;
+
+  undef->type = bfd_link_hash_defined;
+  undef->u.def.value = sym->u.def.value;
+  undef->u.def.section = sym->u.def.section;
+
+  if (pe_enable_stdcall_fixup == -1)
+    {
+      einfo (_("Warning: resolving %s by linking to %s\n"),
+	     undef->root.string, sym->root.string);
+
+      if (! gave_warning_message)
+	{
+	  einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
+	  einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
+	  gave_warning_message = TRUE;
+	}
+    }
+
+  /* PR 19803: Make sure that the linked symbol is not garbage collected.  */
+  lang_add_gc_name (sym->root.string);
+}
+
 static void
 pe_fixup_stdcalls (void)
 {
-  static int gave_warning_message = 0;
   struct bfd_link_hash_entry *undef, *sym;
 
   if (pe_dll_extra_pe_debug)
@@ -1072,69 +1100,39 @@ pe_fixup_stdcalls (void)
   for (undef = link_info.hash->undefs; undef; undef=undef->u.undef.next)
     if (undef->type == bfd_link_hash_undefined)
       {
-	char* at = strchr (undef->root.string, '@');
-	int lead_at = (*undef->root.string == '@');
+	const char * name = undef->root.string;
+	char * at;
+	int lead_at = (*name == '@');
+
 	if (lead_at)
-	  at = strchr (undef->root.string + 1, '@');
+	  at = strchr (name + 1, '@');
+	else
+	  at = strchr (name, '@');
 
 	if (at || lead_at)
 	  {
 	    /* The symbol is a stdcall symbol, so let's look for a
 	       cdecl symbol with the same name and resolve to that.  */
-	    char *cname = xstrdup (undef->root.string);
+	    char *cname = xstrdup (name);
 
 	    if (lead_at)
 	      *cname = '_';
-	    at = strchr (cname, '@');
-	    if (at)
-	      *at = 0;
-	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);
+	    if (at)	      
+	      * strchr (cname, '@') = 0;
+	    sym = bfd_link_hash_lookup (link_info.hash, cname, FALSE, FALSE, TRUE);
 
 	    if (sym && sym->type == bfd_link_hash_defined)
-	      {
-		undef->type = bfd_link_hash_defined;
-		undef->u.def.value = sym->u.def.value;
-		undef->u.def.section = sym->u.def.section;
-
-		if (pe_enable_stdcall_fixup == -1)
-		  {
-		    einfo (_("Warning: resolving %s by linking to %s\n"),
-			   undef->root.string, cname);
-		    if (! gave_warning_message)
-		      {
-			gave_warning_message = 1;
-			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
-			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
-		      }
-		  }
-	      }
+	      change_undef (undef, sym);
 	  }
 	else
 	  {
 	    /* The symbol is a cdecl symbol, so we look for stdcall
 	       symbols - which means scanning the whole symbol table.  */
-	    pe_undef_found_sym = 0;
+	    pe_undef_found_sym = NULL;
 	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
-				    (char *) undef->root.string);
-	    sym = pe_undef_found_sym;
-	    if (sym)
-	      {
-		undef->type = bfd_link_hash_defined;
-		undef->u.def.value = sym->u.def.value;
-		undef->u.def.section = sym->u.def.section;
-
-		if (pe_enable_stdcall_fixup == -1)
-		  {
-		    einfo (_("Warning: resolving %s by linking to %s\n"),
-			   undef->root.string, sym->root.string);
-		    if (! gave_warning_message)
-		      {
-			gave_warning_message = 1;
-			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
-			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
-		      }
-		  }
-	      }
+				    (char *) name);
+	    if (pe_undef_found_sym)
+	      change_undef (undef, pe_undef_found_sym);
 	  }
       }
 }
diff --git a/ld/pe-dll.c b/ld/pe-dll.c
index 3c02d0b2dd..ae16150a29 100644
--- a/ld/pe-dll.c
+++ b/ld/pe-dll.c
@@ -904,6 +904,9 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *
 	{
 	  *name = '_';
 	  strcpy (name + 1, pe_def_file->exports[i].internal_name);
+
+	  /* PR 19803: The alias must be preserved as well.  */
+	  lang_add_gc_name (xstrdup (name));
 	}
       else
 	strcpy (name, pe_def_file->exports[i].internal_name);
-- 
2.20.0.rc2

