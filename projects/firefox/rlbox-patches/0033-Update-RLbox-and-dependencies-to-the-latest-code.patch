From 233c64b0601b43a2aef09913bf205321121584fb Mon Sep 17 00:00:00 2001
From: Georg Koppen <gk@torproject.org>
Date: Fri, 28 Feb 2020 13:46:29 +0000
Subject: [PATCH 33/35] Update RLbox and dependencies to the latest code

This commit picks up changes which landed in bug 1610991 and 1615786.
The vendoring happened, again, with `./mach vendor rust`.

diff --git a/.cargo/config.in b/.cargo/config.in
index 2133c09fa161..15a68b528c85 100644
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -15,12 +15,12 @@ replace-with = "vendored-sources"
 [source."https://github.com/PLSysSec/rlbox_lucet_sandbox/"]
 git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/"
 replace-with = "vendored-sources"
-rev = "5f8bca975d8206e4837786d6bdb57a5c2fbd4016"
+rev = "d510da5999a744c563b0acd18056069d1698273f"
 
 [source."https://github.com/PLSysSec/lucet_sandbox_compiler"]
 git = "https://github.com/PLSysSec/lucet_sandbox_compiler"
 replace-with = "vendored-sources"
-rev = "58498599272e23ef797bb4304d0f181d7455ca57"
+rev = "5e870faf6f95d79d11efc813e56370ad124bbed5"
 
 [source."https://github.com/servo/serde"]
 git = "https://github.com/servo/serde"
diff --git a/Cargo.lock b/Cargo.lock
index 914e6238d956..67bf650ee89b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -235,7 +235,7 @@ name = "bindgen"
 version = "0.49.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cexpr 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "clang-sys 0.28.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -280,7 +280,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "bitflags"
-version = "1.0.4"
+version = "1.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -505,7 +505,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "textwrap 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -518,7 +518,7 @@ name = "cloudabi"
 version = "0.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -571,7 +571,7 @@ name = "core-graphics"
 version = "0.17.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "foreign-types 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -642,7 +642,7 @@ source = "git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0
 [[package]]
 name = "cranelift-entity"
 version = "0.41.0"
-source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57#58498599272e23ef797bb4304d0f181d7455ca57"
+source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5#5e870faf6f95d79d11efc813e56370ad124bbed5"
 
 [[package]]
 name = "cranelift-frontend"
@@ -814,7 +814,7 @@ name = "cubeb-core"
 version = "0.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cubeb-sys 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -1154,7 +1154,7 @@ name = "fuchsia-zircon"
 version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -1301,7 +1301,7 @@ dependencies = [
  "nsstring 0.1.0",
  "prefs_parser 0.0.1",
  "profiler_helper 0.1.0",
- "rlbox_lucet_sandbox 0.1.0 (git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=5f8bca975d8206e4837786d6bdb57a5c2fbd4016)",
+ "rlbox_lucet_sandbox 0.1.0 (git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=d510da5999a744c563b0acd18056069d1698273f)",
  "rsdparsa_capi 0.1.0",
  "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "storage 0.1.0",
@@ -1666,7 +1666,7 @@ name = "lmdb-rkv"
 version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
  "lmdb-rkv-sys 0.8.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
@@ -1709,11 +1709,11 @@ dependencies = [
 [[package]]
 name = "lucet-module"
 version = "0.1.1"
-source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57#58498599272e23ef797bb4304d0f181d7455ca57"
+source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5#5e870faf6f95d79d11efc813e56370ad124bbed5"
 dependencies = [
  "bincode 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "cranelift-entity 0.41.0 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
+ "cranelift-entity 0.41.0 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
  "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-derive 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -1725,12 +1725,12 @@ dependencies = [
 [[package]]
 name = "lucet-runtime"
 version = "0.1.1"
-source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57#58498599272e23ef797bb4304d0f181d7455ca57"
+source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5#5e870faf6f95d79d11efc813e56370ad124bbed5"
 dependencies = [
  "cc 1.0.34 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
- "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
+ "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
  "num-derive 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
@@ -1738,10 +1738,10 @@ dependencies = [
 [[package]]
 name = "lucet-runtime-internals"
 version = "0.1.1"
-source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57#58498599272e23ef797bb4304d0f181d7455ca57"
+source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5#5e870faf6f95d79d11efc813e56370ad124bbed5"
 dependencies = [
  "bincode 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cc 1.0.34 (registry+https://github.com/rust-lang/crates.io-index)",
  "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -1749,25 +1749,27 @@ dependencies = [
  "lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
  "libloading 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
+ "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
  "memoffset 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "nix 0.13.1 (git+https://github.com/shravanrn/nix/?branch=r0.13.1)",
  "num-derive 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "raw-cpuid 7.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "xfailure 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "lucet-wasi"
 version = "0.1.1"
-source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57#58498599272e23ef797bb4304d0f181d7455ca57"
+source = "git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5#5e870faf6f95d79d11efc813e56370ad124bbed5"
 dependencies = [
  "cast 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
- "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
+ "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "mach 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "nix 0.13.1 (git+https://github.com/shravanrn/nix/?branch=r0.13.1)",
  "rand 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
@@ -1777,6 +1779,14 @@ name = "lzw"
 version = "0.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "mach"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "malloc_size_of"
 version = "0.0.1"
@@ -2096,7 +2106,7 @@ name = "nix"
 version = "0.13.1"
 source = "git+https://github.com/shravanrn/nix/?branch=r0.13.1#4af6c367603869a30fddb5ffb0aba2b9477ba92e"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cc 1.0.34 (registry+https://github.com/rust-lang/crates.io-index)",
  "cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.59 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -2135,7 +2145,7 @@ dependencies = [
 name = "nsstring"
 version = "0.1.0"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "encoding_rs 0.8.16 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -2387,7 +2397,7 @@ name = "png"
 version = "0.14.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "deflate 0.7.19 (registry+https://github.com/rust-lang/crates.io-index)",
  "inflate 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -2455,7 +2465,7 @@ dependencies = [
 name = "pulse"
 version = "0.2.0"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "pulse-ffi 0.1.0",
 ]
 
@@ -2648,6 +2658,16 @@ dependencies = [
  "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "raw-cpuid"
+version = "7.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cc 1.0.34 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "rayon"
 version = "1.0.0"
@@ -2766,14 +2786,14 @@ dependencies = [
 [[package]]
 name = "rlbox_lucet_sandbox"
 version = "0.1.0"
-source = "git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=5f8bca975d8206e4837786d6bdb57a5c2fbd4016#5f8bca975d8206e4837786d6bdb57a5c2fbd4016"
+source = "git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=d510da5999a744c563b0acd18056069d1698273f#d510da5999a744c563b0acd18056069d1698273f"
 dependencies = [
  "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "goblin 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
- "lucet-wasi 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)",
+ "lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
+ "lucet-wasi 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)",
 ]
 
 [[package]]
@@ -2913,7 +2933,7 @@ dependencies = [
 name = "selectors"
 version = "0.21.0"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.25.7 (registry+https://github.com/rust-lang/crates.io-index)",
  "derive_more 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "fxhash 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3129,7 +3149,7 @@ dependencies = [
  "arrayvec 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "bindgen 0.49.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.25.7 (registry+https://github.com/rust-lang/crates.io-index)",
  "derive_more 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3192,7 +3212,7 @@ name = "style_traits"
 version = "0.0.1"
 dependencies = [
  "app_units 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.25.7 (registry+https://github.com/rust-lang/crates.io-index)",
  "euclid 0.19.5 (registry+https://github.com/rust-lang/crates.io-index)",
  "lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3591,7 +3611,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 name = "u2fhid"
 version = "0.2.3"
 dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "boxfnonce 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "devd-rs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3766,7 +3786,7 @@ version = "0.60.0"
 dependencies = [
  "base64 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "bincode 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3806,7 +3826,7 @@ version = "0.60.0"
 dependencies = [
  "app_units 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "bincode 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "core-graphics 0.17.1 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -4040,7 +4060,7 @@ dependencies = [
 "checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a"
 "checksum bit-vec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "f59bbe95d4e52a6398ec21238d31577f2b28a9d86807f06ca59d191d8440d0bb"
 "checksum bit_reverse 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "5e97e02db5a2899c0377f3d6031d5da8296ca2b47abef6ed699de51b9e40a28c"
-"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)" = "228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12"
+"checksum bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
 "checksum bitreader 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "80b13e2ab064ff3aa0bdbf1eff533f9822dc37899821f5f98c67f263eab51707"
 "checksum blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)" = "5d6d530bdd2d52966a6d03b7a964add7ae1a288d25214066fd4b600f0f796400"
 "checksum block-buffer 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)" = "c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b"
@@ -4075,7 +4095,7 @@ dependencies = [
 "checksum cranelift-codegen 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)" = "<none>"
 "checksum cranelift-codegen-meta 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)" = "<none>"
 "checksum cranelift-entity 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)" = "<none>"
-"checksum cranelift-entity 0.41.0 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)" = "<none>"
+"checksum cranelift-entity 0.41.0 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)" = "<none>"
 "checksum cranelift-frontend 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)" = "<none>"
 "checksum cranelift-wasm 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)" = "<none>"
 "checksum crc 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bd5d02c0aac6bd68393ed69e00bbc2457f3e89075c6349db7189618dc4ddc1d7"
@@ -4171,11 +4191,12 @@ dependencies = [
 "checksum lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "62ebf1391f6acad60e5c8b43706dde4582df75c06698ab44511d15016bc2442c"
 "checksum log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)" = "e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b"
 "checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6"
-"checksum lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)" = "<none>"
-"checksum lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)" = "<none>"
-"checksum lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)" = "<none>"
-"checksum lucet-wasi 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=58498599272e23ef797bb4304d0f181d7455ca57)" = "<none>"
+"checksum lucet-module 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)" = "<none>"
+"checksum lucet-runtime 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)" = "<none>"
+"checksum lucet-runtime-internals 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)" = "<none>"
+"checksum lucet-wasi 0.1.1 (git+https://github.com/PLSysSec/lucet_sandbox_compiler?rev=5e870faf6f95d79d11efc813e56370ad124bbed5)" = "<none>"
 "checksum lzw 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)" = "7d947cbb889ed21c2a84be6ffbaebf5b4e0f4340638cba0444907e38b56be084"
+"checksum mach 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa"
 "checksum malloc_size_of_derive 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "35adee9ed962cf7d07d62cb58bc45029f3227f5b5b86246caa8632f06c187bc3"
 "checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376"
 "checksum memchr 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "148fab2e51b4f1cfc66da2a7c32981d1d3c083a803978268bb11fe4b86925e7a"
@@ -4259,6 +4280,7 @@ dependencies = [
 "checksum rand_os 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
 "checksum rand_pcg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
 "checksum rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
+"checksum raw-cpuid 7.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "b4a349ca83373cfa5d6dbb66fd76e58b2cca08da71a5f6400de0a0a6a9bceeaf"
 "checksum rayon 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "485541959c8ecc49865526fe6c4de9653dd6e60d829d6edf0be228167b60372d"
 "checksum rayon-core 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "9d24ad214285a7729b174ed6d3bcfcb80177807f959d95fafd5bfc5c4f201ac8"
 "checksum rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
@@ -4271,7 +4293,7 @@ dependencies = [
 "checksum regex-syntax 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "8f1ac0f60d675cc6cf13a20ec076568254472551051ad5dd050364d70671bf6b"
 "checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5"
 "checksum rkv 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)" = "238764bd8750927754d91e4a27155ac672ba88934a2bf698c992d55e5ae25e5b"
-"checksum rlbox_lucet_sandbox 0.1.0 (git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=5f8bca975d8206e4837786d6bdb57a5c2fbd4016)" = "<none>"
+"checksum rlbox_lucet_sandbox 0.1.0 (git+https://github.com/PLSysSec/rlbox_lucet_sandbox/?rev=d510da5999a744c563b0acd18056069d1698273f)" = "<none>"
 "checksum ron 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "da06feaa07f69125ab9ddc769b11de29090122170b402547f64b86fe16ebc399"
 "checksum runloop 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5d79b4b604167921892e84afbbaad9d5ad74e091bf6c511d9dbfb0593f09fabd"
 "checksum rust-ini 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8a654c5bda722c699be6b0fe4c0d90de218928da5b724c3e467fc48865c37263"
diff --git a/Cargo.toml b/Cargo.toml
index 8ed0d762b84c..d770bd4ca00e 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -61,7 +61,7 @@ libudev-sys = { path = "dom/webauthn/libudev-sys" }
 serde_derive = { git = "https://github.com/servo/serde", branch = "deserialize_from_enums10" }
 winapi = { git = "https://github.com/froydnj/winapi-rs", branch = "aarch64" }
 packed_simd = { git = "https://github.com/hsivonen/packed_simd", branch = "rust_1_32" }
-rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="5f8bca975d8206e4837786d6bdb57a5c2fbd4016" }
+rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="d510da5999a744c563b0acd18056069d1698273f" }
 nix = { git = "https://github.com/shravanrn/nix/", branch = "r0.13.1", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 
 [patch.crates-io.cranelift-codegen]
diff --git a/third_party/rust/bitflags/.cargo-checksum.json b/third_party/rust/bitflags/.cargo-checksum.json
index 0338787d2f2c..a8b031c6517a 100644
--- a/third_party/rust/bitflags/.cargo-checksum.json
+++ b/third_party/rust/bitflags/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CHANGELOG.md":"b9f503da2d3c91b0a244f1dc853d975f971f782b209ea52cd4cd98705e6e2749","CODE_OF_CONDUCT.md":"42634d0f6d922f49857175af991802822f7f920487aefa2ee250a50d12251a66","Cargo.toml":"0234b6f827764ca093d897126b45505be0996e67860d61caeab696d092ffb781","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"6b236f8b62c82f189fabce0756e01a2c0ab1f32cb84cad9ff3c96b2ce5282bda","src/example_generated.rs":"e43eb59e90f317f38d436670a6067d2fd9eb35fb319fe716184e4a04e24ed1b2","src/lib.rs":"5751eb6fbb8cb97d8accd0846493168d9b5acff1f8d64435d4da8ad7dbf36b4d"},"package":"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12"}
\ No newline at end of file
+{"files":{"CHANGELOG.md":"00224cc8d292567bdd212c36db66a1f662cd2e6c58e947900680234937e288a9","CODE_OF_CONDUCT.md":"42634d0f6d922f49857175af991802822f7f920487aefa2ee250a50d12251a66","Cargo.toml":"abacd42e33056c16008ab8eefd16eb2403cbc3393f8a6ed352a9a39d945ad3a5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"6b236f8b62c82f189fabce0756e01a2c0ab1f32cb84cad9ff3c96b2ce5282bda","build.rs":"8923f38056f859b30aa9022980bb517755cbef57e1b09c34b33b27eb03b0626c","src/example_generated.rs":"e43eb59e90f317f38d436670a6067d2fd9eb35fb319fe716184e4a04e24ed1b2","src/lib.rs":"bd4e44ac35831c75af8815ba3a11ee1659afe0f72ce9c5f638a66bf50aa23d2a"},"package":"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"}
\ No newline at end of file
diff --git a/third_party/rust/bitflags/CHANGELOG.md b/third_party/rust/bitflags/CHANGELOG.md
index 1f5b4252c034..0d4910153d90 100644
--- a/third_party/rust/bitflags/CHANGELOG.md
+++ b/third_party/rust/bitflags/CHANGELOG.md
@@ -1,3 +1,44 @@
+# 1.2.1
+
+- Remove extraneous `#[inline]` attributes ([#194])
+
+[#194]: https://github.com/bitflags/bitflags/pull/194
+
+# 1.2.0
+
+- Fix typo: {Lower, Upper}Exp - {Lower, Upper}Hex ([#183])
+
+- Add support for "unknown" bits ([#188])
+
+[#183]: https://github.com/rust-lang-nursery/bitflags/pull/183
+[#188]: https://github.com/rust-lang-nursery/bitflags/pull/188
+
+# 1.1.0
+
+This is a re-release of `1.0.5`, which was yanked due to a bug in the RLS.
+
+# 1.0.5
+
+- Use compiletest_rs flags supported by stable toolchain ([#171])
+
+- Put the user provided attributes first ([#173])
+
+- Make bitflags methods `const` on newer compilers ([#175])
+
+[#171]: https://github.com/rust-lang-nursery/bitflags/pull/171
+[#173]: https://github.com/rust-lang-nursery/bitflags/pull/173
+[#175]: https://github.com/rust-lang-nursery/bitflags/pull/175
+
+# 1.0.4
+
+- Support Rust 2018 style macro imports ([#165])
+
+  ```rust
+  use bitflags::bitflags;
+  ```
+
+[#165]: https://github.com/rust-lang-nursery/bitflags/pull/165
+
 # 1.0.3
 
 - Improve zero value flag handling and documentation ([#157])
diff --git a/third_party/rust/bitflags/Cargo.toml b/third_party/rust/bitflags/Cargo.toml
index 956e9e976174..b803644d4475 100644
--- a/third_party/rust/bitflags/Cargo.toml
+++ b/third_party/rust/bitflags/Cargo.toml
@@ -3,7 +3,7 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g. crates.io) dependencies
+# to registry (e.g., crates.io) dependencies
 #
 # If you believe there's an error in this file please file an
 # issue against the rust-lang/cargo repository. If you're
@@ -12,8 +12,9 @@
 
 [package]
 name = "bitflags"
-version = "1.0.4"
+version = "1.2.1"
 authors = ["The Rust Project Developers"]
+build = "build.rs"
 exclude = [".travis.yml", "appveyor.yml", "bors.toml"]
 description = "A macro to generate structures which behave like bitflags.\n"
 homepage = "https://github.com/bitflags/bitflags"
diff --git a/third_party/rust/bitflags/build.rs b/third_party/rust/bitflags/build.rs
new file mode 100644
index 000000000000..985757a6f612
--- /dev/null
+++ b/third_party/rust/bitflags/build.rs
@@ -0,0 +1,44 @@
+use std::env;
+use std::process::Command;
+use std::str::{self, FromStr};
+
+fn main(){
+    let minor = match rustc_minor_version() {
+        Some(minor) => minor,
+        None => return,
+    };
+
+    // const fn stabilized in Rust 1.31:
+    if minor >= 31 {
+        println!("cargo:rustc-cfg=bitflags_const_fn");
+    }
+}
+
+fn rustc_minor_version() -> Option<u32> {
+    let rustc = match env::var_os("RUSTC") {
+        Some(rustc) => rustc,
+        None => return None,
+    };
+
+    let output = match Command::new(rustc).arg("--version").output() {
+        Ok(output) => output,
+        Err(_) => return None,
+    };
+
+    let version = match str::from_utf8(&output.stdout) {
+        Ok(version) => version,
+        Err(_) => return None,
+    };
+
+    let mut pieces = version.split('.');
+    if pieces.next() != Some("rustc 1") {
+        return None;
+    }
+
+    let next = match pieces.next() {
+        Some(next) => next,
+        None => return None,
+    };
+
+    u32::from_str(next).ok()
+}
\ No newline at end of file
diff --git a/third_party/rust/bitflags/src/lib.rs b/third_party/rust/bitflags/src/lib.rs
index 9e1bcfd6c228..3929b02ac10d 100644
--- a/third_party/rust/bitflags/src/lib.rs
+++ b/third_party/rust/bitflags/src/lib.rs
@@ -128,7 +128,7 @@
 //! too: `Extend` adds the union of the instances of the `struct` iterated over,
 //! while `FromIterator` calculates the union.
 //!
-//! The `Binary`, `Debug`, `LowerExp`, `Octal` and `UpperExp` trait is also
+//! The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` trait is also
 //! implemented by displaying the bits value of the internal struct.
 //!
 //! ## Operators
@@ -146,14 +146,18 @@
 //! The following methods are defined for the generated `struct`:
 //!
 //! - `empty`: an empty set of flags
-//! - `all`: the set of all flags
+//! - `all`: the set of all defined flags
 //! - `bits`: the raw value of the flags currently stored
 //! - `from_bits`: convert from underlying bit representation, unless that
-//!                representation contains bits that do not correspond to a flag
+//!                representation contains bits that do not correspond to a
+//!                defined flag
 //! - `from_bits_truncate`: convert from underlying bit representation, dropping
-//!                         any bits that do not correspond to flags
+//!                         any bits that do not correspond to defined flags
+//! - `from_bits_unchecked`: convert from underlying bit representation, keeping
+//!                          all bits (even those not corresponding to defined
+//!                          flags)
 //! - `is_empty`: `true` if no flags are currently stored
-//! - `is_all`: `true` if all flags are currently set
+//! - `is_all`: `true` if currently set flags exactly equal all defined flags
 //! - `intersects`: `true` if there are flags common to both `self` and `other`
 //! - `contains`: `true` all of the flags in `other` are contained within `self`
 //! - `insert`: inserts the specified flags in-place
@@ -247,7 +251,7 @@
 //! ```
 
 #![no_std]
-#![doc(html_root_url = "https://docs.rs/bitflags/1.0.4")]
+#![doc(html_root_url = "https://docs.rs/bitflags/1.2.1")]
 
 #[cfg(test)]
 #[macro_use]
@@ -398,8 +402,8 @@ macro_rules! __bitflags {
             )+
         }
     ) => {
-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
         $(#[$outer])*
+        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
         $($vis)* struct $BitFlags {
             bits: $T,
         }
@@ -415,6 +419,60 @@ macro_rules! __bitflags {
     };
 }
 
+#[macro_export(local_inner_macros)]
+#[doc(hidden)]
+#[cfg(bitflags_const_fn)]
+macro_rules! __fn_bitflags {
+    (
+        $(# $attr_args:tt)*
+        const fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        const fn $($item)*
+    };
+    (
+        $(# $attr_args:tt)*
+        pub const fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        pub const fn $($item)*
+    };
+    (
+        $(# $attr_args:tt)*
+        pub const unsafe fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        pub const unsafe fn $($item)*
+    };
+}
+
+#[macro_export(local_inner_macros)]
+#[doc(hidden)]
+#[cfg(not(bitflags_const_fn))]
+macro_rules! __fn_bitflags {
+    (
+        $(# $attr_args:tt)*
+        const fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        fn $($item)*
+    };
+    (
+        $(# $attr_args:tt)*
+        pub const fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        pub fn $($item)*
+    };
+    (
+        $(# $attr_args:tt)*
+        pub const unsafe fn $($item:tt)*
+    ) => {
+        $(# $attr_args)*
+        pub unsafe fn $($item)*
+    };
+}
+
 #[macro_export(local_inner_macros)]
 #[doc(hidden)]
 macro_rules! __impl_bitflags {
@@ -473,6 +531,15 @@ macro_rules! __impl_bitflags {
                         f.write_str(__bitflags_stringify!($Flag))?;
                     }
                 )+
+                let extra_bits = self.bits & !$BitFlags::all().bits();
+                if extra_bits != 0 {
+                    if !first {
+                        f.write_str(" | ")?;
+                    }
+                    first = false;
+                    f.write_str("0x")?;
+                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
+                }
                 if first {
                     f.write_str("(empty)")?;
                 }
@@ -507,40 +574,44 @@ macro_rules! __impl_bitflags {
                 pub const $Flag: $BitFlags = $BitFlags { bits: $value };
             )+
 
-            /// Returns an empty set of flags.
-            #[inline]
-            pub fn empty() -> $BitFlags {
-                $BitFlags { bits: 0 }
+            __fn_bitflags! {
+                /// Returns an empty set of flags
+                #[inline]
+                pub const fn empty() -> $BitFlags {
+                    $BitFlags { bits: 0 }
+                }
             }
 
-            /// Returns the set containing all flags.
-            #[inline]
-            pub fn all() -> $BitFlags {
-                // See `Debug::fmt` for why this approach is taken.
-                #[allow(non_snake_case)]
-                trait __BitFlags {
-                    $(
-                        #[inline]
-                        fn $Flag() -> $T { 0 }
-                    )+
-                }
-                impl __BitFlags for $BitFlags {
-                    $(
-                        __impl_bitflags! {
-                            #[allow(deprecated)]
-                            #[inline]
-                            $(? #[$attr $($args)*])*
-                            fn $Flag() -> $T { Self::$Flag.bits }
-                        }
-                    )+
+            __fn_bitflags! {
+                /// Returns the set containing all flags.
+                #[inline]
+                pub const fn all() -> $BitFlags {
+                    // See `Debug::fmt` for why this approach is taken.
+                    #[allow(non_snake_case)]
+                    trait __BitFlags {
+                        $(
+                            const $Flag: $T = 0;
+                        )+
+                    }
+                    impl __BitFlags for $BitFlags {
+                        $(
+                            __impl_bitflags! {
+                                #[allow(deprecated)]
+                                $(? #[$attr $($args)*])*
+                                const $Flag: $T = Self::$Flag.bits;
+                            }
+                        )+
+                    }
+                    $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag)|+ }
                 }
-                $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag())|+ }
             }
 
-            /// Returns the raw value of the flags currently stored.
-            #[inline]
-            pub fn bits(&self) -> $T {
-                self.bits
+            __fn_bitflags! {
+                /// Returns the raw value of the flags currently stored.
+                #[inline]
+                pub const fn bits(&self) -> $T {
+                    self.bits
+                }
             }
 
             /// Convert from underlying bit representation, unless that
@@ -554,35 +625,54 @@ macro_rules! __impl_bitflags {
                 }
             }
 
-            /// Convert from underlying bit representation, dropping any bits
-            /// that do not correspond to flags.
-            #[inline]
-            pub fn from_bits_truncate(bits: $T) -> $BitFlags {
-                $BitFlags { bits } & $BitFlags::all()
+            __fn_bitflags! {
+                /// Convert from underlying bit representation, dropping any bits
+                /// that do not correspond to flags.
+                #[inline]
+                pub const fn from_bits_truncate(bits: $T) -> $BitFlags {
+                    $BitFlags { bits: bits & $BitFlags::all().bits }
+                }
             }
 
-            /// Returns `true` if no flags are currently stored.
-            #[inline]
-            pub fn is_empty(&self) -> bool {
-                *self == $BitFlags::empty()
+            __fn_bitflags! {
+                /// Convert from underlying bit representation, preserving all
+                /// bits (even those not corresponding to a defined flag).
+                #[inline]
+                pub const unsafe fn from_bits_unchecked(bits: $T) -> $BitFlags {
+                    $BitFlags { bits }
+                }
             }
 
-            /// Returns `true` if all flags are currently set.
-            #[inline]
-            pub fn is_all(&self) -> bool {
-                *self == $BitFlags::all()
+            __fn_bitflags! {
+                /// Returns `true` if no flags are currently stored.
+                #[inline]
+                pub const fn is_empty(&self) -> bool {
+                    self.bits() == $BitFlags::empty().bits()
+                }
             }
 
-            /// Returns `true` if there are flags common to both `self` and `other`.
-            #[inline]
-            pub fn intersects(&self, other: $BitFlags) -> bool {
-                !(*self & other).is_empty()
+            __fn_bitflags! {
+                /// Returns `true` if all flags are currently set.
+                #[inline]
+                pub const fn is_all(&self) -> bool {
+                    self.bits == $BitFlags::all().bits
+                }
             }
 
-            /// Returns `true` all of the flags in `other` are contained within `self`.
-            #[inline]
-            pub fn contains(&self, other: $BitFlags) -> bool {
-                (*self & other) == other
+            __fn_bitflags! {
+                /// Returns `true` if there are flags common to both `self` and `other`.
+                #[inline]
+                pub const fn intersects(&self, other: $BitFlags) -> bool {
+                    !$BitFlags{ bits: self.bits & other.bits}.is_empty()
+                }
+            }
+
+            __fn_bitflags! {
+                /// Returns `true` all of the flags in `other` are contained within `self`.
+                #[inline]
+                pub const fn contains(&self, other: $BitFlags) -> bool {
+                    (self.bits & other.bits) == other.bits
+                }
             }
 
             /// Inserts the specified flags in-place.
@@ -769,6 +859,61 @@ macro_rules! __impl_bitflags {
         $(#[$filtered])*
         fn $($item)*
     };
+
+    // Every attribute that the user writes on a const is applied to the
+    // corresponding const that we generate, but within the implementation of
+    // Debug and all() we want to ignore everything but #[cfg] attributes. In
+    // particular, including a #[deprecated] attribute on those items would fail
+    // to compile.
+    // https://github.com/bitflags/bitflags/issues/109
+    //
+    // const version
+    //
+    // Input:
+    //
+    //     ? #[cfg(feature = "advanced")]
+    //     ? #[deprecated(note = "Use somthing else.")]
+    //     ? #[doc = r"High quality documentation."]
+    //     const f: i32 { /* ... */ }
+    //
+    // Output:
+    //
+    //     #[cfg(feature = "advanced")]
+    //     const f: i32 { /* ... */ }
+    (
+        $(#[$filtered:meta])*
+        ? #[cfg $($cfgargs:tt)*]
+        $(? #[$rest:ident $($restargs:tt)*])*
+        const $($item:tt)*
+    ) => {
+        __impl_bitflags! {
+            $(#[$filtered])*
+            #[cfg $($cfgargs)*]
+            $(? #[$rest $($restargs)*])*
+            const $($item)*
+        }
+    };
+    (
+        $(#[$filtered:meta])*
+        // $next != `cfg`
+        ? #[$next:ident $($nextargs:tt)*]
+        $(? #[$rest:ident $($restargs:tt)*])*
+        const $($item:tt)*
+    ) => {
+        __impl_bitflags! {
+            $(#[$filtered])*
+            // $next filtered out
+            $(? #[$rest $($restargs)*])*
+            const $($item)*
+        }
+    };
+    (
+        $(#[$filtered:meta])*
+        const $($item:tt)*
+    ) => {
+        $(#[$filtered])*
+        const $($item)*
+    };
 }
 
 // Same as std::stringify but callable from __impl_bitflags, which needs to use
@@ -808,12 +953,12 @@ mod tests {
 
     bitflags! {
         struct _CfgFlags: u32 {
-            #[cfg(windows)]
-            const _CFG_A = 0b01;
             #[cfg(unix)]
-            const _CFG_B = 0b01;
+            const _CFG_A = 0b01;
             #[cfg(windows)]
-            const _CFG_C = _CFG_A.bits | 0b10;
+            const _CFG_B = 0b01;
+            #[cfg(unix)]
+            const _CFG_C = Self::_CFG_A.bits | 0b10;
         }
     }
 
@@ -868,6 +1013,17 @@ mod tests {
         );
     }
 
+    #[test]
+    fn test_from_bits_unchecked() {
+        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0) }, Flags::empty());
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1) }, Flags::A);
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0b10) }, Flags::B);
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0b11) }, (Flags::A | Flags::B));
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1000) }, (extra | Flags::empty()));
+        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1001) }, (extra | Flags::A));
+    }
+
     #[test]
     fn test_is_empty() {
         assert!(Flags::empty().is_empty());
@@ -969,6 +1125,22 @@ mod tests {
         assert_eq!(m4, AnotherSetOfFlags::empty());
     }
 
+    #[test]
+    fn test_operators_unchecked() {
+        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };
+        let e1 = Flags::A | Flags::C | extra;
+        let e2 = Flags::B | Flags::C;
+        assert_eq!((e1 | e2), (Flags::ABC | extra)); // union
+        assert_eq!((e1 & e2), Flags::C); // intersection
+        assert_eq!((e1 - e2), (Flags::A | extra)); // set difference
+        assert_eq!(!e2, Flags::A); // set complement
+        assert_eq!(!e1, Flags::B); // set complement
+        assert_eq!(e1 ^ e2, Flags::A | Flags::B | extra); // toggle
+        let mut e3 = e1;
+        e3.toggle(e2);
+        assert_eq!(e3, Flags::A | Flags::B | extra);
+    }
+
     #[test]
     fn test_set() {
         let mut e1 = Flags::A | Flags::C;
@@ -996,6 +1168,19 @@ mod tests {
         assert_eq!(m1, e1);
     }
 
+
+    #[cfg(bitflags_const_fn)]
+    #[test]
+    fn test_const_fn() {
+        const _M1: Flags = Flags::empty();
+
+        const M2: Flags = Flags::A;
+        assert_eq!(M2, Flags::A);
+
+        const M3: Flags = Flags::C;
+        assert_eq!(M3, Flags::C);
+    }
+
     #[test]
     fn test_extend() {
         let mut flags;
@@ -1079,30 +1264,46 @@ mod tests {
         assert_eq!(format!("{:?}", Flags::A | Flags::B), "A | B");
         assert_eq!(format!("{:?}", Flags::empty()), "(empty)");
         assert_eq!(format!("{:?}", Flags::ABC), "A | B | C | ABC");
+        let extra = unsafe { Flags::from_bits_unchecked(0xb8) };
+        assert_eq!(format!("{:?}", extra), "0xb8");
+        assert_eq!(format!("{:?}", Flags::A | extra), "A | 0xb8");
+        assert_eq!(format!("{:?}", Flags::ABC | extra), "A | B | C | ABC | 0xb8");
     }
 
     #[test]
     fn test_binary() {
         assert_eq!(format!("{:b}", Flags::ABC), "111");
         assert_eq!(format!("{:#b}", Flags::ABC), "0b111");
+        let extra = unsafe { Flags::from_bits_unchecked(0b1010000) };
+        assert_eq!(format!("{:b}", Flags::ABC | extra), "1010111");
+        assert_eq!(format!("{:#b}", Flags::ABC | extra), "0b1010111");
     }
 
     #[test]
     fn test_octal() {
         assert_eq!(format!("{:o}", LongFlags::LONG_A), "177777");
         assert_eq!(format!("{:#o}", LongFlags::LONG_A), "0o177777");
+        let extra = unsafe { LongFlags::from_bits_unchecked(0o5000000) };
+        assert_eq!(format!("{:o}", LongFlags::LONG_A | extra), "5177777");
+        assert_eq!(format!("{:#o}", LongFlags::LONG_A | extra), "0o5177777");
     }
 
     #[test]
     fn test_lowerhex() {
         assert_eq!(format!("{:x}", LongFlags::LONG_A), "ffff");
         assert_eq!(format!("{:#x}", LongFlags::LONG_A), "0xffff");
+        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };
+        assert_eq!(format!("{:x}", LongFlags::LONG_A | extra), "e0ffff");
+        assert_eq!(format!("{:#x}", LongFlags::LONG_A | extra), "0xe0ffff");
     }
 
     #[test]
     fn test_upperhex() {
         assert_eq!(format!("{:X}", LongFlags::LONG_A), "FFFF");
         assert_eq!(format!("{:#X}", LongFlags::LONG_A), "0xFFFF");
+        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };
+        assert_eq!(format!("{:X}", LongFlags::LONG_A | extra), "E0FFFF");
+        assert_eq!(format!("{:#X}", LongFlags::LONG_A | extra), "0xE0FFFF");
     }
 
     mod submodule {
diff --git a/third_party/rust/lucet-module/.cargo-checksum.json b/third_party/rust/lucet-module/.cargo-checksum.json
index ee394773893f..5e3b0f3dde4b 100644
--- a/third_party/rust/lucet-module/.cargo-checksum.json
+++ b/third_party/rust/lucet-module/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"541f0b13e6f51d7ce1e61275aaaeeaabd38ae9f3e5b6bb1d5b543be416449546","src/bindings.rs":"bb0bcfb2e328f139d7d34b95d91ac64008c54fbf2748caf818b4a6af6c3bec14","src/error.rs":"1c938dfd33b790eb97e920785aadc7b4a2796d8e2e806b6083593ccf173d43d1","src/functions.rs":"29f4e4bd91986680d7d06ed6f5ccbb8bc734b52316e5bf9ac40ced45cbc8b149","src/globals.rs":"18841f6f5d6163673de5e9dfd641b1c558e9ad984418cbf94691059a1c4ed2a2","src/lib.rs":"9b5ec1e3fd8b0c51e5eceb8ac4930f9d2562cf296cffa102746b794547cbcfbb","src/linear_memory.rs":"aa62a57ad0783508465dc43bd22167c33d15efb32e44b9aeba6ff86ea72051ef","src/module.rs":"56f37d2892fe91d19afc49d2f62b562f0f71a21f21aec205b5368c733329d629","src/module_data.rs":"8059b46aeef038babdedbf3d2de758605f019ba6f2ab8ddc7c132581609a7a78","src/runtime.rs":"0532a55d2649eb6ea486a70c278ccbc243255cdbf5462739c0db6a2e73cb4d1a","src/signature.rs":"c1606419111edec1895762c212c7116a0d39670c8d303b5af0f58295ba15cfc4","src/tables.rs":"efe9aa8ae3602cce8aa093e220d63490b17907be8ed192024939445ff8b8922b","src/traps.rs":"2ff45ff2438f18ca1740182cf9735cbb789125bd57214e5a140b3bcd5295a433","src/types.rs":"d354b3a9f96b768dc7a8885b9fefa2efc1e01bcb66e5028e5f787247d1b2abb2","tests/bindings/bad_bindings.json":"7c5ad85eb0a222985857b6ff35246dccfa2a35de415d57fd712264ca7e078934","tests/bindings/bindings_test.json":"2e3ed6ff5d18da665d5c2fb24e279f009092f21bba6deff221db7a5770a6a3d4","tests/bindings/garbage.json":"f956f64c8c23ecf2aa6226fa7abc5f52eee2fa861e12ceac3bddbdf0602a174b"},"package":null}
\ No newline at end of file
+{"files":{"Cargo.toml":"541f0b13e6f51d7ce1e61275aaaeeaabd38ae9f3e5b6bb1d5b543be416449546","src/bindings.rs":"bb0bcfb2e328f139d7d34b95d91ac64008c54fbf2748caf818b4a6af6c3bec14","src/error.rs":"1c938dfd33b790eb97e920785aadc7b4a2796d8e2e806b6083593ccf173d43d1","src/functions.rs":"29f4e4bd91986680d7d06ed6f5ccbb8bc734b52316e5bf9ac40ced45cbc8b149","src/globals.rs":"18841f6f5d6163673de5e9dfd641b1c558e9ad984418cbf94691059a1c4ed2a2","src/lib.rs":"759adce1db8c138294edcc47610f905e89da2e3ba5e62e3cef769ba1556ae174","src/linear_memory.rs":"aa62a57ad0783508465dc43bd22167c33d15efb32e44b9aeba6ff86ea72051ef","src/module.rs":"56f37d2892fe91d19afc49d2f62b562f0f71a21f21aec205b5368c733329d629","src/module_data.rs":"9e08e44ce8aaa90ae60240eb8feb693d5ca36dc42df55147617f5c3b636b9b8b","src/runtime.rs":"0532a55d2649eb6ea486a70c278ccbc243255cdbf5462739c0db6a2e73cb4d1a","src/signature.rs":"c1606419111edec1895762c212c7116a0d39670c8d303b5af0f58295ba15cfc4","src/tables.rs":"efe9aa8ae3602cce8aa093e220d63490b17907be8ed192024939445ff8b8922b","src/traps.rs":"2ff45ff2438f18ca1740182cf9735cbb789125bd57214e5a140b3bcd5295a433","src/types.rs":"d354b3a9f96b768dc7a8885b9fefa2efc1e01bcb66e5028e5f787247d1b2abb2","tests/bindings/bad_bindings.json":"7c5ad85eb0a222985857b6ff35246dccfa2a35de415d57fd712264ca7e078934","tests/bindings/bindings_test.json":"2e3ed6ff5d18da665d5c2fb24e279f009092f21bba6deff221db7a5770a6a3d4","tests/bindings/garbage.json":"f956f64c8c23ecf2aa6226fa7abc5f52eee2fa861e12ceac3bddbdf0602a174b"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/lucet-module/src/lib.rs b/third_party/rust/lucet-module/src/lib.rs
index ede81ee2d1ba..9582113c5d6b 100644
--- a/third_party/rust/lucet-module/src/lib.rs
+++ b/third_party/rust/lucet-module/src/lib.rs
@@ -26,7 +26,7 @@ pub use crate::functions::{
 pub use crate::globals::{Global, GlobalDef, GlobalSpec, GlobalValue};
 pub use crate::linear_memory::{HeapSpec, LinearMemorySpec, SparseData};
 pub use crate::module::{Module, SerializedModule, LUCET_MODULE_SYM};
-pub use crate::module_data::{ModuleData, MODULE_DATA_SYM};
+pub use crate::module_data::{ModuleData, ModuleFeatures, MODULE_DATA_SYM};
 pub use crate::runtime::InstanceRuntimeData;
 pub use crate::signature::ModuleSignature;
 #[cfg(feature = "signature_checking")]
diff --git a/third_party/rust/lucet-module/src/module_data.rs b/third_party/rust/lucet-module/src/module_data.rs
index da1b5e96852d..e55c33a18631 100644
--- a/third_party/rust/lucet-module/src/module_data.rs
+++ b/third_party/rust/lucet-module/src/module_data.rs
@@ -35,6 +35,38 @@ pub struct ModuleData<'a> {
     export_functions: Vec<ExportFunction<'a>>,
     signatures: Vec<Signature>,
     module_signature: Vec<u8>,
+    features: ModuleFeatures,
+}
+
+#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
+pub struct ModuleFeatures {
+    pub sse3: bool,
+    pub ssse3: bool,
+    pub sse41: bool,
+    pub sse42: bool,
+    pub avx: bool,
+    pub bmi1: bool,
+    pub bmi2: bool,
+    pub lzcnt: bool,
+    pub popcnt: bool,
+    _hidden: (),
+}
+
+impl ModuleFeatures {
+    pub fn none() -> Self {
+        Self {
+            sse3: false,
+            ssse3: false,
+            sse41: false,
+            sse42: false,
+            avx: false,
+            bmi1: false,
+            bmi2: false,
+            lzcnt: false,
+            popcnt: false,
+            _hidden: (),
+        }
+    }
 }
 
 impl<'a> ModuleData<'a> {
@@ -46,6 +78,7 @@ impl<'a> ModuleData<'a> {
         import_functions: Vec<ImportFunction<'a>>,
         export_functions: Vec<ExportFunction<'a>>,
         signatures: Vec<Signature>,
+        features: ModuleFeatures,
     ) -> Self {
         let module_signature = vec![0u8; SignatureBones::BYTES];
         Self {
@@ -56,6 +89,7 @@ impl<'a> ModuleData<'a> {
             export_functions,
             signatures,
             module_signature,
+            features,
         }
     }
 
@@ -67,6 +101,7 @@ impl<'a> ModuleData<'a> {
         import_functions: Vec<ImportFunction<'a>>,
         export_functions: Vec<ExportFunction<'a>>,
         signatures: Vec<Signature>,
+        features: ModuleFeatures,
     ) -> Self {
         let module_signature = vec![0u8; 0];
         Self {
@@ -77,6 +112,7 @@ impl<'a> ModuleData<'a> {
             export_functions,
             signatures,
             module_signature,
+            features,
         }
     }
 
@@ -136,6 +172,10 @@ impl<'a> ModuleData<'a> {
         &self.module_signature
     }
 
+    pub fn features(&self) -> &ModuleFeatures {
+        &self.features
+    }
+
     #[cfg(feature = "signature_checking")]
     pub fn patch_module_signature(
         module_data_bin: &'a [u8],
@@ -186,6 +226,7 @@ pub struct OwnedModuleData {
     imports: Vec<OwnedImportFunction>,
     exports: Vec<OwnedExportFunction>,
     signatures: Vec<Signature>,
+    features: ModuleFeatures,
 }
 
 impl OwnedModuleData {
@@ -196,6 +237,7 @@ impl OwnedModuleData {
         imports: Vec<OwnedImportFunction>,
         exports: Vec<OwnedExportFunction>,
         signatures: Vec<Signature>,
+        features: ModuleFeatures,
     ) -> Self {
         Self {
             linear_memory,
@@ -204,6 +246,7 @@ impl OwnedModuleData {
             imports,
             exports,
             signatures,
+            features,
         }
     }
 
@@ -224,11 +267,20 @@ impl OwnedModuleData {
             self.imports.iter().map(|imp| imp.to_ref()).collect(),
             self.exports.iter().map(|exp| exp.to_ref()).collect(),
             self.signatures.clone(),
+            self.features.clone(),
         )
     }
 
     pub fn empty() -> Self {
-        Self::new(None, vec![], vec![], vec![], vec![], vec![])
+        Self::new(
+            None,
+            vec![],
+            vec![],
+            vec![],
+            vec![],
+            vec![],
+            ModuleFeatures::none(),
+        )
     }
 
     pub fn with_heap_spec(mut self, heap_spec: HeapSpec) -> Self {
diff --git a/third_party/rust/lucet-runtime-internals/.cargo-checksum.json b/third_party/rust/lucet-runtime-internals/.cargo-checksum.json
index 006846265033..57dc0da558ce 100644
--- a/third_party/rust/lucet-runtime-internals/.cargo-checksum.json
+++ b/third_party/rust/lucet-runtime-internals/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"20c473420bb65fe6f8abb4695359ce4e56a051de9076e960fc831e4445053303","build.rs":"ae539feaad828d15cbe4924e8de5ae38c7d0086200a5c4d494edf8e8e28c074e","src/alloc/mod.rs":"842a9003ab8f89d142e567f62278b8a50ce08be9a1751035d5fdba09286dea75","src/alloc/tests.rs":"d7516622bfa8c96f81b2f6929674eea6b9f368e876ab84bd442de120debda234","src/c_api.rs":"5360954bad8cd332e881e466eb840e50da1984d72c44ccc809a38b7e33633d5a","src/context/context_asm.S":"6b0fe86e5e7f3699482d94819f67ead933aaf91da89f79da0d8a75fa71ba4380","src/context/mod.rs":"98452bfad053d4cd4143afed620233538688cf2bac857b0c4569f42ee8d6d844","src/context/tests/c_child.c":"a9ad91367ac37e7406a587f971858aa7758913f634ea7ae88fccc7f487a3c4fc","src/context/tests/c_child.rs":"33c0472401795d61af2a706cc69d62b69225159a10cfc55e4b0c6e15321f0964","src/context/tests/mod.rs":"5d1bc979aaea2870a8c3a3db66cde21d16d9aab20b898da2c67d6aa1f1f5c292","src/context/tests/rust_child.rs":"ed69940a0b426eef5f9524f06ca215d0952cf4b00d8ebcf8837077849502d075","src/embed_ctx.rs":"57ae60c1a50cf84af23dc529a154db21cbb58c52c8067b9f87069dd600b99473","src/error.rs":"fd09389d5112b04ea76ffed0a7b2a8180c524cded90e33e36399a690c5714e2e","src/hostcall_macros.rs":"b4a2fdd876eee50bec4188f7d9f7c708d71600974cc2b52ff38c7daaa63cb225","src/instance.rs":"04bf1dddd9a980579b3baef77b83f19e8187a085aee6276a0fd4e60af7918e7a","src/instance/siginfo_ext.c":"8ee3a54ef2b93041ca07ecce70ebeb8d421c8ad1257122d9e8ef064d2d45a4a4","src/instance/siginfo_ext.rs":"529b4cc7ce6eea140c17a97477cc862f9d224e40cc24687223a478696d27b971","src/instance/signals.rs":"b890f9f7ca571763c48fa004284aa09b4e80b07ae2f836826aa784fbcace28f1","src/instance/state.rs":"490278c7222fc22248c8f545364a5d522da721c35f5b5e814658dc90e8ed77bd","src/lib.rs":"0c97e40191f17826feccff762898a0f4cafd1ed45cc3e81c07f9f446e263a422","src/module.rs":"29b54cc59cf308d712d9ecf4d595ef10645213e8ea62ec7f3a12adb27089fb47","src/module/dl.rs":"863c487f7494353ca53e0c663dc297e65a4ff5f380cff94c7c760b9509275270","src/module/mock.rs":"12d8eb790de37c3065d7a3029ea5caa4811992dc62054f01737ad7562c7f4c05","src/module/sparse_page_data.rs":"84ef79aa4707e5c84d72a38c5ead18156b16ab29c617540e652e851c744449dc","src/region/mmap.rs":"3ad6dc578f52619300a24db532912fd3ac16ced9de894b9fce8dab4f78b0f04f","src/region/mod.rs":"d2bf8b8c769542299bae9e5ed5d334ca7b431dfd52619ae1487d1494653dfc82","src/sysdeps/linux.rs":"124cc2f0fb0856e23274facdab8ca4631f04cdf8e494d9a4531979efe4ba4ad9","src/sysdeps/macos.rs":"8dc632a9aab98993140a6faefb7c2e313d80e6b9db2e45f54e8d6604cd752a6f","src/sysdeps/mod.rs":"9caed471a08f5f7d39c836a649d0f61d7a84095cee7589cdfc1eafe10eaa866c","src/test_helpers.rs":"72d1aeb9ca9c512aadcecac7ad0869c883c13134fced9f625075dc5e2741c55d","src/val.rs":"503891cd17892349b931d49ed3cdc0c9fc572da47d4c8f8f94fee30f5f4543a6","src/vmctx.rs":"b401df03b483c827d694f5f9024cf54b40987cff025dd8f292137e8396f56e6e"},"package":null}
\ No newline at end of file
+{"files":{"Cargo.toml":"60850f9a0002833508a6c2ecfa7ec8e11c3b5708934a7b74faa93246cd9b75ee","build.rs":"ae539feaad828d15cbe4924e8de5ae38c7d0086200a5c4d494edf8e8e28c074e","src/alloc/mod.rs":"6aac9fa3fd238de17d6270fab6e9677ade40dbbff9d700494f9a78084da1ccd3","src/alloc/tests.rs":"3aada1196dae1b03106e63f6892b9fc019cf9627b99b278765668c56df82bc79","src/c_api.rs":"cb42793d891597ac903636d4726d64a94507a583d44bd350571ce104db4fcc0a","src/context/context_asm.S":"6b0fe86e5e7f3699482d94819f67ead933aaf91da89f79da0d8a75fa71ba4380","src/context/mod.rs":"98452bfad053d4cd4143afed620233538688cf2bac857b0c4569f42ee8d6d844","src/context/tests/c_child.c":"a9ad91367ac37e7406a587f971858aa7758913f634ea7ae88fccc7f487a3c4fc","src/context/tests/c_child.rs":"33c0472401795d61af2a706cc69d62b69225159a10cfc55e4b0c6e15321f0964","src/context/tests/mod.rs":"5d1bc979aaea2870a8c3a3db66cde21d16d9aab20b898da2c67d6aa1f1f5c292","src/context/tests/rust_child.rs":"ed69940a0b426eef5f9524f06ca215d0952cf4b00d8ebcf8837077849502d075","src/embed_ctx.rs":"57ae60c1a50cf84af23dc529a154db21cbb58c52c8067b9f87069dd600b99473","src/error.rs":"fd09389d5112b04ea76ffed0a7b2a8180c524cded90e33e36399a690c5714e2e","src/hostcall_macros.rs":"b4a2fdd876eee50bec4188f7d9f7c708d71600974cc2b52ff38c7daaa63cb225","src/instance.rs":"04bf1dddd9a980579b3baef77b83f19e8187a085aee6276a0fd4e60af7918e7a","src/instance/siginfo_ext.c":"8ee3a54ef2b93041ca07ecce70ebeb8d421c8ad1257122d9e8ef064d2d45a4a4","src/instance/siginfo_ext.rs":"529b4cc7ce6eea140c17a97477cc862f9d224e40cc24687223a478696d27b971","src/instance/signals.rs":"37d7cff815169fdab680d2931f6236d4e912c34621b9c99192b0147450bb6bc1","src/instance/state.rs":"490278c7222fc22248c8f545364a5d522da721c35f5b5e814658dc90e8ed77bd","src/lib.rs":"0c97e40191f17826feccff762898a0f4cafd1ed45cc3e81c07f9f446e263a422","src/module.rs":"29b54cc59cf308d712d9ecf4d595ef10645213e8ea62ec7f3a12adb27089fb47","src/module/dl.rs":"828838d35596e9c4399a5cfc857d680484b953f6ebed17b5dfd8ddf3e77adf82","src/module/mock.rs":"bf397a32bc1f567a5597f92d017a04f5c480e1b07f21b8843b49b49f6dde111a","src/module/sparse_page_data.rs":"84ef79aa4707e5c84d72a38c5ead18156b16ab29c617540e652e851c744449dc","src/region/mmap.rs":"fd41806035e26320136eb770960d514770eab8a4c933b8f17b4c605d02cf421f","src/region/mod.rs":"d2bf8b8c769542299bae9e5ed5d334ca7b431dfd52619ae1487d1494653dfc82","src/sysdeps/linux.rs":"124cc2f0fb0856e23274facdab8ca4631f04cdf8e494d9a4531979efe4ba4ad9","src/sysdeps/macos.rs":"8dc632a9aab98993140a6faefb7c2e313d80e6b9db2e45f54e8d6604cd752a6f","src/sysdeps/mod.rs":"9caed471a08f5f7d39c836a649d0f61d7a84095cee7589cdfc1eafe10eaa866c","src/test_helpers.rs":"72d1aeb9ca9c512aadcecac7ad0869c883c13134fced9f625075dc5e2741c55d","src/val.rs":"503891cd17892349b931d49ed3cdc0c9fc572da47d4c8f8f94fee30f5f4543a6","src/vmctx.rs":"b401df03b483c827d694f5f9024cf54b40987cff025dd8f292137e8396f56e6e"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/lucet-runtime-internals/Cargo.toml b/third_party/rust/lucet-runtime-internals/Cargo.toml
index b555c68beaef..bcac1f88e593 100644
--- a/third_party/rust/lucet-runtime-internals/Cargo.toml
+++ b/third_party/rust/lucet-runtime-internals/Cargo.toml
@@ -24,6 +24,7 @@ nix = "0.13"
 num-derive = "0.3"
 num-traits = "0.2"
 xfailure = "0.1"
+raw-cpuid = "7.0.3"
 
 # This is only a dependency to ensure that other crates don't pick a newer version as a transitive
 # dependency. `0.1.3 < getrandom <= 0.1.6` cause `lazy_static` to pull in spinlock implementations
diff --git a/third_party/rust/lucet-runtime-internals/src/alloc/mod.rs b/third_party/rust/lucet-runtime-internals/src/alloc/mod.rs
index 8cd8378f39b6..b6d12901953e 100644
--- a/third_party/rust/lucet-runtime-internals/src/alloc/mod.rs
+++ b/third_party/rust/lucet-runtime-internals/src/alloc/mod.rs
@@ -1,7 +1,7 @@
 use crate::error::Error;
 use crate::module::Module;
 use crate::region::RegionInternal;
-use libc::{c_void, SIGSTKSZ};
+use libc::c_void;
 use lucet_module::GlobalValue;
 use nix::unistd::{sysconf, SysconfVar};
 use std::sync::{Arc, Once, Weak};
@@ -113,7 +113,8 @@ impl Drop for Alloc {
 }
 
 impl Alloc {
-    pub fn addr_in_heap_guard(&self, addr: *const c_void) -> bool {
+    pub fn addr_in_guard_page(&self, addr: *const c_void) -> bool {
+        let addr = addr as usize;
         let heap = self.slot().heap as usize;
         let guard_start = heap + self.heap_accessible_size;
         let guard_end = heap + self.slot().limits.heap_address_space_size;
@@ -121,7 +122,16 @@ impl Alloc {
         //     "addr = {:p}, guard_start = {:p}, guard_end = {:p}",
         //     addr, guard_start as *mut c_void, guard_end as *mut c_void
         // );
-        (addr as usize >= guard_start) && ((addr as usize) < guard_end)
+        let stack_guard_end = self.slot().stack as usize;
+        let stack_guard_start = stack_guard_end - host_page_size();
+        // eprintln!(
+        //     "addr = {:p}, stack_guard_start = {:p}, stack_guard_end = {:p}",
+        //     addr, stack_guard_start as *mut c_void, stack_guard_end as *mut c_void
+        // );
+        let in_heap_guard = (addr >= guard_start) && (addr < guard_end);
+        let in_stack_guard = (addr >= stack_guard_start) && (addr < stack_guard_end);
+
+        in_heap_guard || in_stack_guard
     }
 
     pub fn expand_heap(&mut self, expand_bytes: u32, module: &dyn Module) -> Result<u32, Error> {
@@ -308,7 +318,10 @@ impl Alloc {
 
     /// Return the sigstack as a mutable byte slice.
     pub unsafe fn sigstack_mut(&mut self) -> &mut [u8] {
-        std::slice::from_raw_parts_mut(self.slot().sigstack as *mut u8, libc::SIGSTKSZ)
+        std::slice::from_raw_parts_mut(
+            self.slot().sigstack as *mut u8,
+            self.slot().limits.signal_stack_size,
+        )
     }
 
     pub fn mem_in_heap<T>(&self, ptr: *const T, len: usize) -> bool {
@@ -341,15 +354,30 @@ pub struct Limits {
     pub stack_size: usize,
     /// Size of the globals region in bytes; each global uses 8 bytes. (default 4K)
     pub globals_size: usize,
+    /// Size of the signal stack in bytes. (default SIGSTKSZ for release builds, 12K for debug builds)
+    ///
+    /// This difference is to account for the greatly increased stack size usage in the signal
+    /// handler when running without optimizations.
+    ///
+    /// Note that debug vs. release mode is determined by `cfg(debug_assertions)`, so if you are
+    /// specifically enabling debug assertions in your release builds, the default signal stack will
+    /// be larger.
+    pub signal_stack_size: usize,
 }
 
-impl Default for Limits {
-    fn default() -> Limits {
+#[cfg(debug_assertions)]
+pub const DEFAULT_SIGNAL_STACK_SIZE: usize = 12 * 1024;
+#[cfg(not(debug_assertions))]
+pub const DEFAULT_SIGNAL_STACK_SIZE: usize = libc::SIGSTKSZ;
+
+impl Limits {
+    pub const fn default() -> Limits {
         Limits {
             heap_memory_size: 16 * 64 * 1024,
             heap_address_space_size: 0x200000000,
             stack_size: 128 * 1024,
             globals_size: 4096,
+            signal_stack_size: DEFAULT_SIGNAL_STACK_SIZE,
         }
     }
 }
@@ -360,19 +388,18 @@ impl Limits {
         // * the instance (up to instance_heap_offset)
         // * the heap, followed by guard pages
         // * the stack (grows towards heap guard pages)
-        // * one guard page (for good luck?)
         // * globals
         // * one guard page (to catch signal stack overflow)
-        // * the signal stack (size given by signal.h SIGSTKSZ macro)
+        // * the signal stack
 
         [
             instance_heap_offset(),
             self.heap_address_space_size,
-            self.stack_size,
             host_page_size(),
+            self.stack_size,
             self.globals_size,
             host_page_size(),
-            SIGSTKSZ,
+            self.signal_stack_size,
         ]
         .iter()
         .try_fold(0usize, |acc, &x| acc.checked_add(x))
@@ -409,6 +436,11 @@ impl Limits {
         if self.stack_size <= 0 {
             return Err(Error::InvalidArgument("stack size must be greater than 0"));
         }
+        if self.signal_stack_size % host_page_size() != 0 {
+            return Err(Error::InvalidArgument(
+                "signal stack size must be a multiple of host page size",
+            ));
+        }
         Ok(())
     }
 }
diff --git a/third_party/rust/lucet-runtime-internals/src/alloc/tests.rs b/third_party/rust/lucet-runtime-internals/src/alloc/tests.rs
index c4d8823a6304..0e7c1be4dc11 100644
--- a/third_party/rust/lucet-runtime-internals/src/alloc/tests.rs
+++ b/third_party/rust/lucet-runtime-internals/src/alloc/tests.rs
@@ -21,6 +21,7 @@ macro_rules! alloc_tests {
             heap_address_space_size: LIMITS_HEAP_ADDRSPACE_SIZE,
             stack_size: LIMITS_STACK_SIZE,
             globals_size: LIMITS_GLOBALS_SIZE,
+            ..Limits::default()
         };
 
         const SPEC_HEAP_RESERVED_SIZE: u64 = LIMITS_HEAP_ADDRSPACE_SIZE as u64 / 2;
@@ -264,6 +265,7 @@ macro_rules! alloc_tests {
                 heap_address_space_size: LIMITS_HEAP_ADDRSPACE_SIZE,
                 stack_size: LIMITS_STACK_SIZE,
                 globals_size: LIMITS_GLOBALS_SIZE,
+                ..Limits::default()
             };
             let res = TestRegion::create(10, &LIMITS);
             assert!(res.is_err(), "region creation fails");
@@ -366,7 +368,7 @@ macro_rules! alloc_tests {
                 }
 
                 let sigstack = unsafe { inst.alloc_mut().sigstack_mut() };
-                assert_eq!(sigstack.len(), libc::SIGSTKSZ);
+                assert_eq!(sigstack.len(), LIMITS.signal_stack_size);
 
                 assert_eq!(sigstack[0], 0);
                 sigstack[0] = 0xFF;
@@ -569,6 +571,7 @@ macro_rules! alloc_tests {
             heap_address_space_size: 2 * 4096,
             stack_size: 4096,
             globals_size: 4096,
+            ..Limits::default()
         };
         const CONTEXT_TEST_INITIAL_SIZE: u64 = 4096;
         const CONTEXT_TEST_HEAP: HeapSpec = HeapSpec {
diff --git a/third_party/rust/lucet-runtime-internals/src/c_api.rs b/third_party/rust/lucet-runtime-internals/src/c_api.rs
index 02aa0a156011..cd3bb4867a82 100644
--- a/third_party/rust/lucet-runtime-internals/src/c_api.rs
+++ b/third_party/rust/lucet-runtime-internals/src/c_api.rs
@@ -140,6 +140,16 @@ pub struct lucet_alloc_limits {
     pub stack_size: u64,
     /// Size of the globals region in bytes; each global uses 8 bytes. (default 4K)
     pub globals_size: u64,
+    /// Size of the signal stack in bytes. (default SIGSTKSZ for Rust release builds, 12K for Rust
+    /// debug builds)
+    ///
+    /// This difference is to account for the greatly increased stack size usage in the signal
+    /// handler when running without optimizations.
+    ///
+    /// Note that debug vs. release mode is determined by `cfg(debug_assertions)`, so if you are
+    /// specifically enabling Rust debug assertions in your Cargo release builds, the default signal
+    /// stack will be larger.
+    pub signal_stack_size: u64,
 }
 
 impl From<Limits> for lucet_alloc_limits {
@@ -155,6 +165,7 @@ impl From<&Limits> for lucet_alloc_limits {
             heap_address_space_size: limits.heap_address_space_size as u64,
             stack_size: limits.stack_size as u64,
             globals_size: limits.globals_size as u64,
+            signal_stack_size: limits.signal_stack_size as u64,
         }
     }
 }
@@ -172,6 +183,7 @@ impl From<&lucet_alloc_limits> for Limits {
             heap_address_space_size: limits.heap_address_space_size as usize,
             stack_size: limits.stack_size as usize,
             globals_size: limits.globals_size as usize,
+            signal_stack_size: limits.signal_stack_size as usize,
         }
     }
 }
diff --git a/third_party/rust/lucet-runtime-internals/src/instance/signals.rs b/third_party/rust/lucet-runtime-internals/src/instance/signals.rs
index 72a0fa4fec4a..d52be927c7a5 100644
--- a/third_party/rust/lucet-runtime-internals/src/instance/signals.rs
+++ b/third_party/rust/lucet-runtime-internals/src/instance/signals.rs
@@ -61,7 +61,7 @@ impl Instance {
         let guest_sigstack = SigStack::new(
             self.alloc.slot().sigstack,
             SigStackFlags::empty(),
-            libc::SIGSTKSZ,
+            self.alloc.slot().limits.signal_stack_size,
         );
         let previous_sigstack = unsafe { sigaltstack(Some(guest_sigstack)) }
             .expect("enabling or changing the signal stack succeeds");
@@ -190,7 +190,7 @@ extern "C" fn handle_signal(signum: c_int, siginfo_ptr: *mut siginfo_t, ucontext
                 // If the trap was a segv or bus fault and the addressed memory was outside the
                 // guard pages, it is also a fatal error
                 let outside_guard = (siginfo.si_signo == SIGSEGV || siginfo.si_signo == SIGBUS)
-                    && !inst.alloc.addr_in_heap_guard(siginfo.si_addr_ext());
+                    && !inst.alloc.addr_in_guard_page(siginfo.si_addr_ext());
 
                 // record the fault and jump back to the host context
                 inst.state = State::Faulted {
diff --git a/third_party/rust/lucet-runtime-internals/src/module/dl.rs b/third_party/rust/lucet-runtime-internals/src/module/dl.rs
index ac2c1e6a7db4..2a917ebd66fc 100644
--- a/third_party/rust/lucet-runtime-internals/src/module/dl.rs
+++ b/third_party/rust/lucet-runtime-internals/src/module/dl.rs
@@ -3,8 +3,8 @@ use crate::module::{AddrDetails, GlobalSpec, HeapSpec, Module, ModuleInternal, T
 use libc::c_void;
 use libloading::Library;
 use lucet_module::{
-    FunctionHandle, FunctionIndex, FunctionPointer, FunctionSpec, ModuleData, SerializedModule,
-    Signature, LUCET_MODULE_SYM,
+    FunctionHandle, FunctionIndex, FunctionPointer, FunctionSpec, ModuleData, ModuleFeatures,
+    ModuleSignature, SerializedModule, Signature, LUCET_MODULE_SYM,
 };
 #[cfg(feature = "signature_checking")]
 use lucet_module::{ModuleSignature, PublicKey};
@@ -15,6 +15,69 @@ use std::slice;
 use std::slice::from_raw_parts;
 use std::sync::Arc;
 
+use raw_cpuid::CpuId;
+
+fn check_feature_support(module_features: &ModuleFeatures) -> Result<(), Error> {
+    let cpuid = CpuId::new();
+
+    fn missing_feature(feature: &str) -> Error {
+        Error::Unsupported(format!(
+            "Module requires feature host does not support: {}",
+            feature
+        ))
+    }
+
+    let info = cpuid
+        .get_feature_info()
+        .ok_or_else(|| Error::Unsupported("Unable to obtain host CPU feature info!".to_string()))?;
+
+    if module_features.sse3 && !info.has_sse3() {
+        return Err(missing_feature("SSE3"));
+    }
+    if module_features.ssse3 && !info.has_ssse3() {
+        return Err(missing_feature("SSS3"));
+    }
+    if module_features.sse41 && !info.has_sse41() {
+        return Err(missing_feature("SSE4.1"));
+    }
+    if module_features.sse42 && !info.has_sse42() {
+        return Err(missing_feature("SSE4.2"));
+    }
+    if module_features.avx && !info.has_avx() {
+        return Err(missing_feature("AVX"));
+    }
+    if module_features.popcnt && !info.has_popcnt() {
+        return Err(missing_feature("POPCNT"));
+    }
+
+    if module_features.bmi1 || module_features.bmi2 {
+        let info = cpuid.get_extended_feature_info().ok_or_else(|| {
+            Error::Unsupported("Unable to obtain host CPU extended feature info!".to_string())
+        })?;
+
+        if module_features.bmi1 && !info.has_bmi1() {
+            return Err(missing_feature("BMI1"));
+        }
+
+        if module_features.bmi2 && !info.has_bmi2() {
+            return Err(missing_feature("BMI2"));
+        }
+    }
+
+    if module_features.lzcnt {
+        let info = cpuid.get_extended_function_info().ok_or_else(|| {
+            Error::Unsupported("Unable to obtain host CPU extended function info!".to_string())
+        })?;
+
+        if module_features.lzcnt && !info.has_lzcnt() {
+            return Err(missing_feature("LZCNT"));
+        }
+    }
+
+    // Features are fine, we're compatible!
+    Ok(())
+}
+
 /// A Lucet module backed by a dynamically-loaded shared object.
 pub struct DlModule {
     lib: Library,
@@ -83,6 +146,9 @@ impl DlModule {
             )
         };
         let module_data = ModuleData::deserialize(module_data_slice)?;
+
+        check_feature_support(module_data.features())?;
+
         verifier(&module_data)?;
 
         let fbase = if let Some(dli) =
diff --git a/third_party/rust/lucet-runtime-internals/src/module/mock.rs b/third_party/rust/lucet-runtime-internals/src/module/mock.rs
index 1600f63b0902..edca4d83a262 100644
--- a/third_party/rust/lucet-runtime-internals/src/module/mock.rs
+++ b/third_party/rust/lucet-runtime-internals/src/module/mock.rs
@@ -6,8 +6,8 @@ use lucet_module::owned::{
     OwnedLinearMemorySpec, OwnedModuleData, OwnedSparseData,
 };
 use lucet_module::{
-    FunctionHandle, FunctionIndex, FunctionPointer, FunctionSpec, ModuleData, Signature, TrapSite,
-    UniqueSignatureIndex,
+    FunctionHandle, FunctionIndex, FunctionPointer, FunctionSpec, ModuleData, ModuleFeatures,
+    Signature, TrapSite, UniqueSignatureIndex,
 };
 use std::collections::{BTreeMap, HashMap};
 use std::sync::Arc;
@@ -221,6 +221,7 @@ impl MockModuleBuilder {
             self.imports,
             self.exports,
             self.signatures,
+            ModuleFeatures::none(),
         );
         let serialized_module_data = owned_module_data
             .to_ref()
diff --git a/third_party/rust/lucet-runtime-internals/src/region/mmap.rs b/third_party/rust/lucet-runtime-internals/src/region/mmap.rs
index d97f0a0fd3f9..8655f7599b0a 100644
--- a/third_party/rust/lucet-runtime-internals/src/region/mmap.rs
+++ b/third_party/rust/lucet-runtime-internals/src/region/mmap.rs
@@ -4,9 +4,9 @@ use crate::error::Error;
 use crate::instance::{new_instance_handle, Instance, InstanceHandle};
 use crate::module::Module;
 use crate::region::{Region, RegionCreate, RegionInternal};
+use libc::c_void;
 #[cfg(not(target_os = "linux"))]
 use libc::memset;
-use libc::{c_void, SIGSTKSZ};
 use nix::sys::mman::{madvise, mmap, munmap, MapFlags, MmapAdvise, ProtFlags};
 use std::ptr;
 use std::sync::{Arc, Mutex, Weak};
@@ -39,17 +39,17 @@ use std::sync::{Arc, Mutex, Weak};
 /// 0xXXXX: ~  .......heap.......   ~ // heap size is governed by limits.heap_address_space_size
 /// 0xXXXX: |                       |
 /// 0xN000: +-----------------------| <-- Stack (at heap_start + limits.heap_address_space_size)
+/// 0xNXXX: --- stack guard page ----
 /// 0xNXXX: |                       |
 /// 0xXXXX: ~  .......stack......   ~ // stack size is governed by limits.stack_size
 /// 0xXXXX: |                       |
-/// 0xXXXx: --- stack guard page ----
 /// 0xM000: +-----------------------| <-- Globals (at stack_start + limits.stack_size + PAGE_SIZE)
 /// 0xMXXX: |                       |
 /// 0xXXXX: ~  ......globals.....   ~
 /// 0xXXXX: |                       |
 /// 0xXXXX  --- global guard page ---
 /// 0xS000: +-----------------------| <-- Sigstack (at globals_start + globals_size + PAGE_SIZE)
-/// 0xSXXX: |  ......sigstack....   | // sigstack is SIGSTKSZ bytes
+/// 0xSXXX: |  ......sigstack....   | // sigstack is governed by limits.signal_stack_size
 /// 0xSXXX: +-----------------------|
 /// ```
 pub struct MmapRegion {
@@ -87,7 +87,7 @@ impl RegionInternal for MmapRegion {
             // make the globals read/writable
             (slot.globals, limits.globals_size),
             // make the sigstack read/writable
-            (slot.sigstack, SIGSTKSZ),
+            (slot.sigstack, limits.signal_stack_size),
         ]
         .into_iter()
         {
@@ -136,7 +136,7 @@ impl RegionInternal for MmapRegion {
             (slot.heap, alloc.heap_accessible_size),
             (slot.stack, slot.limits.stack_size),
             (slot.globals, slot.limits.globals_size),
-            (slot.sigstack, SIGSTKSZ),
+            (slot.sigstack, slot.limits.signal_stack_size),
         ]
         .into_iter()
         {
@@ -272,10 +272,6 @@ impl MmapRegion {
     /// The region is returned in an `Arc`, because any instances created from it carry a reference
     /// back to the region.
     pub fn create(instance_capacity: usize, limits: &Limits) -> Result<Arc<Self>, Error> {
-        assert!(
-            SIGSTKSZ % host_page_size() == 0,
-            "signal stack size is a multiple of host page size"
-        );
         limits.validate()?;
 
         let region = Arc::new(MmapRegion {
@@ -305,10 +301,6 @@ impl MmapRegion {
         limits: &Limits,
         heap_alignment: usize,
     ) -> Result<Arc<Self>, Error> {
-        assert!(
-            SIGSTKSZ % host_page_size() == 0,
-            "signal stack size is a multiple of host page size"
-        );
         limits.validate()?;
 
         let is_power_of_2 = (heap_alignment & (heap_alignment - 1)) == 0;
@@ -372,9 +364,9 @@ impl MmapRegion {
 
         // lay out the other sections in memory
         let heap = mem as usize + instance_heap_offset();
-        let stack = heap + region.limits.heap_address_space_size;
-        let globals = stack + region.limits.stack_size + host_page_size();
-        let sigstack = globals + host_page_size();
+        let stack = heap + region.limits.heap_address_space_size + host_page_size();
+        let globals = stack + region.limits.stack_size;
+        let sigstack = globals + region.limits.globals_size + host_page_size();
 
         Ok(Slot {
             start: mem,
diff --git a/third_party/rust/lucet-runtime/.cargo-checksum.json b/third_party/rust/lucet-runtime/.cargo-checksum.json
index bd1b7668f9c0..b10686c34560 100644
--- a/third_party/rust/lucet-runtime/.cargo-checksum.json
+++ b/third_party/rust/lucet-runtime/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"32943e73c9f49c3ce3512b312128bed7200631c33297f45a254db416a5a3d4bd","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","build.rs":"d56fd4e2fe9d0830aee061be443ef0b541ed98dd6a4233220a51745478b3fb77","include/lucet.h":"89ff353483287040e07e3f6eaeed4286cb06f541fb67057f9fdbbf844a7ec928","include/lucet_types.h":"9581effd486709f178f5e45b68eea015b9c5f94f4488bf8e745edd65ea02086d","include/lucet_val.h":"220b862b0280ac4f7962d44520f6cc34a47f3b3a34b8ecf389e6111cd95b8bf0","include/lucet_vmctx.h":"044ca80cf8cca51620de3f113a1c07c00ebecea108a45288f9b87e5e2fbb820c","src/c_api.rs":"97e28537fffeac5d21f09911a3474114997ce0268492edb8010ce8ca178a6c64","src/lib.rs":"48f0ba473b4da3616bddfce3cda00cf836eca3c9e7b055855156c1c167a6f908","tests/c_api.c":"82618645e60d714dd07338f9240eeea54a459e2c6bb6f7e35ee75d6aadd900ae","tests/entrypoint.rs":"1d0080e9f71a16f61e69c21922ac1c2207b2003fb13d3bacafb681be5cceb8b9","tests/globals.rs":"56248c5cefbaad546b08964d9193e5c16a461e974d1c9c520ebba3f1cf32af66","tests/guest_fault.rs":"cb4728d0851148f992c944199f4fc98595070d0879e1ddf5361419e4fc330ad3","tests/guests/null.c":"de2bf0dc98ac1acaef8cb856a300119aa1300d228a1dceb0b7e06b63d3ac712a","tests/guests/yield_resume.c":"b9c19d9c2d540e042d3488f2cea04a7a98cc75910c68faad738ad835b04dde9d","tests/guests/yield_resume_bindings.json":"e124e940038a552d08495d6f99b7dd8495a011e4a082b32ab8d035e40169d663","tests/host.rs":"0cd5f40ed9725c7ef2f497a4e31f09e88833841240dfbfe971d60724075eac00","tests/instruction_counting.rs":"6aa8c2cf4c32adbbb5bf74e8449dd29d4deff77dcb55947a2d15c4eccbb89d6e","tests/instruction_counting/arithmetic_count.wat":"c347c7a78e4159e45aa5ba299f1d03e1efbb7c635f13dd23053907de7f57193b","tests/instruction_counting/br_table_count.wat":"66cdac7595bd69103f5d1b825a58f09a5624db4e35c91e11ae7b30cc2f53eb0c","tests/instruction_counting/calls.wat":"8212736a55a897937c712bab33c22c62ab96f1b32eef44eab1cbee77f34ba641","tests/instruction_counting/count_after_br.wat":"12df2019f3b0c518bd747e485b423f73a82c91571e834bdeed5d7bd6455f84c0","tests/instruction_counting/empty_loop.wat":"3dfa9ab297a7f8fd21bd22db8ded37de0545ac741be132fdcdf1a61c50cf455a","tests/instruction_counting/empty_loop_2.wat":"c65b4516a1a26f9b8b0117bb1f4fe9282e3bc79052b89f834cad6c202a51f68e","tests/instruction_counting/if_count.wat":"620330be046a3b3890646e8fdbbde6d4a8c4763b450d818ee549e103a1c3e3aa","tests/instruction_counting/if_not_taken_count.wat":"12bdc1f0512016e549bd7656386274c7b7b92d32b5d3eeb73b93d6ef18cc4ff2","tests/instruction_counting/indirect_calls.wat":"f56f6a715a733176168a81ca6cbfd22333ab9755029174a3f7950da9b401320e","tests/instruction_counting/loops.wat":"0cd765b1cf694a2c35df69547b30303731512c937cad05e1c052ebcd7840e3b1","tests/instruction_counting/unreachable_call.wat":"c15653c3ff198f321f8b892c363ec7badad75ec703c5b3a215a6dbfb059a15b7","tests/memory.rs":"73b65dc44978181a5d2a3b39a6d0fc60fd6637e16387c2a7b025baedb16a004f","tests/stack.rs":"5e5939991a55c8ecd579d8c509226ed3ac7bae5a847bdcdac4d285df28d54d6b","tests/start.rs":"7b31f8c289c1ad52d05f17c0c46b0856382b0ff85d6e5579c4346c443eb93fb3","tests/strcmp.rs":"7420aa723630af51360a9e9a3763c2fd8d7c57aa8d4011cfd8ca452376036efb","tests/val.rs":"2e38a7aa10bde34d5cf580a958c07eff8593662a86678427a79d8a5f5bc2efac"},"package":null}
\ No newline at end of file
+{"files":{"Cargo.toml":"d5bb2276a7550ff7863e938a82168d721f2eabb917599e953e556f645fe1b6e1","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","build.rs":"d56fd4e2fe9d0830aee061be443ef0b541ed98dd6a4233220a51745478b3fb77","include/lucet.h":"89ff353483287040e07e3f6eaeed4286cb06f541fb67057f9fdbbf844a7ec928","include/lucet_types.h":"95c7793034c71e123fac04ce61dc89f4930360b6d4af0f40582c84357fd6877d","include/lucet_val.h":"220b862b0280ac4f7962d44520f6cc34a47f3b3a34b8ecf389e6111cd95b8bf0","include/lucet_vmctx.h":"044ca80cf8cca51620de3f113a1c07c00ebecea108a45288f9b87e5e2fbb820c","src/c_api.rs":"97e28537fffeac5d21f09911a3474114997ce0268492edb8010ce8ca178a6c64","src/lib.rs":"48f0ba473b4da3616bddfce3cda00cf836eca3c9e7b055855156c1c167a6f908","tests/c_api.c":"772716a14ceed6913a3670d8ca3fcf0cb0c376493cabae4c8b527fb694554b7b","tests/entrypoint.rs":"1d0080e9f71a16f61e69c21922ac1c2207b2003fb13d3bacafb681be5cceb8b9","tests/globals.rs":"56248c5cefbaad546b08964d9193e5c16a461e974d1c9c520ebba3f1cf32af66","tests/guest_fault.rs":"cb4728d0851148f992c944199f4fc98595070d0879e1ddf5361419e4fc330ad3","tests/guests/null.c":"de2bf0dc98ac1acaef8cb856a300119aa1300d228a1dceb0b7e06b63d3ac712a","tests/guests/yield_resume.c":"b9c19d9c2d540e042d3488f2cea04a7a98cc75910c68faad738ad835b04dde9d","tests/guests/yield_resume_bindings.json":"e124e940038a552d08495d6f99b7dd8495a011e4a082b32ab8d035e40169d663","tests/host.rs":"0cd5f40ed9725c7ef2f497a4e31f09e88833841240dfbfe971d60724075eac00","tests/instruction_counting.rs":"6aa8c2cf4c32adbbb5bf74e8449dd29d4deff77dcb55947a2d15c4eccbb89d6e","tests/instruction_counting/arithmetic_count.wat":"c347c7a78e4159e45aa5ba299f1d03e1efbb7c635f13dd23053907de7f57193b","tests/instruction_counting/br_table_count.wat":"66cdac7595bd69103f5d1b825a58f09a5624db4e35c91e11ae7b30cc2f53eb0c","tests/instruction_counting/calls.wat":"8212736a55a897937c712bab33c22c62ab96f1b32eef44eab1cbee77f34ba641","tests/instruction_counting/count_after_br.wat":"12df2019f3b0c518bd747e485b423f73a82c91571e834bdeed5d7bd6455f84c0","tests/instruction_counting/empty_loop.wat":"3dfa9ab297a7f8fd21bd22db8ded37de0545ac741be132fdcdf1a61c50cf455a","tests/instruction_counting/empty_loop_2.wat":"c65b4516a1a26f9b8b0117bb1f4fe9282e3bc79052b89f834cad6c202a51f68e","tests/instruction_counting/if_count.wat":"620330be046a3b3890646e8fdbbde6d4a8c4763b450d818ee549e103a1c3e3aa","tests/instruction_counting/if_not_taken_count.wat":"12bdc1f0512016e549bd7656386274c7b7b92d32b5d3eeb73b93d6ef18cc4ff2","tests/instruction_counting/indirect_calls.wat":"f56f6a715a733176168a81ca6cbfd22333ab9755029174a3f7950da9b401320e","tests/instruction_counting/loops.wat":"0cd765b1cf694a2c35df69547b30303731512c937cad05e1c052ebcd7840e3b1","tests/instruction_counting/unreachable_call.wat":"c15653c3ff198f321f8b892c363ec7badad75ec703c5b3a215a6dbfb059a15b7","tests/memory.rs":"73b65dc44978181a5d2a3b39a6d0fc60fd6637e16387c2a7b025baedb16a004f","tests/stack.rs":"5e5939991a55c8ecd579d8c509226ed3ac7bae5a847bdcdac4d285df28d54d6b","tests/start.rs":"7b31f8c289c1ad52d05f17c0c46b0856382b0ff85d6e5579c4346c443eb93fb3","tests/strcmp.rs":"7420aa723630af51360a9e9a3763c2fd8d7c57aa8d4011cfd8ca452376036efb","tests/val.rs":"2e38a7aa10bde34d5cf580a958c07eff8593662a86678427a79d8a5f5bc2efac"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/lucet-runtime/Cargo.toml b/third_party/rust/lucet-runtime/Cargo.toml
index 0536d29cf50c..cb38fd5f93cd 100644
--- a/third_party/rust/lucet-runtime/Cargo.toml
+++ b/third_party/rust/lucet-runtime/Cargo.toml
@@ -36,7 +36,7 @@ signature_checking = ["lucet-module/signature_checking"]
 
 [lib]
 name = "lucet_runtime"
-crate-type = ["rlib", "staticlib", "cdylib"]
+crate-type = ["rlib", "staticlib"]
 
 [package.metadata.deb]
 name = "fst-lucet-runtime"
diff --git a/third_party/rust/lucet-runtime/include/lucet_types.h b/third_party/rust/lucet-runtime/include/lucet_types.h
index 820f943ceace..d419395c7c4a 100644
--- a/third_party/rust/lucet-runtime/include/lucet_types.h
+++ b/third_party/rust/lucet-runtime/include/lucet_types.h
@@ -122,6 +122,13 @@ struct lucet_alloc_limits {
      * Size of the globals region in bytes; each global uses 8 bytes. (default 4K)
      */
     uint64_t globals_size;
+    /**
+     * Size of the signal stack region in bytes.
+     *
+     * SIGSTKSZ from <signals.h> is a good default when linking against a Rust release build of
+     * lucet-runtime, but 12K or more is recommended when using a Rust debug build.
+     */
+    uint64_t signal_stack_size;
 };
 
 typedef enum lucet_signal_behavior (*lucet_signal_handler)(struct lucet_instance *   inst,
diff --git a/third_party/rust/lucet-runtime/tests/c_api.c b/third_party/rust/lucet-runtime/tests/c_api.c
index 4f2dc3418aca..b799d186f091 100644
--- a/third_party/rust/lucet-runtime/tests/c_api.c
+++ b/third_party/rust/lucet-runtime/tests/c_api.c
@@ -11,6 +11,7 @@ bool lucet_runtime_test_expand_heap(struct lucet_dl_module *mod)
         .heap_address_space_size = 8 * 1024 * 1024,
         .stack_size              = 64 * 1024,
         .globals_size            = 4096,
+        .signal_stack_size       = 12 * 1024,
     };
 
     enum lucet_error err;
@@ -97,6 +98,7 @@ bool lucet_runtime_test_yield_resume(struct lucet_dl_module *mod)
         .heap_address_space_size = 8 * 1024 * 1024,
         .stack_size              = 64 * 1024,
         .globals_size            = 4096,
+        .signal_stack_size       = 12 * 1024,
     };
 
     enum lucet_error err;
diff --git a/third_party/rust/lucet-wasi/.cargo-checksum.json b/third_party/rust/lucet-wasi/.cargo-checksum.json
index 6cf052a3225b..229fc9978c85 100644
--- a/third_party/rust/lucet-wasi/.cargo-checksum.json
+++ b/third_party/rust/lucet-wasi/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"8874fee1c359b1a1e18014cd0237bb1c54db182216ec4d41ca1bd360eff2573f","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","LICENSE.cloudabi-utils":"86a34251f0aab76b7dc3daf8d252afbdf481ea94aa5b46d020205178b7e2eac1","LICENSE.wasmtime":"a6c48161a09acc75a0e25503bab66a731eb5fba5392ed4bb4743e4ba5085327a","bindings.json":"fad8362f845e6f7a2af1d7547cee5730894e7b96804f338181fc070ffdcfae1e","build.rs":"593173ad03963afcbef43f1843be6f04cde1df3eae0298ca20bf881019dd350a","examples/.gitignore":"44575cf5b28512d75644bf54a517dcef304ff809fd511747621b4d64f19aac66","examples/Makefile":"d2d2ceeb1bc4435189ea9a2710b6f5f5331ce6aa73ae8a4f4edcca215058a9b4","examples/README.md":"f2a5be6cc88d511c9f4d3bfefdd42dcb2ace813bc23f6a4430b6b543f7373341","examples/hello.c":"9cbc0d3173e02309e15372835fa849d196b2a202d81806fea60378e1878d0c53","examples/pseudoquine.c":"8fd696f8e1b8fb86188564a05f4776875ead31d785a12e3aa4af9d9c1b46d5b5","include/lucet_wasi.h":"497f712c64f753ebdf73ab05b0b340d50094f9c59bb8637ccbf99d895cd20966","src/bindings.rs":"edbeb51d1a93fd31039ee1f1dc7c1b6c0bded2cf5dad10039e8b7da81a4d4a12","src/c_api.rs":"a9c73070a88a461882a28e3e2adfd773f569b964c7ffabde39a3cef907782f71","src/ctx.rs":"578f87c35cce12eaebec95d03e31954c3e6cd0afa214a0fec068f03814eb0cc7","src/fdentry.rs":"94a8480fa587e5586327dfd6b66d8a6a3ef1f8091ba8deb335bf45642f4f98e6","src/host.rs":"6f05f8fea2afed827abfc3c008a5854a8023d91d066580ecfb49e5c8036ef3a3","src/hostcalls/fs.rs":"18102b651f443e37197b2d808450c85535d3b39ff98d52844b4f5fd95e8018e6","src/hostcalls/fs_helpers.rs":"474bce0a1f15fa23b0b0b8aa83143d993dd2cbd7cdfc38c118d452d04e80caea","src/hostcalls/misc.rs":"2cb55f010d661f4e42dffc82d49d0970996de9437b8fd6f8e3b298dd898cd2f9","src/hostcalls/mod.rs":"7ffeb1c08825487d90dd516def21ddc303949d631792ac17a8f57d902993ffd1","src/lib.rs":"5554e1a3f0cd3756173ece6435a0d01b2f520b3401cd5fc33180a04fb9f69bbe","src/memory.rs":"0a09026b15d27f99d74e560cd94795f645cba414a8491bc961987fab9d9da69b","src/wasi_host.rs":"cacbdac28304a837b11e5ad400ae9de3ee79c0284be335e64606ecdfe426ad6e","src/wasm32.rs":"13a5dc6e59784662f1e55eccb457cbbae241a96f70cfa72c41d55858ca05b980","tests/guests/cant_dotdot.c":"609b8cece9443e375a0b38a7e43651b179f66ee9c686edba6696fe1bcd45b111","tests/guests/clock_getres.c":"f5e41c0a2b05a8d7cdb5b4da6c8b6778b858004c1e9d115503c45a1d976be33b","tests/guests/duplicate_import.wat":"4bd8d7a5c1d1597dbe7648300e94e3fab84d7ab068d56cfb656aa1a208026cee","tests/guests/exitcode.c":"b7c5cec3ead0ed82326c568287a1f3398e71ae7e447ce49a3c4c7114c82495af","tests/guests/follow_symlink.c":"de3143ad2bbbfe834c0c32b54c9fcf144ca4eba5cdcf7588929e5f47225ab616","tests/guests/fs.c":"0dca5232ff5da1b7745e3b44bca39333c01a20ba4eae1a6a0a1c492c71ca1efa","tests/guests/getentropy.c":"5d80bcc68dcf3ba91576969055099d61635ae713c057b3cb36afb122a5f26347","tests/guests/getrusage.c":"8114c103b85eb564d9ab43684958bc1939de3794d314b7c121762f3a2f0434a6","tests/guests/gettimeofday.c":"4a57f376b06f4228017b82695448a0bd213fb91455f5301d689cd87fcff01f06","tests/guests/notdir.c":"bd8f8b24360b7cf8d5dced9d9ba4c15843fcbbae89fecc13e3a457c33a275e28","tests/guests/poll.c":"aefaa9b58ce9906dc379e0bd25fa68dfbf8cdffb48cd5ecde1d67708b83b366d","tests/guests/preopen_populates.c":"f186e4eb4aab6a1d9ec7bc5c49eaea6d9d162e0159dfe8f953bb48ade9b58d43","tests/guests/read_file.c":"1aab9393f005f05b69592826d7c4d384a115d5bca42c66f10a901811b4b1dcac","tests/guests/read_file_twice.c":"04a3dad7a43b93e36efd4e2c822c11b3f129429ec799af304d82b358686c578a","tests/guests/stat.c":"02756933ea7d4337b4fa04344b32968851b02f9d0bd5ea1cb0e2f022e8c65ab0","tests/guests/stdin.c":"66efc4b54f68d1138046f1afefae15f7d4555b2904b4a988818e61e67fe8fefb","tests/guests/symlink_escape.c":"686e047b5c986e29c854bcd93996d027dcdc8721219fa9fa532efc98d2798f5c","tests/guests/symlink_loop.c":"2bbddf3a5edfc6e5f3c0fa82cee4ac92b18804810509e263abd17f5240cd37e5","tests/guests/write_file.c":"9e9b14552c2445cfa6d0aa26b334081a59e6e3428dbb17ceca005a9ba59d3220","tests/test_helpers/mod.rs":"bc18194317611fe1be5c439a7a9e0de75399555c3b6de4275af149fb180456c8","tests/tests.rs":"173a7e0f086f6ed46474686cc3413ee68bbd2ff67004f7790e963a1392c7c46e"},"package":null}
\ No newline at end of file
+{"files":{"Cargo.toml":"fea1408a1c1b1e84b06044a0b12cb26c8fd3253ca124debb6cd3e4faab48fcbd","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","LICENSE.cloudabi-utils":"86a34251f0aab76b7dc3daf8d252afbdf481ea94aa5b46d020205178b7e2eac1","LICENSE.wasmtime":"a6c48161a09acc75a0e25503bab66a731eb5fba5392ed4bb4743e4ba5085327a","bindings.json":"fad8362f845e6f7a2af1d7547cee5730894e7b96804f338181fc070ffdcfae1e","build.rs":"593173ad03963afcbef43f1843be6f04cde1df3eae0298ca20bf881019dd350a","examples/.gitignore":"44575cf5b28512d75644bf54a517dcef304ff809fd511747621b4d64f19aac66","examples/Makefile":"d2d2ceeb1bc4435189ea9a2710b6f5f5331ce6aa73ae8a4f4edcca215058a9b4","examples/README.md":"f2a5be6cc88d511c9f4d3bfefdd42dcb2ace813bc23f6a4430b6b543f7373341","examples/hello.c":"9cbc0d3173e02309e15372835fa849d196b2a202d81806fea60378e1878d0c53","examples/pseudoquine.c":"8fd696f8e1b8fb86188564a05f4776875ead31d785a12e3aa4af9d9c1b46d5b5","include/lucet_wasi.h":"497f712c64f753ebdf73ab05b0b340d50094f9c59bb8637ccbf99d895cd20966","src/bindings.rs":"edbeb51d1a93fd31039ee1f1dc7c1b6c0bded2cf5dad10039e8b7da81a4d4a12","src/c_api.rs":"a9c73070a88a461882a28e3e2adfd773f569b964c7ffabde39a3cef907782f71","src/ctx.rs":"578f87c35cce12eaebec95d03e31954c3e6cd0afa214a0fec068f03814eb0cc7","src/fdentry.rs":"94a8480fa587e5586327dfd6b66d8a6a3ef1f8091ba8deb335bf45642f4f98e6","src/host.rs":"6f05f8fea2afed827abfc3c008a5854a8023d91d066580ecfb49e5c8036ef3a3","src/hostcalls/fs.rs":"4726e6f695f7d1d4e371ec52c57f4e36b0ba0d2302fc008b21a301f5fd7a5c97","src/hostcalls/fs_helpers.rs":"474bce0a1f15fa23b0b0b8aa83143d993dd2cbd7cdfc38c118d452d04e80caea","src/hostcalls/misc.rs":"83d087891d92af08cfa2d2e0c5f41cc47cb8219460f6dbcc8666b418dfef206e","src/hostcalls/mod.rs":"4c5d3f65c69503e11e647770879026c37c0e5e01a99b7116c8fb9411b4797187","src/hostcalls/timers.rs":"e65d6a491256b5d6051b6816f6c5049ba3cdc6142651bac81f34d659c1c2a104","src/lib.rs":"5554e1a3f0cd3756173ece6435a0d01b2f520b3401cd5fc33180a04fb9f69bbe","src/memory.rs":"0a09026b15d27f99d74e560cd94795f645cba414a8491bc961987fab9d9da69b","src/wasi_host.rs":"cacbdac28304a837b11e5ad400ae9de3ee79c0284be335e64606ecdfe426ad6e","src/wasm32.rs":"13a5dc6e59784662f1e55eccb457cbbae241a96f70cfa72c41d55858ca05b980","tests/guests/cant_dotdot.c":"609b8cece9443e375a0b38a7e43651b179f66ee9c686edba6696fe1bcd45b111","tests/guests/clock_getres.c":"f5e41c0a2b05a8d7cdb5b4da6c8b6778b858004c1e9d115503c45a1d976be33b","tests/guests/duplicate_import.wat":"4bd8d7a5c1d1597dbe7648300e94e3fab84d7ab068d56cfb656aa1a208026cee","tests/guests/exitcode.c":"b7c5cec3ead0ed82326c568287a1f3398e71ae7e447ce49a3c4c7114c82495af","tests/guests/follow_symlink.c":"de3143ad2bbbfe834c0c32b54c9fcf144ca4eba5cdcf7588929e5f47225ab616","tests/guests/fs.c":"0dca5232ff5da1b7745e3b44bca39333c01a20ba4eae1a6a0a1c492c71ca1efa","tests/guests/getentropy.c":"5d80bcc68dcf3ba91576969055099d61635ae713c057b3cb36afb122a5f26347","tests/guests/getrusage.c":"8114c103b85eb564d9ab43684958bc1939de3794d314b7c121762f3a2f0434a6","tests/guests/gettimeofday.c":"4a57f376b06f4228017b82695448a0bd213fb91455f5301d689cd87fcff01f06","tests/guests/notdir.c":"bd8f8b24360b7cf8d5dced9d9ba4c15843fcbbae89fecc13e3a457c33a275e28","tests/guests/poll.c":"aefaa9b58ce9906dc379e0bd25fa68dfbf8cdffb48cd5ecde1d67708b83b366d","tests/guests/preopen_populates.c":"f186e4eb4aab6a1d9ec7bc5c49eaea6d9d162e0159dfe8f953bb48ade9b58d43","tests/guests/read_file.c":"1aab9393f005f05b69592826d7c4d384a115d5bca42c66f10a901811b4b1dcac","tests/guests/read_file_twice.c":"04a3dad7a43b93e36efd4e2c822c11b3f129429ec799af304d82b358686c578a","tests/guests/stat.c":"02756933ea7d4337b4fa04344b32968851b02f9d0bd5ea1cb0e2f022e8c65ab0","tests/guests/stdin.c":"66efc4b54f68d1138046f1afefae15f7d4555b2904b4a988818e61e67fe8fefb","tests/guests/symlink_escape.c":"686e047b5c986e29c854bcd93996d027dcdc8721219fa9fa532efc98d2798f5c","tests/guests/symlink_loop.c":"2bbddf3a5edfc6e5f3c0fa82cee4ac92b18804810509e263abd17f5240cd37e5","tests/guests/write_file.c":"9e9b14552c2445cfa6d0aa26b334081a59e6e3428dbb17ceca005a9ba59d3220","tests/test_helpers/mod.rs":"bc18194317611fe1be5c439a7a9e0de75399555c3b6de4275af149fb180456c8","tests/tests.rs":"173a7e0f086f6ed46474686cc3413ee68bbd2ff67004f7790e963a1392c7c46e"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/lucet-wasi/Cargo.toml b/third_party/rust/lucet-wasi/Cargo.toml
index 1afd111e8e6a..4800ae3ae0a9 100644
--- a/third_party/rust/lucet-wasi/Cargo.toml
+++ b/third_party/rust/lucet-wasi/Cargo.toml
@@ -33,6 +33,9 @@ lucet-module = { path = "../lucet-module", version = "0.1.1" }
 nix = "0.13"
 rand = "0.7"
 
+[target.'cfg(target_os = "macos")'.dependencies]
+mach = "0.3.2"
+
 [dev-dependencies]
 lucet-wasi-sdk = { path = "../lucet-wasi-sdk", version = "0.1.1" }
 lucetc = { path = "../lucetc", version = "0.1.1" }
@@ -44,7 +47,7 @@ optional = true
 
 [lib]
 name = "lucet_wasi"
-crate-type = ["rlib", "staticlib", "cdylib"]
+crate-type = ["rlib", "staticlib"]
 
 [package.metadata.deb]
 name = "fst-lucet-wasi"
diff --git a/third_party/rust/lucet-wasi/src/hostcalls/fs.rs b/third_party/rust/lucet-wasi/src/hostcalls/fs.rs
index 7eaee5352cd8..db1a0c5d2d86 100644
--- a/third_party/rust/lucet-wasi/src/hostcalls/fs.rs
+++ b/third_party/rust/lucet-wasi/src/hostcalls/fs.rs
@@ -7,6 +7,7 @@ use crate::memory::*;
 use crate::{host, wasm32};
 
 use super::fs_helpers::*;
+use super::timers;
 use lucet_runtime::vmctx::Vmctx;
 
 use nix::libc::{self, c_long, c_void, off_t};
@@ -821,7 +822,7 @@ pub fn wasi_fd_filestat_set_times(
     if fst_flags & (host::__WASI_FILESTAT_SET_MTIM_NOW as host::__wasi_fstflags_t) != 0 {
         let clock_id = libc::CLOCK_REALTIME;
         let mut timespec = MaybeUninit::<libc::timespec>::uninit();
-        let res = unsafe { libc::clock_gettime(clock_id, timespec.as_mut_ptr()) };
+        let res = unsafe { timers::clock_gettime_helper(clock_id, timespec.as_mut_ptr()) };
         if res != 0 {
             return wasm32::errno_from_nix(nix::errno::Errno::last());
         }
@@ -850,7 +851,7 @@ pub fn wasi_fd_filestat_set_times(
     };
     let ts_mtime = *TimeSpec::nanoseconds(st_mtim as i64).as_ref();
     let times = [ts_atime, ts_mtime];
-    let res = unsafe { libc::futimens(fe.fd_object.rawfd, times.as_ptr()) };
+    let res = unsafe { timers::futimens_helper(fe.fd_object.rawfd, times.as_ptr()) };
     if res != 0 {
         return wasm32::errno_from_nix(nix::errno::Errno::last());
     }
@@ -890,7 +891,7 @@ pub fn wasi_path_filestat_set_times(
     if fst_flags & (host::__WASI_FILESTAT_SET_MTIM_NOW as host::__wasi_fstflags_t) != 0 {
         let clock_id = libc::CLOCK_REALTIME;
         let mut timespec = MaybeUninit::<libc::timespec>::uninit();
-        let res = unsafe { libc::clock_gettime(clock_id, timespec.as_mut_ptr()) };
+        let res = unsafe { timers::clock_gettime_helper(clock_id, timespec.as_mut_ptr()) };
         if res != 0 {
             return wasm32::errno_from_nix(nix::errno::Errno::last());
         }
@@ -923,7 +924,7 @@ pub fn wasi_path_filestat_set_times(
         Ok(path_cstr) => path_cstr,
         Err(_) => return wasm32::__WASI_EINVAL,
     };
-    let res = unsafe { libc::utimensat(dir, path_cstr.as_ptr(), times.as_ptr(), atflags) };
+    let res = unsafe { timers::utimensat_helper(dir, path_cstr.as_ptr(), times.as_ptr(), atflags) };
     if res != 0 {
         return wasm32::errno_from_nix(nix::errno::Errno::last());
     }
diff --git a/third_party/rust/lucet-wasi/src/hostcalls/misc.rs b/third_party/rust/lucet-wasi/src/hostcalls/misc.rs
index 75f0600098cf..39ab5109c1c2 100644
--- a/third_party/rust/lucet-wasi/src/hostcalls/misc.rs
+++ b/third_party/rust/lucet-wasi/src/hostcalls/misc.rs
@@ -5,6 +5,8 @@ use crate::ctx::WasiCtx;
 use crate::memory::*;
 use crate::{host, wasm32};
 
+use super::timers;
+
 use cast::From as _0;
 use lucet_runtime::lucet_hostcall_terminate;
 use lucet_runtime::vmctx::Vmctx;
@@ -125,7 +127,7 @@ pub fn wasi_clock_res_get(
 
     // no `nix` wrapper for clock_getres, so we do it ourselves
     let mut timespec = MaybeUninit::<libc::timespec>::uninit();
-    let res = unsafe { libc::clock_getres(clock_id, timespec.as_mut_ptr()) };
+    let res = unsafe { timers::clock_getres_helper(clock_id, timespec.as_mut_ptr()) };
     if res != 0 {
         return wasm32::errno_from_nix(nix::errno::Errno::last());
     }
@@ -169,7 +171,7 @@ pub fn wasi_clock_time_get(
 
     // no `nix` wrapper for clock_getres, so we do it ourselves
     let mut timespec = MaybeUninit::<libc::timespec>::uninit();
-    let res = unsafe { libc::clock_gettime(clock_id, timespec.as_mut_ptr()) };
+    let res = unsafe { timers::clock_gettime_helper(clock_id, timespec.as_mut_ptr()) };
     if res != 0 {
         return wasm32::errno_from_nix(nix::errno::Errno::last());
     }
diff --git a/third_party/rust/lucet-wasi/src/hostcalls/mod.rs b/third_party/rust/lucet-wasi/src/hostcalls/mod.rs
index 450468176c44..ed9b5e038d78 100644
--- a/third_party/rust/lucet-wasi/src/hostcalls/mod.rs
+++ b/third_party/rust/lucet-wasi/src/hostcalls/mod.rs
@@ -10,6 +10,7 @@
 mod fs;
 mod fs_helpers;
 mod misc;
+mod timers;
 
 use crate::wasm32;
 
diff --git a/third_party/rust/lucet-wasi/src/hostcalls/timers.rs b/third_party/rust/lucet-wasi/src/hostcalls/timers.rs
new file mode 100644
index 000000000000..926a9984454a
--- /dev/null
+++ b/third_party/rust/lucet-wasi/src/hostcalls/timers.rs
@@ -0,0 +1,113 @@
+use nix::libc::{self, c_int, c_char};
+
+#[cfg(not(target_os = "macos"))]
+mod notmac
+{
+    use super::*;
+
+    pub unsafe fn clock_gettime_helper(clock_id: libc::clockid_t, tp: *mut libc::timespec) -> c_int {
+        libc::clock_gettime(clock_id, tp)
+    }
+
+    pub unsafe fn clock_getres_helper(clock_id: libc::clockid_t, res: *mut libc::timespec) -> c_int {
+        libc::clock_getres(clock_id, res)
+    }
+
+    pub unsafe fn futimens_helper(fd: c_int, times: *const libc::timespec) -> c_int {
+        libc::futimens(fd, times)
+    }
+
+    pub unsafe fn utimensat_helper(dirfd: c_int, path: *const c_char, times: *const libc::timespec, flag: c_int) -> c_int {
+        libc::utimensat(dirfd, path, times, flag)
+    }
+}
+
+#[cfg(target_os = "macos")]
+mod mac
+{
+    use super::*;
+    use std::mem::MaybeUninit;
+    use std::sync::Once;
+
+    use mach::mach_time::*;
+
+    // Referring these 3 sources
+    //https://stackoverflow.com/questions/5167269/clock-gettime-alternative-in-mac-os-x
+    //https://stackoverflow.com/questions/11680461/monotonic-clock-on-osx
+    //https://gist.github.com/lifthrasiir/393ffb3e9900709fa2e3ae2a540b635f
+
+    static mut CONVERSION_FACTOR : f64 = 0.0;
+    static INIT : Once = Once::new();
+
+    unsafe fn get_cached_conversion_factor() -> f64 {
+        unsafe {
+            INIT.call_once(|| {
+                let mut timebase = MaybeUninit::<mach_timebase_info_data_t>::uninit();
+                mach_timebase_info(timebase.as_mut_ptr());
+                let timebase = unsafe { timebase.assume_init() };
+            
+                let numer_d : f64 = timebase.numer as f64;
+                let denom_d : f64 = timebase.denom as f64;
+            
+                CONVERSION_FACTOR = numer_d / denom_d;
+            });
+        }
+        CONVERSION_FACTOR
+    }
+
+    pub unsafe fn clock_gettime_helper(clock_id: libc::clockid_t, tp: *mut libc::timespec) -> c_int {
+        if !(clock_id == libc::CLOCK_REALTIME || clock_id == libc::CLOCK_MONOTONIC) {
+            (*libc::__error()) = libc::EINVAL;
+            return -1;
+        }
+
+        if clock_id == libc::CLOCK_REALTIME {
+            let mut micro = MaybeUninit::<libc::timeval>::uninit();
+            libc::gettimeofday(micro.as_mut_ptr(), core::ptr::null_mut());
+            let micro = unsafe { micro.assume_init() };
+      
+            (*tp).tv_sec = micro.tv_sec;
+            (*tp).tv_nsec = i64::from(micro.tv_usec) * 1000;
+            return 0;
+        } else {
+            let time : u64 = mach_absolute_time();
+            let time_d : f64 = time as f64;
+            let conv : f64 = get_cached_conversion_factor();
+            let nseconds : f64 = time_d * conv;
+            let seconds : f64 = nseconds / 1e9;
+            (*tp).tv_sec = seconds as i64;
+            (*tp).tv_nsec = nseconds as i64;
+            return 0;
+        }
+    }
+
+    pub unsafe fn clock_getres_helper(clock_id: libc::clockid_t, res: *mut libc::timespec) -> c_int {
+        if !(clock_id == libc::CLOCK_REALTIME || clock_id == libc::CLOCK_MONOTONIC) {
+            (*libc::__error()) = libc::EINVAL;
+            return -1;
+        }
+
+        (*res).tv_sec = 0 as i64;
+        (*res).tv_nsec = 
+            if clock_id == libc::CLOCK_REALTIME {
+                1000 as i64
+            } else {
+                1 as i64
+            };
+        return 0;
+    }
+
+    pub unsafe fn futimens_helper(_fd: c_int, _times: *const libc::timespec) -> c_int {
+        panic!("futimens not implemented");
+    }
+
+    pub unsafe fn utimensat_helper(_dirfd: c_int, _path: *const c_char, _times: *const libc::timespec, _flag: c_int) -> c_int {
+        panic!("utimensat not implemented");
+    }
+}
+
+#[cfg(not(target_os = "macos"))]
+pub use notmac::*;
+
+#[cfg(target_os = "macos")]
+pub use mac::*;
\ No newline at end of file
diff --git a/third_party/rust/mach/.cargo-checksum.json b/third_party/rust/mach/.cargo-checksum.json
new file mode 100644
index 000000000000..0158b060d233
--- /dev/null
+++ b/third_party/rust/mach/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.toml":"6cf25dae1f0fd842fb63275ae47904879e66b36290f6fc7ed02090f3ac657b51","LICENSE.md":"399507a62fba271ddb3e24dc857e85b571fbb76435546f51b212cf04d8463f58","README.md":"8e5094a355def0f762dcc92fd68f475bb65016dd0fbeadc0d8a50303d6fb5381","ci/build_fail.sh":"6c2401edd356a43739ef6c27deccfc7703f883ff8d21f49395d8edb806542728","ci/deploy_and_run_on_ios_simulator.rs":"acde74c117544575b2e7ef7531759ec0a6e28bd65d69da16944c746f711ec27d","ci/run.sh":"2eef6140f5f53373f961c682d2b292f8d4b57b2124f1f0e53d5168db27f38d52","examples/dump_process_registers.rs":"e9d0d023cb2cc8272f239cd134152dfa0169017c2a454db1490d2f4548efe6c8","src/boolean.rs":"1d24ea9872748881cd7269a383a7c344e3a650df23f0e44e3b6c266fb8205d9a","src/bootstrap.rs":"a5ab69d74ad8bfb8fad1cb45c8c571977c0bf907a70e767309a437580cee184c","src/clock.rs":"a33c1bfb2f174abb695d164c469ee744be52fec4bc345656e6027d063e150d71","src/clock_priv.rs":"a8e6a96896a94eda67c9fb6e45c564581a711cc9fdcf7674251bb6c0c28b47c2","src/clock_reply.rs":"bac04b6602dcdd4daac8e3a0a1e56fa4b6de20cf2c3fe7bb583358166aca8a3b","src/clock_types.rs":"d55d1d2a953e477f9dd064bd684b118235aa7bd79de85cdeaf75e21510aaaefa","src/dyld_kernel.rs":"566a17f597aa29619a1ce15f6b22577fc70ac5356f96e00fddbcb28560a5c83c","src/exc.rs":"2246493bef2c596b92f115ab673a10d50c6003d11abb8e73d7707ebc19e8ae5a","src/exception_types.rs":"c7894831d73145adb1a4b5d2a5d0b346f2b2dc05382b97f2f3f0275d337f6dfc","src/kern_return.rs":"153339995674136ef05d9595bdcf831595db0d0714a737ecd1ccd45391c56657","src/lib.rs":"7570054fdec1fb73200cb1cf736c97bdeeb82f2aef78aec11e8498af769bba86","src/mach_init.rs":"df49bd287fd05fb74bc76254df7607fad0d6b90cb20da803e9f9a1dc2fcfe2fc","src/mach_port.rs":"07e300871eac4687ccc98d725e550482f136f9780f9f353a0f01f768bc58229b","src/mach_time.rs":"b9493e820acf21fee1f6e7e82a510d887925dc1117d6b71b681acc40cfa776af","src/mach_types.rs":"e2d17741ebcdcdff9686ec9ee5c90fb7a150ce990979507da01c351771fb3a19","src/memory_object_types.rs":"6fcb446c00ddd5ef4920efe618bd89df2e87f7ae3cf660a2bc1d25cf1f331dc2","src/message.rs":"501e743438342ea37cf7db81d6ebd17528da9d78e77d1f1643412e7dc569649f","src/port.rs":"36fc636e2cae2c1f69246b54eb3ca2b33d7e75846df50587fb14597d34b05594","src/structs.rs":"132e21e91313e6ec13e3ad5ed9c71852e8a55fbbaba449dbb1b3ca889bed4889","src/task.rs":"282ea602db2d08711785e0050a06b322a3fe4a4aac34b3c9116fe13e033898dd","src/task_info.rs":"cf87cffe567fee8871e0ce9762b7d8bbd5058dfbb309678d382149dedbe7f14a","src/thread_act.rs":"647198e0f9e3fe409a0610ee98560de3af4f152bcc4761f943e67723193b8a25","src/thread_status.rs":"3fe98fadd61ce01b4f9dc3bc0ef8c9496798f0147822a4ddffe5d0eaf2f32c0a","src/traps.rs":"a15d0dc206c53cf69cb9d11c6ed5477b7dd9937ea68b5a453011be9d004c44a9","src/vm.rs":"9edecf858dcd8e22efbc6ad1838cbfa6a0fc5b334bd21d87b3f05d24058b549e","src/vm_attributes.rs":"55fd9c1661a147a4e374051a6da1884f0c9629aabc514e01561f0e0c365aa18a","src/vm_behavior.rs":"a5d195a52602f5ebe2991774c2390a6f20f1bfa82168dd62e88f2804134da1f3","src/vm_inherit.rs":"dbc7432350869733d6e7cf1da8617d97aafbeb1afcb1bdc60ed7ab53e37abf61","src/vm_page_size.rs":"9e5333f750cd7380465cd34b4611c1f7b5251c11befca0d4482a323e0b1c20b2","src/vm_prot.rs":"15f8f82fbdd67ed31185abd5cc3418332f4371d39ecef6a7e47ddf17bdb5146c","src/vm_purgable.rs":"a39a9fcd85f0394cd169c888e2d7e461d56bf97cf9f81a384df06262e40c9f24","src/vm_region.rs":"d95de52828f28987fa95eb54327b2d278f31769091befb653d286b21d51efc73","src/vm_statistics.rs":"49b452bf56080200d6bf3c32ae8b6642b142fbb13560849ef6a2dc96b650ab4a","src/vm_sync.rs":"4897306cf6c57929830766253637c9adc475e472949a351efc8ada28c20e0d0f","src/vm_types.rs":"a47f71193172ce233018dfd40de2b9a56cdfcdfb18e04c1c0761cb6fc36f51b8"},"package":"b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa"}
\ No newline at end of file
diff --git a/third_party/rust/mach/Cargo.toml b/third_party/rust/mach/Cargo.toml
new file mode 100644
index 000000000000..ea6d375c2c54
--- /dev/null
+++ b/third_party/rust/mach/Cargo.toml
@@ -0,0 +1,46 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+edition = "2015"
+name = "mach"
+version = "0.3.2"
+authors = ["Nick Fitzgerald <fitzgen@gmail.com>", "David Cuddeback <david.cuddeback@gmail.com>", "Gonzalo Brito Gadeschi <gonzalobg88@gmail.com>"]
+description = "A Rust interface to the user-space API of the Mach 3.0 kernel that underlies OSX."
+readme = "README.md"
+keywords = ["kernel", "macos", "darwin"]
+categories = ["api-bindings", "external-ffi-bindings", "no-std", "os"]
+license = "BSD-2-Clause"
+repository = "https://github.com/fitzgen/mach"
+
+[features]
+default = []
+deprecated = []
+rustc-dep-of-std = ["rustc-std-workspace-core", "libc/rustc-dep-of-std"]
+[target."cfg(any(target_os = \"macos\", target_os = \"ios\"))".dependencies.libc]
+version = "0.2"
+default-features = false
+
+[target."cfg(any(target_os = \"macos\", target_os = \"ios\"))".dependencies.rustc-std-workspace-core]
+version = "1.0.0"
+optional = true
+[badges.is-it-maintained-issue-resolution]
+repository = "fitzgen/mach"
+
+[badges.is-it-maintained-open-issues]
+repository = "fitzgen/mach"
+
+[badges.maintenance]
+status = "passively-maintained"
+
+[badges.travis-ci]
+repository = "fitzgen/mach"
diff --git a/third_party/rust/mach/LICENSE.md b/third_party/rust/mach/LICENSE.md
new file mode 100644
index 000000000000..ee1e887d14f4
--- /dev/null
+++ b/third_party/rust/mach/LICENSE.md
@@ -0,0 +1,23 @@
+Copyright (c) 2015, Nick Fitzgerald
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/third_party/rust/mach/README.md b/third_party/rust/mach/README.md
new file mode 100644
index 000000000000..cb5f93b7562d
--- /dev/null
+++ b/third_party/rust/mach/README.md
@@ -0,0 +1,55 @@
+[![Build Status][travis_ci_badge]][travis_ci] [![Latest Version]][crates.io] [![docs]][docs.rs]
+
+A Rust interface to the **user-space** API of the Mach 3.0 kernel exposed in
+`/usr/include/mach` that underlies macOS and is linked via `libSystem` (and
+`libsystem_kernel`).
+
+This library does not expose the **kernel-space** API of the Mach 3.0 kernel
+exposed in
+`SDK/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/mach`. 
+
+That is, if you are writing a kernel-resident device drivers or some other
+kernel extensions you have to use something else. The user-space kernel API is
+often API-incompatible with the kernel space one, and even in the cases where
+they match, they are sometimes ABI incompatible such that using this library
+would have **undefined behavior**.
+
+# Usage
+
+Add the following to your `Cargo.toml` to conditionally include mach on those
+platforms that support it.
+
+```toml
+[target.'cfg(any(target_os = "macos", target_os = "ios"))'.dependencies.mach]
+version = "0.3"
+```
+
+The following crate features are available:
+
+* **deprecated** (disabled by default): exposes deprecated APIs that have been
+  removed from the latest versions of the MacOS SDKs. The behavior of using
+  these APIs on MacOS versions that do not support them is undefined (hopefully
+  a linker error).
+
+# Platform support
+
+The following table describes the current CI set-up:
+
+| Target                | Min. Rust | XCode         | build | ctest | run |
+|-----------------------|-----------|---------------|-------|-------|-----|
+| `x86_64-apple-darwin` | 1.33.0    | 6.4 - 10.0    | ✓     | ✓     | ✓   |
+| `i686-apple-darwin`   | 1.33.0    | 6.4 - 10.0    | ✓     | ✓     | ✓   |
+| `i386-apple-ios`      | 1.33.0    | 6.4 - 9.4 [0] | ✓     | -     | -   |
+| `x86_64-apple-ios`    | 1.33.0    | 6.4 - 10.0    | ✓     | -     | -   |
+| `armv7-apple-ios`     | nightly   | 6.4 - 10.0    | ✓     | -     | -   |
+| `aarch64-apple-ios`   | nightly   | 6.4 - 10.0    | ✓     | -     | -   |
+
+[0] `i386-apple-ios` is deprecated in XCode 10.0.
+
+[travis_ci]: https://travis-ci.org/fitzgen/mach
+[travis_ci_badge]: https://travis-ci.org/fitzgen/mach.png?branch=master
+[crates.io]: https://crates.io/crates/mach
+[Latest Version]: https://img.shields.io/crates/v/mach.svg
+[docs]: https://docs.rs/mach/badge.svg
+[docs.rs]: https://docs.rs/mach/
+
diff --git a/third_party/rust/mach/ci/build_fail.sh b/third_party/rust/mach/ci/build_fail.sh
new file mode 100755
index 000000000000..ef3596546849
--- /dev/null
+++ b/third_party/rust/mach/ci/build_fail.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+
+set -ex
+
+: "${TARGET?The TARGET environment variable must be set.}"
+
+! cargo build --target "${TARGET}"
diff --git a/third_party/rust/mach/ci/deploy_and_run_on_ios_simulator.rs b/third_party/rust/mach/ci/deploy_and_run_on_ios_simulator.rs
new file mode 100644
index 000000000000..c0bc21dbc731
--- /dev/null
+++ b/third_party/rust/mach/ci/deploy_and_run_on_ios_simulator.rs
@@ -0,0 +1,175 @@
+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+// This is a script to deploy and execute a binary on an iOS simulator.
+// The primary use of this is to be able to run unit tests on the simulator and
+// retrieve the results.
+//
+// To do this through Cargo instead, use Dinghy
+// (https://github.com/snipsco/dinghy): cargo dinghy install, then cargo dinghy
+// test.
+//
+// Source: this script is part of libc
+// https://github.com/rust-lang/libc/blob/master/ci/ios/deploy_and_run_on_ios_simulator.rs
+// and should be sync'ed with it when ci breaks (or periodically).
+
+use std::env;
+use std::fs::{self, File};
+use std::io::Write;
+use std::path::Path;
+use std::process;
+use std::process::Command;
+
+macro_rules! t {
+    ($e:expr) => (match $e {
+        Ok(e) => e,
+        Err(e) => panic!("{} failed with: {}", stringify!($e), e),
+    })
+}
+
+// Step one: Wrap as an app
+fn package_as_simulator_app(crate_name: &str, test_binary_path: &Path) {
+    println!("Packaging simulator app");
+    drop(fs::remove_dir_all("ios_simulator_app"));
+    t!(fs::create_dir("ios_simulator_app"));
+    t!(fs::copy(test_binary_path,
+                Path::new("ios_simulator_app").join(crate_name)));
+
+    let mut f = t!(File::create("ios_simulator_app/Info.plist"));
+    t!(f.write_all(format!(r#"
+        <?xml version="1.0" encoding="UTF-8"?>
+        <!DOCTYPE plist PUBLIC
+                "-//Apple//DTD PLIST 1.0//EN"
+                "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+        <plist version="1.0">
+            <dict>
+                <key>CFBundleExecutable</key>
+                <string>{}</string>
+                <key>CFBundleIdentifier</key>
+                <string>com.rust.unittests</string>
+            </dict>
+        </plist>
+    "#, crate_name).as_bytes()));
+}
+
+// Step two: Start the iOS simulator
+fn start_simulator() {
+    println!("Looking for iOS simulator");
+    let output = t!(Command::new("xcrun").arg("simctl").arg("list").output());
+    assert!(output.status.success());
+    let mut simulator_exists = false;
+    let mut simulator_booted = false;
+    let mut found_rust_sim = false;
+    let stdout = t!(String::from_utf8(output.stdout));
+    for line in stdout.lines() {
+        if line.contains("rust_ios") {
+            if found_rust_sim {
+                panic!("Duplicate rust_ios simulators found. Please \
+                        double-check xcrun simctl list.");
+            }
+            simulator_exists = true;
+            simulator_booted = line.contains("(Booted)");
+            found_rust_sim = true;
+        }
+    }
+
+    if simulator_exists == false {
+        println!("Creating iOS simulator");
+        Command::new("xcrun")
+                .arg("simctl")
+                .arg("create")
+                .arg("rust_ios")
+                .arg("com.apple.CoreSimulator.SimDeviceType.iPhone-SE")
+                .arg("com.apple.CoreSimulator.SimRuntime.iOS-10-2")
+                .check_status();
+    } else if simulator_booted == true {
+        println!("Shutting down already-booted simulator");
+        Command::new("xcrun")
+                .arg("simctl")
+                .arg("shutdown")
+                .arg("rust_ios")
+                .check_status();
+    }
+
+    println!("Starting iOS simulator");
+    // We can't uninstall the app (if present) as that will hang if the
+    // simulator isn't completely booted; just erase the simulator instead.
+    Command::new("xcrun").arg("simctl").arg("erase").arg("rust_ios").check_status();
+    Command::new("xcrun").arg("simctl").arg("boot").arg("rust_ios").check_status();
+}
+
+// Step three: Install the app
+fn install_app_to_simulator() {
+    println!("Installing app to simulator");
+    Command::new("xcrun")
+            .arg("simctl")
+            .arg("install")
+            .arg("booted")
+            .arg("ios_simulator_app/")
+            .check_status();
+}
+
+// Step four: Run the app
+fn run_app_on_simulator() {
+    println!("Running app");
+    let output = t!(Command::new("xcrun")
+                    .arg("simctl")
+                    .arg("launch")
+                    .arg("--console")
+                    .arg("booted")
+                    .arg("com.rust.unittests")
+                    .output());
+
+    println!("stdout --\n{}\n", String::from_utf8_lossy(&output.stdout));
+    println!("stderr --\n{}\n", String::from_utf8_lossy(&output.stderr));
+
+    let stdout = String::from_utf8_lossy(&output.stdout);
+    let passed = stdout.lines()
+                       .find(|l| l.contains("PASSED"))
+                       .map(|l| l.contains("tests"))
+                       .unwrap_or(false);
+
+    println!("Shutting down simulator");
+    Command::new("xcrun")
+        .arg("simctl")
+        .arg("shutdown")
+        .arg("rust_ios")
+        .check_status();
+    if !passed {
+        panic!("tests didn't pass");
+    }
+}
+
+trait CheckStatus {
+    fn check_status(&mut self);
+}
+
+impl CheckStatus for Command {
+    fn check_status(&mut self) {
+        println!("\trunning: {:?}", self);
+        assert!(t!(self.status()).success());
+    }
+}
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+    if args.len() != 2 {
+        println!("Usage: {} <executable>", args[0]);
+        process::exit(-1);
+    }
+
+    let test_binary_path = Path::new(&args[1]);
+    let crate_name = test_binary_path.file_name().unwrap();
+
+    package_as_simulator_app(crate_name.to_str().unwrap(), test_binary_path);
+    start_simulator();
+    install_app_to_simulator();
+    run_app_on_simulator();
+}
diff --git a/third_party/rust/mach/ci/run.sh b/third_party/rust/mach/ci/run.sh
new file mode 100755
index 000000000000..9d814705c90c
--- /dev/null
+++ b/third_party/rust/mach/ci/run.sh
@@ -0,0 +1,57 @@
+#!/usr/bin/env sh
+
+set -ex
+
+: "${TARGET?The TARGET environment variable must be set.}"
+: "${TRAVIS_RUST_VERSION?The TRAVIS_RUST_VERSION environment variable must be set.}"
+
+echo "Running tests for target: ${TARGET}"
+export RUST_BACKTRACE=1
+export RUST_TEST_THREADS=1
+export RUST_TEST_NOCAPTURE=1
+export CARGO_INCREMENTAL=0
+export CARGO_CODEGEN_UNITS=1
+export RUSTFLAGS="-C codegen-units=1 "
+
+case "${TARGET}" in
+    *"ios"*)
+        export RUSTFLAGS="${RUSTFLAGS} -C link-args=-mios-simulator-version-min=7.0"
+        rustc ./ci/deploy_and_run_on_ios_simulator.rs -o ios_cargo_runner --verbose
+        if [ "${TARGET}" = "x86_64-apple-ios" ]; then
+            export CARGO_TARGET_X86_64_APPLE_IOS_RUNNER
+            CARGO_TARGET_X86_64_APPLE_IOS_RUNNER="$(pwd)/ios_cargo_runner"
+        fi
+        if [ "${TARGET}" = "i386-apple-ios" ]; then
+            export CARGO_TARGET_I386_APPLE_IOS_RUNNER
+            CARGO_TARGET_I386_APPLE_IOS_RUNNER="$(pwd)/ios_cargo_runner"
+        fi
+        ;;
+    *)
+        ;;
+esac
+
+# Build w/o std
+cargo clean
+cargo build --no-default-features --target "${TARGET}" -vv 2>&1 | tee build_no_std.txt
+
+# Check that the no-std builds are not linked against a libc with default
+# features or the std feature enabled:
+! grep -q "default" build_no_std.txt
+! grep -q "std" build_no_std.txt
+# Make sure that the resulting build contains no std symbols
+! find target/ -name "*.rlib" -exec nm {} \; | grep "std"
+
+# Runs mach's run-time tests:
+if [ -z "$NORUN" ]; then
+    cargo test --target "${TARGET}" -vv
+    cargo test --target "${TARGET}" -vv --features deprecated
+    cargo test --no-default-features --target "${TARGET}" -vv
+fi
+
+# Runs ctest to verify mach's ABI against the system libraries:
+if [ -z "$NOCTEST" ]; then
+    if [ "${TRAVIS_RUST_VERSION}" = "nightly" ]; then
+        cargo test --manifest-path mach-test/Cargo.toml --target "${TARGET}" -vv
+        cargo test --no-default-features --manifest-path mach-test/Cargo.toml --target "${TARGET}" -vv
+    fi
+fi
diff --git a/third_party/rust/mach/examples/dump_process_registers.rs b/third_party/rust/mach/examples/dump_process_registers.rs
new file mode 100644
index 000000000000..c426e583e0fe
--- /dev/null
+++ b/third_party/rust/mach/examples/dump_process_registers.rs
@@ -0,0 +1,136 @@
+//! A script to read and dump to stdout the current register values of a
+//! process.
+
+extern crate libc;
+extern crate mach;
+
+use std::io;
+use std::mem;
+use std::ptr;
+
+use mach::kern_return::KERN_SUCCESS;
+use mach::mach_types::{task_t, thread_act_array_t};
+use mach::message::mach_msg_type_number_t;
+use mach::port::mach_port_name_t;
+use mach::structs::x86_thread_state64_t;
+use mach::task::{task_resume, task_suspend, task_threads};
+use mach::thread_act::thread_get_state;
+use mach::thread_status::x86_THREAD_STATE64;
+use mach::traps::{mach_task_self, task_for_pid};
+
+use std::io::prelude::*;
+
+fn read_int() -> Result<::libc::c_int, ()> {
+    let stdin = io::stdin();
+    let mut line = String::new();
+
+    stdin.read_line(&mut line).ok().unwrap();
+    let mut value: ::libc::c_int = 0;
+
+    for c in line.chars().take_while(|&c| c != '\n') {
+        if let Some(d) = c.to_digit(10) {
+            value = value * 10 + (d as ::libc::c_int);
+        } else {
+            return Err(());
+        }
+    }
+    return Ok(value);
+}
+
+fn resume(task: task_t) {
+    unsafe {
+        let kret = task_resume(task);
+        if kret != KERN_SUCCESS {
+            println!("Did not succeed in resuming task.");
+            println!("kern_return_t error {}", kret);
+            panic!();
+        }
+    }
+}
+
+fn main() {
+    print!("Enter pid: ");
+    io::stdout().flush().ok();
+
+    let pid = match read_int() {
+        Ok(v) => v,
+        Err(_) => {
+            println!("Bad pid!");
+            return;
+        }
+    };
+
+    println!("pid = {}", &pid);
+
+    let task: mach_port_name_t = 0;
+    unsafe {
+        let kret = task_for_pid(
+            mach_task_self() as mach_port_name_t,
+            pid,
+            mem::transmute(&task),
+        );
+        if kret != KERN_SUCCESS {
+            println!("Did not succeed in getting task for pid {}", pid);
+            println!("kern_return_t error {}", kret);
+            println!("");
+            println!("Did you forget to run with 'sudo'? This script will");
+            println!("probably fail without it.");
+            return;
+        }
+    }
+
+    println!("task = 0x{:x}", &task);
+
+    unsafe {
+        let kret = task_suspend(task as task_t);
+        if kret != KERN_SUCCESS {
+            println!("Did not succeed in suspending task.");
+            println!("kern_return_t error {}", kret);
+            return;
+        }
+    }
+
+    let thread_list: thread_act_array_t = ptr::null_mut();
+    let thread_count: mach_msg_type_number_t = 0;
+    unsafe {
+        let kret = task_threads(
+            task as task_t,
+            mem::transmute(&thread_list),
+            mem::transmute(&thread_count),
+        );
+        if kret != KERN_SUCCESS {
+            println!("Did not succeed in getting task's threads");
+            println!("kern_return_t error {}", kret);
+            resume(task as task_t);
+            return;
+        }
+    }
+
+    println!("Task is running {} threads", &thread_count);
+
+    unsafe {
+        let threads =
+            Vec::from_raw_parts(thread_list, thread_count as usize, thread_count as usize);
+        let state = x86_thread_state64_t::new();
+        let state_count = x86_thread_state64_t::count();
+        for (idx, &thread) in threads.iter().enumerate() {
+            println!("Thread {}:", idx);
+            let kret = thread_get_state(
+                thread,
+                x86_THREAD_STATE64,
+                mem::transmute(&state),
+                mem::transmute(&state_count),
+            );
+            if kret != KERN_SUCCESS {
+                println!("Did not succeed in getting task's thread state");
+                println!("kern_return_t error {}", kret);
+                continue;
+            }
+
+            println!("{:?}", state);
+        }
+    }
+
+    resume(task as task_t);
+    println!("Success!");
+}
diff --git a/third_party/rust/mach/src/boolean.rs b/third_party/rust/mach/src/boolean.rs
new file mode 100644
index 000000000000..cedffa122029
--- /dev/null
+++ b/third_party/rust/mach/src/boolean.rs
@@ -0,0 +1,7 @@
+//! This module corresponds to `mach/i386/boolean.h`.
+
+#[cfg(target_arch = "x86_64")]
+pub type boolean_t = ::libc::c_uint;
+
+#[cfg(not(target_arch = "x86_64"))]
+pub type boolean_t = ::libc::c_int;
diff --git a/third_party/rust/mach/src/bootstrap.rs b/third_party/rust/mach/src/bootstrap.rs
new file mode 100644
index 000000000000..3642b94627d9
--- /dev/null
+++ b/third_party/rust/mach/src/bootstrap.rs
@@ -0,0 +1,76 @@
+//! This module corresponds to `bootstrap.h`
+
+use boolean::boolean_t;
+use kern_return::kern_return_t;
+use port::mach_port_t;
+
+pub const BOOTSTRAP_MAX_NAME_LEN: ::libc::c_uint = 128;
+pub const BOOTSTRAP_MAX_CMD_LEN: ::libc::c_uint = 512;
+
+pub const BOOTSTRAP_MAX_LOOKUP_COUNT: ::libc::c_uint = 20;
+
+pub const BOOTSTRAP_SUCCESS: ::libc::c_uint = 0;
+pub const BOOTSTRAP_NOT_PRIVILEGED: ::libc::c_uint = 1100;
+pub const BOOTSTRAP_NAME_IN_USE: ::libc::c_uint = 1101;
+pub const BOOTSTRAP_UNKNOWN_SERVICE: ::libc::c_uint = 1102;
+pub const BOOTSTRAP_SERVICE_ACTIVE: ::libc::c_uint = 1103;
+pub const BOOTSTRAP_BAD_COUNT: ::libc::c_uint = 1104;
+pub const BOOTSTRAP_NO_MEMORY: ::libc::c_uint = 1105;
+pub const BOOTSTRAP_NO_CHILDREN: ::libc::c_uint = 1106;
+
+pub const BOOTSTRAP_STATUS_INACTIVE: ::libc::c_uint = 0;
+pub const BOOTSTRAP_STATUS_ACTIVE: ::libc::c_uint = 1;
+pub const BOOTSTRAP_STATUS_ON_DEMAND: ::libc::c_uint = 2;
+
+pub type name_t = [::libc::c_char; 128];
+pub type cmd_t = [::libc::c_char; 512];
+pub type name_array_t = *mut name_t;
+pub type bootstrap_status_t = ::libc::c_int;
+pub type bootstrap_status_array_t = *mut bootstrap_status_t;
+pub type bootstrap_property_t = ::libc::c_uint;
+pub type bootstrap_property_array_t = *mut bootstrap_property_t;
+pub type bool_array_t = *mut boolean_t;
+
+extern "C" {
+    pub static bootstrap_port: mach_port_t;
+    pub fn bootstrap_create_server(
+        bp: mach_port_t,
+        server_cmd: *mut ::libc::c_char,
+        server_uid: ::libc::uid_t,
+        on_demand: boolean_t,
+        server_port: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_subset(
+        bp: mach_port_t,
+        requestor_port: mach_port_t,
+        subset_port: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_unprivileged(bp: mach_port_t, unpriv_port: *mut mach_port_t) -> kern_return_t;
+    pub fn bootstrap_parent(bp: mach_port_t, parent_port: *mut mach_port_t) -> kern_return_t;
+    pub fn bootstrap_register(
+        bp: mach_port_t,
+        service_name: *mut ::libc::c_char,
+        sp: mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_create_service(
+        bp: mach_port_t,
+        service_name: *mut ::libc::c_char,
+        sp: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_check_in(
+        bp: mach_port_t,
+        service_name: *const ::libc::c_char,
+        sp: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_look_up(
+        bp: mach_port_t,
+        service_name: *const ::libc::c_char,
+        sp: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_status(
+        bp: mach_port_t,
+        service_name: *mut ::libc::c_char,
+        service_active: *mut bootstrap_status_t,
+    ) -> kern_return_t;
+    pub fn bootstrap_strerror(r: kern_return_t) -> *const ::libc::c_char;
+}
diff --git a/third_party/rust/mach/src/clock.rs b/third_party/rust/mach/src/clock.rs
new file mode 100644
index 000000000000..1d5437951dd2
--- /dev/null
+++ b/third_party/rust/mach/src/clock.rs
@@ -0,0 +1,27 @@
+//! This module roughly corresponds to `mach/clock.h`.
+
+pub const clock_MSG_COUNT: ::libc::c_uint = 3;
+
+use clock_types::{alarm_type_t, clock_attr_t, clock_flavor_t, mach_timespec_t};
+use kern_return::kern_return_t;
+use mach_types::{clock_reply_t, clock_serv_t};
+use message::mach_msg_type_number_t;
+
+extern "C" {
+    pub fn clock_get_time(
+        clock_serv: clock_serv_t,
+        cur_time: *mut mach_timespec_t,
+    ) -> kern_return_t;
+    pub fn clock_get_attributes(
+        clock_serv: clock_serv_t,
+        flavor: clock_flavor_t,
+        clock_attr: clock_attr_t,
+        clock_attrCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+    pub fn clock_alarm(
+        clock_serv: clock_serv_t,
+        alarm_type: alarm_type_t,
+        alarm_time: mach_timespec_t,
+        alarm_port: clock_reply_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/clock_priv.rs b/third_party/rust/mach/src/clock_priv.rs
new file mode 100644
index 000000000000..d534e79a3c20
--- /dev/null
+++ b/third_party/rust/mach/src/clock_priv.rs
@@ -0,0 +1,16 @@
+//! This module roughly corresponds to `mach/clock_priv.h`.
+
+use clock_types::{clock_attr_t, clock_flavor_t, mach_timespec_t};
+use kern_return::kern_return_t;
+use mach_types::clock_ctrl_t;
+use message::mach_msg_type_number_t;
+
+extern "C" {
+    pub fn clock_set_time(clock_ctrl: clock_ctrl_t, new_time: mach_timespec_t) -> kern_return_t;
+    pub fn clock_set_attributes(
+        clock_ctrl: clock_ctrl_t,
+        flavor: clock_flavor_t,
+        clock_attr: clock_attr_t,
+        clock_attrCnt: mach_msg_type_number_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/clock_reply.rs b/third_party/rust/mach/src/clock_reply.rs
new file mode 100644
index 000000000000..854eb22bf581
--- /dev/null
+++ b/third_party/rust/mach/src/clock_reply.rs
@@ -0,0 +1,16 @@
+//! This module roughly corresponds to `mach/clock_reply.h`.
+
+use clock_types::{alarm_type_t, mach_timespec_t};
+use kern_return::kern_return_t;
+use mach_types::clock_reply_t;
+use message::mach_msg_type_name_t;
+
+extern "C" {
+    pub fn clock_alarm_reply(
+        alarm_port: clock_reply_t,
+        alarm_portPoly: mach_msg_type_name_t,
+        alarm_code: kern_return_t,
+        alarm_type: alarm_type_t,
+        alarm_time: mach_timespec_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/clock_types.rs b/third_party/rust/mach/src/clock_types.rs
new file mode 100644
index 000000000000..c0949c83158b
--- /dev/null
+++ b/third_party/rust/mach/src/clock_types.rs
@@ -0,0 +1,75 @@
+//! This module roughly corresponds to `mach/clock_types.h`.
+
+pub type alarm_type_t = ::libc::c_int;
+pub type sleep_type_t = ::libc::c_int;
+pub type clock_id_t = ::libc::c_int;
+pub type clock_flavor_t = ::libc::c_int;
+pub type clock_attr_t = *mut ::libc::c_int;
+pub type clock_res_t = ::libc::c_int;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_timespec {
+    pub tv_sec: ::libc::c_uint,
+    pub tv_nsec: clock_res_t,
+}
+pub type mach_timespec_t = mach_timespec;
+
+pub const SYSTEM_CLOCK: ::libc::c_uint = 0;
+pub const CALENDAR_CLOCK: ::libc::c_uint = 1;
+pub const REALTIME_CLOCK: ::libc::c_uint = 0;
+
+pub const CLOCK_GET_TIME_RES: ::libc::c_uint = 1;
+pub const CLOCK_ALARM_CURRES: ::libc::c_uint = 3;
+pub const CLOCK_ALARM_MINRES: ::libc::c_uint = 4;
+pub const CLOCK_ALARM_MAXRES: ::libc::c_uint = 5;
+
+pub const NSEC_PER_USEC: ::libc::c_ulonglong = 1000;
+pub const USEC_PER_SEC: ::libc::c_ulonglong = 1_000_000;
+pub const NSEC_PER_SEC: ::libc::c_ulonglong = 1_000_000_000;
+pub const NSEC_PER_MSEC: ::libc::c_ulonglong = 1_000_000;
+
+#[allow(non_snake_case)]
+pub fn BAD_MACH_TIMESPEC(t: mach_timespec) -> bool {
+    t.tv_nsec < 0 || (t.tv_nsec as ::libc::c_ulonglong) >= NSEC_PER_SEC
+}
+
+#[allow(non_snake_case)]
+pub fn CMP_MACH_TIMESPEC(t1: &mach_timespec, t2: &mach_timespec) -> ::libc::c_ulonglong {
+    if t1.tv_sec > t2.tv_sec {
+        return NSEC_PER_SEC;
+    }
+    if t1.tv_sec < t2.tv_sec {
+        return !NSEC_PER_SEC;
+    }
+    (t1.tv_nsec as ::libc::c_ulonglong) - (t2.tv_nsec as ::libc::c_ulonglong)
+}
+
+#[allow(non_snake_case)]
+pub fn ADD_MACH_TIMESPEC(t1: &mut mach_timespec, t2: &mach_timespec) {
+    t1.tv_nsec += t2.tv_nsec;
+    if (t1.tv_nsec as ::libc::c_ulonglong) >= NSEC_PER_SEC {
+        t1.tv_nsec = (t1.tv_nsec as ::libc::c_ulonglong - NSEC_PER_SEC) as clock_res_t;
+        t1.tv_sec += 1;
+    }
+    t1.tv_sec += t2.tv_sec;
+}
+
+#[allow(non_snake_case)]
+pub fn SUB_MACH_TIMESPEC(t1: &mut mach_timespec, t2: &mach_timespec) {
+    t1.tv_nsec -= t2.tv_nsec;
+    if t1.tv_nsec < 0 {
+        t1.tv_nsec = (t1.tv_nsec as ::libc::c_ulonglong + NSEC_PER_SEC) as clock_res_t;
+        t1.tv_sec -= 1;
+    }
+    t1.tv_sec -= t2.tv_sec;
+}
+
+pub const ALRMTYPE: ::libc::c_uint = 0xff;
+pub const TIME_ABSOLUTE: ::libc::c_uint = 0x00;
+pub const TIME_RELATIVE: ::libc::c_uint = 0x01;
+
+#[allow(non_snake_case)]
+pub fn BAD_ALRMTYPE(t: ::libc::c_uint) -> bool {
+    t & (!TIME_RELATIVE) != 0
+}
diff --git a/third_party/rust/mach/src/dyld_kernel.rs b/third_party/rust/mach/src/dyld_kernel.rs
new file mode 100644
index 000000000000..9a264dfafd59
--- /dev/null
+++ b/third_party/rust/mach/src/dyld_kernel.rs
@@ -0,0 +1,30 @@
+//! This module roughly corresponds to `mach/dyld_kernel.h`.
+
+use boolean::boolean_t;
+use mach_types::{fsid_t, fsobj_id_t, uuid_t};
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct dyld_kernel_image_info {
+    pub uuid: uuid_t,
+    pub fsobjid: fsobj_id_t,
+    pub fsid: fsid_t,
+    pub load_addr: u64,
+}
+
+#[allow(non_snake_case)]
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct dyld_kernel_process_info {
+    pub cache_image_info: dyld_kernel_image_info,
+    pub timestamp: u64,
+    pub imageCount: u32,
+    pub initialImageCount: u32,
+    pub dyldState: u8,
+    pub no_cache: boolean_t,
+    pub private_cache: boolean_t,
+}
+
+pub type dyld_kernel_image_info_t = dyld_kernel_image_info;
+pub type dyld_kernel_process_info_t = dyld_kernel_process_info;
+pub type dyld_kernel_image_info_array_t = *mut dyld_kernel_image_info_t;
diff --git a/third_party/rust/mach/src/exc.rs b/third_party/rust/mach/src/exc.rs
new file mode 100644
index 000000000000..9330740c4e29
--- /dev/null
+++ b/third_party/rust/mach/src/exc.rs
@@ -0,0 +1,44 @@
+//! This module roughly corresponds to `mach/exc.h`.
+
+use exception_types::{exception_data_t, exception_type_t};
+use kern_return::kern_return_t;
+use message::mach_msg_type_number_t;
+use port::mach_port_t;
+use thread_status::thread_state_t;
+
+pub const exc_MSG_COUNT: ::libc::c_uint = 3;
+
+extern "C" {
+    pub fn exception_raise(
+        exception_port: mach_port_t,
+        thread: mach_port_t,
+        task: mach_port_t,
+        exception: exception_type_t,
+        code: exception_data_t,
+        codeCnt: mach_msg_type_number_t,
+    ) -> kern_return_t;
+    pub fn exception_raise_state(
+        exception_port: mach_port_t,
+        exception: exception_type_t,
+        code: exception_data_t,
+        codeCnt: mach_msg_type_number_t,
+        flavor: *mut ::libc::c_int,
+        old_state: thread_state_t,
+        old_stateCnt: mach_msg_type_number_t,
+        new_state: thread_state_t,
+        new_stateCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+    pub fn exception_raise_state_identity(
+        exception_port: mach_port_t,
+        thread: mach_port_t,
+        task: mach_port_t,
+        exception: exception_type_t,
+        code: exception_data_t,
+        codeCnt: mach_msg_type_number_t,
+        flavor: *mut ::libc::c_int,
+        old_state: thread_state_t,
+        old_stateCnt: mach_msg_type_number_t,
+        new_state: thread_state_t,
+        new_stateCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/exception_types.rs b/third_party/rust/mach/src/exception_types.rs
new file mode 100644
index 000000000000..f042443d8a7f
--- /dev/null
+++ b/third_party/rust/mach/src/exception_types.rs
@@ -0,0 +1,56 @@
+//! This module roughly corresponds to `mach/exception_types.h`.
+
+use port::mach_port_t;
+use thread_status::thread_state_flavor_t;
+use vm_types::integer_t;
+
+pub const EXC_BAD_ACCESS: ::libc::c_uint = 1;
+pub const EXC_BAD_INSTRUCTION: ::libc::c_uint = 2;
+pub const EXC_ARITHMETIC: ::libc::c_uint = 3;
+pub const EXC_EMULATION: ::libc::c_uint = 4;
+pub const EXC_SOFTWARE: ::libc::c_uint = 5;
+pub const EXC_BREAKPOINT: ::libc::c_uint = 6;
+pub const EXC_SYSCALL: ::libc::c_uint = 7;
+pub const EXC_MACH_SYSCALL: ::libc::c_uint = 8;
+pub const EXC_RPC_ALERT: ::libc::c_uint = 9;
+pub const EXC_CRASH: ::libc::c_uint = 10;
+pub const EXC_RESOURCE: ::libc::c_uint = 11;
+pub const EXC_GUARD: ::libc::c_uint = 12;
+pub const EXC_CORPSE_NOTIFY: ::libc::c_uint = 13;
+pub const EXC_CORPSE_VARIANT_BIT: ::libc::c_uint = 256;
+pub const EXCEPTION_DEFAULT: ::libc::c_uint = 1;
+pub const EXCEPTION_STATE: ::libc::c_uint = 2;
+pub const EXCEPTION_STATE_IDENTITY: ::libc::c_uint = 3;
+pub const MACH_EXCEPTION_CODES: ::libc::c_uint = 2_147_483_648;
+pub const EXC_MASK_BAD_ACCESS: ::libc::c_uint = 2;
+pub const EXC_MASK_BAD_INSTRUCTION: ::libc::c_uint = 4;
+pub const EXC_MASK_ARITHMETIC: ::libc::c_uint = 8;
+pub const EXC_MASK_EMULATION: ::libc::c_uint = 16;
+pub const EXC_MASK_SOFTWARE: ::libc::c_uint = 32;
+pub const EXC_MASK_BREAKPOINT: ::libc::c_uint = 64;
+pub const EXC_MASK_SYSCALL: ::libc::c_uint = 128;
+pub const EXC_MASK_MACH_SYSCALL: ::libc::c_uint = 256;
+pub const EXC_MASK_RPC_ALERT: ::libc::c_uint = 512;
+pub const EXC_MASK_CRASH: ::libc::c_uint = 1024;
+pub const EXC_MASK_RESOURCE: ::libc::c_uint = 2048;
+pub const EXC_MASK_GUARD: ::libc::c_uint = 4096;
+pub const EXC_MASK_CORPSE_NOTIFY: ::libc::c_uint = 8192;
+pub const EXC_MASK_ALL: ::libc::c_uint = 7166;
+pub const FIRST_EXCEPTION: ::libc::c_uint = 1;
+pub const EXC_SOFT_SIGNAL: ::libc::c_uint = 65_539;
+pub const EXC_MACF_MIN: ::libc::c_uint = 131_072;
+pub const EXC_MACF_MAX: ::libc::c_uint = 196_607;
+
+pub type exception_type_t = ::libc::c_int;
+pub type exception_data_type_t = integer_t;
+pub type mach_exception_data_type_t = i64;
+pub type exception_behavior_t = ::libc::c_int;
+pub type exception_data_t = *mut exception_data_type_t;
+pub type mach_exception_data_t = *mut mach_exception_data_type_t;
+pub type exception_mask_t = ::libc::c_uint;
+pub type exception_mask_array_t = *mut exception_mask_t;
+pub type exception_behavior_array_t = *mut exception_behavior_t;
+pub type exception_flavor_array_t = *mut thread_state_flavor_t;
+pub type exception_port_array_t = *mut mach_port_t;
+pub type mach_exception_code_t = mach_exception_data_type_t;
+pub type mach_exception_subcode_t = mach_exception_data_type_t;
diff --git a/third_party/rust/mach/src/kern_return.rs b/third_party/rust/mach/src/kern_return.rs
new file mode 100644
index 000000000000..3d447b402664
--- /dev/null
+++ b/third_party/rust/mach/src/kern_return.rs
@@ -0,0 +1,58 @@
+//! This module corresponds to `mach/kern_return.h` and
+//! `mach/i386/kern_return.h`.
+
+pub type kern_return_t = ::libc::c_int;
+
+pub const KERN_SUCCESS: kern_return_t = 0;
+pub const KERN_INVALID_ADDRESS: kern_return_t = 1;
+pub const KERN_PROTECTION_FAILURE: kern_return_t = 2;
+pub const KERN_NO_SPACE: kern_return_t = 3;
+pub const KERN_INVALID_ARGUMENT: kern_return_t = 4;
+pub const KERN_FAILURE: kern_return_t = 5;
+pub const KERN_RESOURCE_SHORTAGE: kern_return_t = 6;
+pub const KERN_NOT_RECEIVER: kern_return_t = 7;
+pub const KERN_NO_ACCESS: kern_return_t = 8;
+pub const KERN_MEMORY_FAILURE: kern_return_t = 9;
+pub const KERN_MEMORY_ERROR: kern_return_t = 10;
+pub const KERN_ALREADY_IN_SET: kern_return_t = 11;
+pub const KERN_NOT_IN_SET: kern_return_t = 12;
+pub const KERN_NAME_EXISTS: kern_return_t = 13;
+pub const KERN_ABORTED: kern_return_t = 14;
+pub const KERN_INVALID_NAME: kern_return_t = 15;
+pub const KERN_INVALID_TASK: kern_return_t = 16;
+pub const KERN_INVALID_RIGHT: kern_return_t = 17;
+pub const KERN_INVALID_VALUE: kern_return_t = 18;
+pub const KERN_UREFS_OVERFLOW: kern_return_t = 19;
+pub const KERN_INVALID_CAPABILITY: kern_return_t = 20;
+pub const KERN_RIGHT_EXISTS: kern_return_t = 21;
+pub const KERN_INVALID_HOST: kern_return_t = 22;
+pub const KERN_MEMORY_PRESENT: kern_return_t = 23;
+pub const KERN_MEMORY_DATA_MOVED: kern_return_t = 24;
+pub const KERN_MEMORY_RESTART_COPY: kern_return_t = 25;
+pub const KERN_INVALID_PROCESSOR_SET: kern_return_t = 26;
+pub const KERN_POLICY_LIMIT: kern_return_t = 27;
+pub const KERN_INVALID_POLICY: kern_return_t = 28;
+pub const KERN_INVALID_OBJECT: kern_return_t = 29;
+pub const KERN_ALREADY_WAITING: kern_return_t = 30;
+pub const KERN_DEFAULT_SET: kern_return_t = 31;
+pub const KERN_EXCEPTION_PROTECTED: kern_return_t = 32;
+pub const KERN_INVALID_LEDGER: kern_return_t = 33;
+pub const KERN_INVALID_MEMORY_CONTROL: kern_return_t = 34;
+pub const KERN_INVALID_SECURITY: kern_return_t = 35;
+pub const KERN_NOT_DEPRESSED: kern_return_t = 36;
+pub const KERN_TERMINATED: kern_return_t = 37;
+pub const KERN_LOCK_SET_DESTROYED: kern_return_t = 38;
+pub const KERN_LOCK_UNSTABLE: kern_return_t = 39;
+pub const KERN_LOCK_OWNED: kern_return_t = 40;
+pub const KERN_LOCK_OWNED_SELF: kern_return_t = 41;
+pub const KERN_SEMAPHORE_DESTROYED: kern_return_t = 42;
+pub const KERN_RPC_SERVER_TERMINATED: kern_return_t = 43;
+pub const KERN_RPC_TERMINATE_ORPHAN: kern_return_t = 44;
+pub const KERN_RPC_CONTINUE_ORPHAN: kern_return_t = 45;
+pub const KERN_NOT_SUPPORTED: kern_return_t = 46;
+pub const KERN_NODE_DOWN: kern_return_t = 47;
+pub const KERN_NOT_WAITING: kern_return_t = 48;
+pub const KERN_OPERATION_TIMED_OUT: kern_return_t = 49;
+pub const KERN_CODESIGN_ERROR: kern_return_t = 50;
+pub const KERN_POLICY_STATIC: kern_return_t = 51;
+pub const KERN_RETURN_MAX: kern_return_t = 0x100;
diff --git a/third_party/rust/mach/src/lib.rs b/third_party/rust/mach/src/lib.rs
new file mode 100644
index 000000000000..faec2cbfa59d
--- /dev/null
+++ b/third_party/rust/mach/src/lib.rs
@@ -0,0 +1,60 @@
+#![allow(non_camel_case_types)]
+#![allow(non_upper_case_globals)]
+#![deny(missing_debug_implementations)]
+#![deny(missing_copy_implementations)]
+#![cfg_attr(feature = "rustc-dep-of-std", feature(no_core))]
+#![cfg_attr(feature = "rustc-dep-of-std", no_core)]
+#![cfg_attr(not(feature = "rustc-dep-of-std"), no_std)]
+#![allow(
+    clippy::module_name_repetitions,
+    clippy::cast_sign_loss,
+    clippy::cast_possible_truncation,
+    clippy::trivially_copy_pass_by_ref
+)]
+
+#[cfg(not(any(target_os = "macos", target_os = "ios")))]
+compile_error!("mach requires MacOSX or iOS");
+
+#[cfg(feature = "rustc-dep-of-std")]
+extern crate rustc_std_workspace_core as core;
+
+extern crate libc;
+
+#[allow(unused_imports)]
+use core::{clone, cmp, default, fmt, hash, marker, mem, option};
+
+pub mod boolean;
+pub mod bootstrap;
+pub mod clock;
+pub mod clock_priv;
+pub mod clock_reply;
+pub mod clock_types; // TODO: test
+pub mod dyld_kernel;
+// pub mod error; // TODO
+pub mod exc;
+pub mod exception_types;
+pub mod kern_return;
+pub mod mach_init;
+pub mod mach_port;
+pub mod mach_time;
+pub mod mach_types;
+pub mod memory_object_types;
+pub mod message;
+pub mod port;
+pub mod structs;
+pub mod task;
+pub mod task_info;
+pub mod thread_act;
+pub mod thread_status;
+pub mod traps;
+pub mod vm;
+pub mod vm_attributes;
+pub mod vm_behavior;
+pub mod vm_inherit;
+pub mod vm_page_size;
+pub mod vm_prot;
+pub mod vm_purgable;
+pub mod vm_region;
+pub mod vm_statistics;
+pub mod vm_sync;
+pub mod vm_types;
diff --git a/third_party/rust/mach/src/mach_init.rs b/third_party/rust/mach/src/mach_init.rs
new file mode 100644
index 000000000000..5776988cb519
--- /dev/null
+++ b/third_party/rust/mach/src/mach_init.rs
@@ -0,0 +1,22 @@
+//! This module corresponds to `mach/mach_init.h`.
+
+use mach_types::thread_port_t;
+
+extern "C" {
+    pub fn mach_thread_self() -> thread_port_t;
+}
+
+#[cfg(test)]
+mod tests {
+    use mach_init::*;
+    use port::*;
+
+    #[test]
+    fn mach_thread_self_test() {
+        unsafe {
+            let this_thread = mach_thread_self();
+            assert!(this_thread != MACH_PORT_NULL);
+            assert!(this_thread != MACH_PORT_DEAD);
+        }
+    }
+}
diff --git a/third_party/rust/mach/src/mach_port.rs b/third_party/rust/mach/src/mach_port.rs
new file mode 100644
index 000000000000..76a34001dfc9
--- /dev/null
+++ b/third_party/rust/mach/src/mach_port.rs
@@ -0,0 +1,29 @@
+//! This module corresponds to `mach/mach_port.h`
+
+use kern_return::kern_return_t;
+use mach_types::ipc_space_t;
+use message::mach_msg_type_name_t;
+use port::{mach_port_name_t, mach_port_right_t, mach_port_t};
+
+extern "C" {
+    pub fn mach_port_allocate(
+        task: ipc_space_t,
+        right: mach_port_right_t,
+        name: *mut mach_port_name_t,
+    ) -> kern_return_t;
+    pub fn mach_port_destroy(task: ipc_space_t, name: mach_port_name_t) -> kern_return_t;
+    pub fn mach_port_deallocate(task: ipc_space_t, name: mach_port_name_t) -> kern_return_t;
+    pub fn mach_port_insert_right(
+        task: ipc_space_t,
+        name: mach_port_name_t,
+        poly: mach_port_t,
+        polyPoly: mach_msg_type_name_t,
+    ) -> kern_return_t;
+    pub fn mach_port_extract_right(
+        task: ipc_space_t,
+        name: mach_port_name_t,
+        msgt_name: mach_msg_type_name_t,
+        poly: *mut mach_port_t,
+        polyPoly: *mut mach_msg_type_name_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/mach_time.rs b/third_party/rust/mach/src/mach_time.rs
new file mode 100644
index 000000000000..9011c0c0af76
--- /dev/null
+++ b/third_party/rust/mach/src/mach_time.rs
@@ -0,0 +1,20 @@
+//! This module corresponds to `mach/mach_time.h`
+use kern_return::kern_return_t;
+pub type mach_timebase_info_t = *mut mach_timebase_info;
+pub type mach_timebase_info_data_t = mach_timebase_info;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_timebase_info {
+    pub numer: u32,
+    pub denom: u32,
+}
+
+extern "C" {
+    pub fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;
+    pub fn mach_wait_until(deadline: u64) -> kern_return_t;
+    pub fn mach_absolute_time() -> u64;
+    pub fn mach_approximate_time() -> u64;
+    pub fn mach_continuous_time() -> u64;
+    pub fn mach_continuous_approximate_time() -> u64;
+}
diff --git a/third_party/rust/mach/src/mach_types.rs b/third_party/rust/mach/src/mach_types.rs
new file mode 100644
index 000000000000..fa257b2a5383
--- /dev/null
+++ b/third_party/rust/mach/src/mach_types.rs
@@ -0,0 +1,106 @@
+//! This module corresponds to `mach/mach_types.h`
+
+use port::mach_port_t;
+
+pub type task_t = mach_port_t;
+pub type task_name_t = mach_port_t;
+pub type task_suspension_token_t = mach_port_t;
+pub type thread_t = mach_port_t;
+pub type thread_act_t = mach_port_t;
+pub type ipc_space_t = mach_port_t;
+pub type coalition_t = mach_port_t;
+pub type host_t = mach_port_t;
+pub type host_priv_t = mach_port_t;
+pub type host_security_t = mach_port_t;
+pub type processor_t = mach_port_t;
+pub type processor_set_t = mach_port_t;
+pub type processor_set_control_t = mach_port_t;
+pub type semaphore_t = mach_port_t;
+pub type lock_set_t = mach_port_t;
+pub type ledger_t = mach_port_t;
+pub type alarm_t = mach_port_t;
+pub type clock_serv_t = mach_port_t;
+pub type clock_ctrl_t = mach_port_t;
+
+pub type processor_set_name_t = processor_set_t;
+
+pub type clock_reply_t = mach_port_t;
+pub type bootstrap_t = mach_port_t;
+pub type mem_entry_name_port_t = mach_port_t;
+pub type exception_handler_t = mach_port_t;
+pub type exception_handler_array_t = *mut exception_handler_t;
+pub type vm_task_entry_t = mach_port_t;
+pub type io_master_t = mach_port_t;
+pub type UNDServerRef = mach_port_t;
+
+pub type task_array_t = *mut task_t;
+pub type thread_array_t = *mut thread_t;
+pub type processor_set_array_t = *mut processor_set_t;
+pub type processor_set_name_array_t = *mut processor_set_t;
+pub type processor_array_t = *mut processor_t;
+pub type thread_act_array_t = *mut thread_act_t;
+pub type ledger_array_t = *mut ledger_t;
+
+pub type task_port_t = task_t;
+pub type task_port_array_t = task_array_t;
+pub type thread_port_t = thread_t;
+pub type thread_port_array_t = thread_array_t;
+pub type ipc_space_port_t = ipc_space_t;
+pub type host_name_t = host_t;
+pub type host_name_port_t = host_t;
+pub type processor_set_port_t = processor_set_t;
+pub type processor_set_name_port_t = processor_set_t;
+pub type processor_set_name_port_array_t = processor_set_array_t;
+pub type processor_set_control_port_t = processor_set_t;
+pub type processor_port_t = processor_t;
+pub type processor_port_array_t = processor_array_t;
+pub type thread_act_port_t = thread_act_t;
+pub type thread_act_port_array_t = thread_act_array_t;
+pub type semaphore_port_t = semaphore_t;
+pub type lock_set_port_t = lock_set_t;
+pub type ledger_port_t = ledger_t;
+pub type ledger_port_array_t = ledger_array_t;
+pub type alarm_port_t = alarm_t;
+pub type clock_serv_port_t = clock_serv_t;
+pub type clock_ctrl_port_t = clock_ctrl_t;
+pub type exception_port_t = exception_handler_t;
+pub type exception_port_arrary_t = exception_handler_array_t;
+
+pub const TASK_NULL: task_t = 0;
+pub const TASK_NAME_NULL: task_name_t = 0;
+pub const THREAD_NULL: thread_t = 0;
+pub const TID_NULL: u64 = 0;
+pub const THR_ACT_NULL: thread_act_t = 0;
+pub const IPC_SPACE_NULL: ipc_space_t = 0;
+pub const COALITION_NULL: coalition_t = 0;
+pub const HOST_NULL: host_t = 0;
+pub const HOST_PRIV_NULL: host_priv_t = 0;
+pub const HOST_SECURITY_NULL: host_security_t = 0;
+pub const PROCESSOR_SET_NULL: processor_set_t = 0;
+pub const PROCESSOR_NULL: processor_t = 0;
+pub const SEMAPHORE_NULL: semaphore_t = 0;
+pub const LOCK_SET_NULL: lock_set_t = 0;
+pub const LEDGER_NULL: ledger_t = 0;
+pub const ALARM_NULL: alarm_t = 0;
+pub const CLOCK_NULL: ::libc::clock_t = 0;
+pub const UND_SERVER_NULL: UNDServerRef = 0;
+
+// <sys/_types.h>: typedef	unsigned char	__darwin_uuid_t[16];
+pub type uuid_t = [::libc::c_uchar; 16];
+
+// <sys/_types/_fsid_t.h>
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct fsid {
+    pub val: [i32; 2],
+}
+pub type fsid_t = fsid;
+
+// <sys/_types/_fsobj_id_t.h>
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct fsobj_id {
+    pub fid_objno: u32,
+    pub fid_generation: u32,
+}
+pub type fsobj_id_t = fsobj_id;
diff --git a/third_party/rust/mach/src/memory_object_types.rs b/third_party/rust/mach/src/memory_object_types.rs
new file mode 100644
index 000000000000..8399e71676a2
--- /dev/null
+++ b/third_party/rust/mach/src/memory_object_types.rs
@@ -0,0 +1,9 @@
+//! This module roughly corresponds to `mach/memory_object_types.h`.
+
+use vm_types::natural_t;
+
+pub type memory_object_offset_t = ::libc::c_ulonglong;
+pub type memory_object_size_t = ::libc::c_ulonglong;
+pub type memory_object_cluster_size_t = natural_t;
+pub type memory_object_fault_info_t = *mut natural_t;
+pub type vm_object_id_t = ::libc::c_ulonglong;
diff --git a/third_party/rust/mach/src/message.rs b/third_party/rust/mach/src/message.rs
new file mode 100644
index 000000000000..4eafa5e9a4c3
--- /dev/null
+++ b/third_party/rust/mach/src/message.rs
@@ -0,0 +1,248 @@
+//! This module corresponds to `mach/message.h`.
+
+use kern_return::kern_return_t;
+use port::{mach_port_name_t, mach_port_t};
+use vm_types::{integer_t, natural_t};
+
+pub type mach_msg_timeout_t = natural_t;
+
+pub type mach_msg_bits_t = ::libc::c_uint;
+pub type mach_msg_id_t = integer_t;
+pub type mach_msg_size_t = natural_t;
+
+pub type mach_msg_copy_options_t = ::libc::c_uint;
+pub type mach_msg_descriptor_type_t = ::libc::c_uint;
+pub type mach_msg_type_name_t = ::libc::c_uint;
+
+pub type mach_msg_trailer_type_t = ::libc::c_uint;
+pub type mach_msg_trailer_size_t = ::libc::c_uint;
+
+pub type mach_msg_option_t = integer_t;
+
+pub type mach_msg_type_number_t = natural_t;
+pub type mach_msg_type_size_t = natural_t;
+
+pub type mach_msg_return_t = kern_return_t;
+
+pub const MACH_MSG_TIMEOUT_NONE: mach_msg_timeout_t = 0;
+
+pub const MACH_MSGH_BITS_ZERO: mach_msg_bits_t = 0x0000_0000;
+
+pub const MACH_MSGH_BITS_REMOTE_MASK: mach_msg_bits_t = 0x0000_001f;
+pub const MACH_MSGH_BITS_LOCAL_MASK: mach_msg_bits_t = 0x0000_1f00;
+pub const MACH_MSGH_BITS_VOUCHER_MASK: mach_msg_bits_t = 0x001f_0000;
+
+pub const MACH_MSGH_BITS_PORTS_MASK: mach_msg_bits_t =
+    MACH_MSGH_BITS_REMOTE_MASK | MACH_MSGH_BITS_LOCAL_MASK | MACH_MSGH_BITS_VOUCHER_MASK;
+
+pub const MACH_MSGH_BITS_COMPLEX: mach_msg_bits_t = 0x8000_0000;
+
+pub const MACH_MSGH_BITS_USER: mach_msg_bits_t = 0x801f_1f1f;
+
+#[allow(non_snake_case)]
+pub fn MACH_MSGH_BITS(remote: mach_msg_bits_t, local: mach_msg_bits_t) -> mach_msg_bits_t {
+    remote | (local << 8)
+}
+
+pub const MACH_MSG_TYPE_MOVE_RECEIVE: mach_msg_type_name_t = 16;
+pub const MACH_MSG_TYPE_MOVE_SEND: mach_msg_type_name_t = 17;
+pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: mach_msg_type_name_t = 18;
+pub const MACH_MSG_TYPE_COPY_SEND: mach_msg_type_name_t = 19;
+pub const MACH_MSG_TYPE_MAKE_SEND: mach_msg_type_name_t = 20;
+pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: mach_msg_type_name_t = 21;
+pub const MACH_MSG_TYPE_COPY_RECEIVE: mach_msg_type_name_t = 22;
+pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: mach_msg_type_name_t = 24;
+pub const MACH_MSG_TYPE_DISPOSE_SEND: mach_msg_type_name_t = 25;
+pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: mach_msg_type_name_t = 26;
+
+pub const MACH_MSG_PHYSICAL_COPY: mach_msg_copy_options_t = 0;
+pub const MACH_MSG_VIRTUAL_COPY: mach_msg_copy_options_t = 1;
+pub const MACH_MSG_ALLOCATE: mach_msg_copy_options_t = 2;
+
+pub const MACH_MSG_PORT_DESCRIPTOR: mach_msg_descriptor_type_t = 0;
+pub const MACH_MSG_OOL_DESCRIPTOR: mach_msg_descriptor_type_t = 1;
+pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: mach_msg_descriptor_type_t = 2;
+pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: mach_msg_descriptor_type_t = 3;
+
+pub const MACH_MSG_OPTION_NONE: mach_msg_option_t = 0x0000_0000;
+
+pub const MACH_SEND_MSG: mach_msg_option_t = 0x0000_0001;
+pub const MACH_RCV_MSG: mach_msg_option_t = 0x0000_0002;
+
+pub const MACH_RCV_LARGE: mach_msg_option_t = 0x0000_0004;
+pub const MACH_RCV_LARGE_IDENTITY: mach_msg_option_t = 0x0000_0008;
+
+pub const MACH_SEND_TIMEOUT: mach_msg_option_t = 0x0000_0010;
+pub const MACH_SEND_INTERRUPT: mach_msg_option_t = 0x0000_0040;
+pub const MACH_SEND_NOTIFY: mach_msg_option_t = 0x0000_0080;
+pub const MACH_SEND_ALWAYS: mach_msg_option_t = 0x0001_0000;
+pub const MACH_SEND_TRAILER: mach_msg_option_t = 0x0002_0000;
+pub const MACH_SEND_NOIMPORTANCE: mach_msg_option_t = 0x0004_0000;
+pub const MACH_SEND_NODENAP: mach_msg_option_t = MACH_SEND_NOIMPORTANCE;
+pub const MACH_SEND_IMPORTANCE: mach_msg_option_t = 0x0008_0000;
+
+pub const MACH_RCV_TIMEOUT: mach_msg_option_t = 0x0000_0100;
+pub const MACH_RCV_NOTIFY: mach_msg_option_t = 0x0000_0200;
+pub const MACH_RCV_INTERRUPT: mach_msg_option_t = 0x0000_0400;
+pub const MACH_RCV_VOUCHER: mach_msg_option_t = 0x0000_0800;
+pub const MACH_RCV_OVERWRITE: mach_msg_option_t = 0x0000_1000;
+
+pub const MACH_MSG_SUCCESS: mach_msg_return_t = 0x0000_0000;
+
+pub const MACH_MSG_MASK: mach_msg_return_t = 0x0000_3e00;
+pub const MACH_MSG_IPC_SPACE: mach_msg_return_t = 0x0000_2000;
+pub const MACH_MSG_VM_SPACE: mach_msg_return_t = 0x0000_1000;
+pub const MACH_MSG_IPC_KERNEL: mach_msg_return_t = 0x0000_0800;
+pub const MACH_MSG_VM_KERNEL: mach_msg_return_t = 0x0000_0400;
+
+pub const MACH_SEND_IN_PROGRESS: mach_msg_return_t = 0x1000_0001;
+pub const MACH_SEND_INVALID_DATA: mach_msg_return_t = 0x1000_0002;
+pub const MACH_SEND_INVALID_DEST: mach_msg_return_t = 0x1000_0003;
+pub const MACH_SEND_TIMED_OUT: mach_msg_return_t = 0x1000_0004;
+pub const MACH_SEND_INVALID_VOUCHER: mach_msg_return_t = 0x1000_0005;
+pub const MACH_SEND_INTERRUPTED: mach_msg_return_t = 0x1000_0007;
+pub const MACH_SEND_MSG_TOO_SMALL: mach_msg_return_t = 0x1000_0008;
+pub const MACH_SEND_INVALID_REPLY: mach_msg_return_t = 0x1000_0009;
+pub const MACH_SEND_INVALID_RIGHT: mach_msg_return_t = 0x1000_000a;
+pub const MACH_SEND_INVALID_NOTIFY: mach_msg_return_t = 0x1000_000b;
+pub const MACH_SEND_INVALID_MEMORY: mach_msg_return_t = 0x1000_000c;
+pub const MACH_SEND_NO_BUFFER: mach_msg_return_t = 0x1000_000d;
+pub const MACH_SEND_TOO_LARGE: mach_msg_return_t = 0x1000_000e;
+pub const MACH_SEND_INVALID_TYPE: mach_msg_return_t = 0x1000_000f;
+pub const MACH_SEND_INVALID_HEADER: mach_msg_return_t = 0x1000_0010;
+pub const MACH_SEND_INVALID_TRAILER: mach_msg_return_t = 0x1000_0011;
+pub const MACH_SEND_INVALID_RT_OOL_SIZE: mach_msg_return_t = 0x1000_0015;
+
+pub const MACH_RCV_IN_PROGRESS: mach_msg_return_t = 0x1000_4001;
+pub const MACH_RCV_INVALID_NAME: mach_msg_return_t = 0x1000_4002;
+pub const MACH_RCV_TIMED_OUT: mach_msg_return_t = 0x1000_4003;
+pub const MACH_RCV_TOO_LARGE: mach_msg_return_t = 0x1000_4004;
+pub const MACH_RCV_INTERRUPTED: mach_msg_return_t = 0x1000_4005;
+pub const MACH_RCV_PORT_CHANGED: mach_msg_return_t = 0x1000_4006;
+pub const MACH_RCV_INVALID_NOTIFY: mach_msg_return_t = 0x1000_4007;
+pub const MACH_RCV_INVALID_DATA: mach_msg_return_t = 0x1000_4008;
+pub const MACH_RCV_PORT_DIED: mach_msg_return_t = 0x1000_4009;
+pub const MACH_RCV_IN_SET: mach_msg_return_t = 0x1000_400a;
+pub const MACH_RCV_HEADER_ERROR: mach_msg_return_t = 0x1000_400b;
+pub const MACH_RCV_BODY_ERROR: mach_msg_return_t = 0x1000_400c;
+pub const MACH_RCV_INVALID_TYPE: mach_msg_return_t = 0x1000_400d;
+pub const MACH_RCV_SCATTER_SMALL: mach_msg_return_t = 0x1000_400e;
+pub const MACH_RCV_INVALID_TRAILER: mach_msg_return_t = 0x1000_400f;
+pub const MACH_RCV_IN_PROGRESS_TIMED: mach_msg_return_t = 0x1000_4011;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_header_t {
+    pub msgh_bits: mach_msg_bits_t,
+    pub msgh_size: mach_msg_size_t,
+    pub msgh_remote_port: mach_port_t,
+    pub msgh_local_port: mach_port_t,
+    pub msgh_voucher_port: mach_port_name_t,
+    pub msgh_id: mach_msg_id_t,
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_body_t {
+    pub msgh_descriptor_count: mach_msg_size_t,
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_base_t {
+    pub header: mach_msg_header_t,
+    pub body: mach_msg_body_t,
+}
+
+pub const MACH_MSG_TRAILER_FORMAT_0: mach_msg_trailer_type_t = 0;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_trailer_t {
+    pub msgh_trailer_type: mach_msg_trailer_type_t,
+    pub msgh_trailer_size: mach_msg_trailer_size_t,
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_port_descriptor_t {
+    pub name: mach_port_t,
+    pub pad1: mach_msg_size_t,
+    pub pad2: u16,
+    pub disposition: u8, // mach_msg_type_name_t bitfield
+    pub type_: u8,       // mach_msg_descriptor_type_t bitfield
+}
+
+impl mach_msg_port_descriptor_t {
+    pub fn new(name: mach_port_t, disposition: mach_msg_type_name_t) -> Self {
+        Self {
+            name,
+            pad1: 0,
+            pad2: 0,
+            disposition: disposition as u8,
+            type_: MACH_MSG_PORT_DESCRIPTOR as u8,
+        }
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_ool_descriptor_t {
+    pub address: *mut ::libc::c_void,
+    #[cfg(not(target_pointer_width = "64"))]
+    pub size: mach_msg_size_t,
+    pub deallocate: u8, // boolean_t bitfield
+    pub copy: u8,       // mach_msg_copy_options_t bitfield
+    pub pad1: u8,
+    pub type_: u8, // mach_msg_descriptor_type_t bitfield
+    #[cfg(target_pointer_width = "64")]
+    pub size: mach_msg_size_t,
+}
+
+impl mach_msg_ool_descriptor_t {
+    pub fn new(
+        address: *mut ::libc::c_void,
+        deallocate: bool,
+        copy: mach_msg_copy_options_t,
+        size: u32,
+    ) -> Self {
+        Self {
+            address,
+            deallocate: if deallocate { 1 } else { 0 },
+            copy: copy as u8,
+            pad1: 0,
+            type_: MACH_MSG_OOL_DESCRIPTOR as u8,
+            size,
+        }
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_msg_ool_ports_descriptor_t {
+    pub address: *mut ::libc::c_void,
+    #[cfg(not(target_pointer_width = "64"))]
+    pub count: mach_msg_size_t,
+    pub deallocate: u8,  // boolean_t bitfield
+    pub copy: u8,        // mach_msg_copy_options_t bitfield
+    pub disposition: u8, // mach_msg_type_name_t bitfield
+    pub type_: u8,       // mach_msg_descriptor_type_t bitfield
+    #[cfg(target_pointer_width = "64")]
+    pub count: mach_msg_size_t,
+}
+
+extern "C" {
+    pub fn mach_msg(
+        msg: *mut mach_msg_header_t,
+        option: mach_msg_option_t,
+        send_size: mach_msg_size_t,
+        recv_size: mach_msg_size_t,
+        recv_name: mach_port_name_t,
+        timeout: mach_msg_timeout_t,
+        notify: mach_port_name_t,
+    ) -> mach_msg_return_t;
+
+    // from mach/mach.h
+    pub fn mach_msg_send(msg: *mut mach_msg_header_t) -> mach_msg_return_t;
+    pub fn mach_msg_destroy(msg: *mut mach_msg_header_t);
+}
diff --git a/third_party/rust/mach/src/port.rs b/third_party/rust/mach/src/port.rs
new file mode 100644
index 000000000000..e43e81d0d33a
--- /dev/null
+++ b/third_party/rust/mach/src/port.rs
@@ -0,0 +1,26 @@
+//! This module corresponds to `mach/port.h`
+
+use vm_types::natural_t;
+
+pub type mach_port_name_t = natural_t;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct ipc_port;
+
+pub type ipc_port_t = *mut ipc_port;
+
+pub type mach_port_t = ::libc::c_uint;
+
+pub const MACH_PORT_NULL: mach_port_t = 0;
+pub const MACH_PORT_DEAD: mach_port_t = !0;
+
+pub type mach_port_right_t = natural_t;
+
+pub const MACH_PORT_RIGHT_SEND: mach_port_right_t = 0;
+pub const MACH_PORT_RIGHT_RECEIVE: mach_port_right_t = 1;
+pub const MACH_PORT_RIGHT_SEND_ONCE: mach_port_right_t = 2;
+pub const MACH_PORT_RIGHT_PORT_SET: mach_port_right_t = 3;
+pub const MACH_PORT_RIGHT_DEAD_NAME: mach_port_right_t = 4;
+pub const MACH_PORT_RIGHT_LABELH: mach_port_right_t = 5;
+pub const MACH_PORT_RIGHT_NUMBER: mach_port_right_t = 6;
diff --git a/third_party/rust/mach/src/structs.rs b/third_party/rust/mach/src/structs.rs
new file mode 100644
index 000000000000..75dc0e8dba5f
--- /dev/null
+++ b/third_party/rust/mach/src/structs.rs
@@ -0,0 +1,62 @@
+//! This module corresponds to `mach/_structs.h`.
+
+use mem;
+use message::mach_msg_type_number_t;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct x86_thread_state64_t {
+    pub __rax: u64,
+    pub __rbx: u64,
+    pub __rcx: u64,
+    pub __rdx: u64,
+    pub __rdi: u64,
+    pub __rsi: u64,
+    pub __rbp: u64,
+    pub __rsp: u64,
+    pub __r8: u64,
+    pub __r9: u64,
+    pub __r10: u64,
+    pub __r11: u64,
+    pub __r12: u64,
+    pub __r13: u64,
+    pub __r14: u64,
+    pub __r15: u64,
+    pub __rip: u64,
+    pub __rflags: u64,
+    pub __cs: u64,
+    pub __fs: u64,
+    pub __gs: u64,
+}
+
+impl x86_thread_state64_t {
+    pub fn new() -> Self {
+        Self {
+            __rax: 0,
+            __rbx: 0,
+            __rcx: 0,
+            __rdx: 0,
+            __rdi: 0,
+            __rsi: 0,
+            __rbp: 0,
+            __rsp: 0,
+            __r8: 0,
+            __r9: 0,
+            __r10: 0,
+            __r11: 0,
+            __r12: 0,
+            __r13: 0,
+            __r14: 0,
+            __r15: 0,
+            __rip: 0,
+            __rflags: 0,
+            __cs: 0,
+            __fs: 0,
+            __gs: 0,
+        }
+    }
+
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
diff --git a/third_party/rust/mach/src/task.rs b/third_party/rust/mach/src/task.rs
new file mode 100644
index 000000000000..1ca2280eb100
--- /dev/null
+++ b/third_party/rust/mach/src/task.rs
@@ -0,0 +1,41 @@
+//! This module corresponds to `mach/task.defs`.
+
+use kern_return::kern_return_t;
+use mach_types::{task_name_t, task_t, thread_act_array_t};
+use message::mach_msg_type_number_t;
+use port::mach_port_t;
+use task_info::{task_flavor_t, task_info_t};
+
+pub type task_special_port_t = ::libc::c_int;
+
+pub const TASK_KERNEL_PORT: task_special_port_t = 1;
+pub const TASK_HOST_PORT: task_special_port_t = 2;
+pub const TASK_NAME_PORT: task_special_port_t = 3;
+pub const TASK_BOOTSTRAP_PORT: task_special_port_t = 4;
+
+extern "C" {
+    pub fn task_resume(target_task: task_t) -> kern_return_t;
+    pub fn task_suspend(target_task: task_t) -> kern_return_t;
+    pub fn task_get_special_port(
+        task: task_t,
+        which_port: task_special_port_t,
+        special_port: *mut mach_port_t,
+    ) -> kern_return_t;
+    pub fn task_threads(
+        target_task: task_t,
+        act_list: *mut thread_act_array_t,
+        act_list_cnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+    pub fn task_info(
+        target_task: task_name_t,
+        flavor: task_flavor_t,
+        task_info_out: task_info_t,
+        task_info_outCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+    pub fn task_set_info(
+        target_task: task_t,
+        flavor: task_flavor_t,
+        task_info_in: task_info_t,
+        task_info_inCnt: mach_msg_type_number_t,
+    ) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/task_info.rs b/third_party/rust/mach/src/task_info.rs
new file mode 100644
index 000000000000..4a3b8ed710e3
--- /dev/null
+++ b/third_party/rust/mach/src/task_info.rs
@@ -0,0 +1,44 @@
+//! This module roughly corresponds to `mach/task_info.h`.
+
+use vm_types::{integer_t, mach_vm_address_t, mach_vm_size_t, natural_t};
+
+pub const TASK_INFO_MAX: ::libc::c_uint = 1024;
+pub const TASK_BASIC_INFO_32: ::libc::c_uint = 4;
+pub const TASK_BASIC2_INFO_32: ::libc::c_uint = 6;
+pub const TASK_BASIC_INFO_64: ::libc::c_uint = 5;
+#[cfg(target_arch = "x86_64")]
+pub const TASK_BASIC_INFO: ::libc::c_uint = 5;
+#[cfg(target_arch = "x86")]
+pub const TASK_BASIC_INFO: ::libc::c_uint = 4;
+pub const TASK_EVENTS_INFO: ::libc::c_uint = 2;
+pub const TASK_THREAD_TIMES_INFO: ::libc::c_uint = 3;
+pub const TASK_ABSOLUTETIME_INFO: ::libc::c_uint = 1;
+pub const TASK_KERNELMEMORY_INFO: ::libc::c_uint = 7;
+pub const TASK_SECURITY_TOKEN: ::libc::c_uint = 13;
+pub const TASK_AUDIT_TOKEN: ::libc::c_uint = 15;
+pub const TASK_AFFINITY_TAG_INFO: ::libc::c_uint = 16;
+pub const TASK_DYLD_INFO: ::libc::c_uint = 17;
+pub const TASK_DYLD_ALL_IMAGE_INFO_32: ::libc::c_uint = 0;
+pub const TASK_DYLD_ALL_IMAGE_INFO_64: ::libc::c_uint = 1;
+pub const TASK_EXTMOD_INFO: ::libc::c_uint = 19;
+pub const MACH_TASK_BASIC_INFO: ::libc::c_uint = 20;
+pub const TASK_POWER_INFO: ::libc::c_uint = 21;
+pub const TASK_VM_INFO: ::libc::c_uint = 22;
+pub const TASK_VM_INFO_PURGEABLE: ::libc::c_uint = 23;
+pub const TASK_TRACE_MEMORY_INFO: ::libc::c_uint = 24;
+pub const TASK_WAIT_STATE_INFO: ::libc::c_uint = 25;
+pub const TASK_POWER_INFO_V2: ::libc::c_uint = 26;
+pub const TASK_VM_INFO_PURGEABLE_ACCOUNT: ::libc::c_uint = 27;
+pub const TASK_FLAGS_INFO: ::libc::c_uint = 28;
+pub const TASK_DEBUG_INFO_INTERNAL: ::libc::c_uint = 29;
+
+pub type task_flavor_t = natural_t;
+pub type task_info_t = *mut integer_t;
+
+#[repr(C, packed(4))]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct task_dyld_info {
+    pub all_image_info_addr: mach_vm_address_t,
+    pub all_image_info_size: mach_vm_size_t,
+    pub all_image_info_format: integer_t,
+}
diff --git a/third_party/rust/mach/src/thread_act.rs b/third_party/rust/mach/src/thread_act.rs
new file mode 100644
index 000000000000..f2f9809a2b7e
--- /dev/null
+++ b/third_party/rust/mach/src/thread_act.rs
@@ -0,0 +1,23 @@
+//! This module corresponds to `mach/thread_act.defs`.
+
+use kern_return::kern_return_t;
+use mach_types::thread_act_t;
+use message::mach_msg_type_number_t;
+use thread_status::{thread_state_flavor_t, thread_state_t};
+
+extern "C" {
+    pub fn thread_get_state(
+        target_act: thread_act_t,
+        flavor: thread_state_flavor_t,
+        new_state: thread_state_t,
+        new_state_count: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+}
+
+extern "C" {
+    pub fn thread_suspend(target_act: thread_act_t) -> kern_return_t;
+}
+
+extern "C" {
+    pub fn thread_resume(target_act: thread_act_t) -> kern_return_t;
+}
diff --git a/third_party/rust/mach/src/thread_status.rs b/third_party/rust/mach/src/thread_status.rs
new file mode 100644
index 000000000000..951256622cd4
--- /dev/null
+++ b/third_party/rust/mach/src/thread_status.rs
@@ -0,0 +1,23 @@
+//! This module corresponds to `mach/thread_status.h`.
+
+use vm_types::natural_t;
+
+pub type thread_state_t = *mut natural_t;
+pub type thread_state_flavor_t = ::libc::c_int;
+
+pub static x86_THREAD_STATE32: thread_state_flavor_t = 1;
+pub static x86_FLOAT_STATE32: thread_state_flavor_t = 2;
+pub static x86_EXCEPTION_STATE32: thread_state_flavor_t = 3;
+pub static x86_THREAD_STATE64: thread_state_flavor_t = 4;
+pub static x86_FLOAT_STATE64: thread_state_flavor_t = 5;
+pub static x86_EXCEPTION_STATE64: thread_state_flavor_t = 6;
+pub static x86_THREAD_STATE: thread_state_flavor_t = 7;
+pub static x86_FLOAT_STATE: thread_state_flavor_t = 8;
+pub static x86_EXCEPTION_STATE: thread_state_flavor_t = 9;
+pub static x86_DEBUG_STATE32: thread_state_flavor_t = 10;
+pub static x86_DEBUG_STATE64: thread_state_flavor_t = 11;
+pub static x86_DEBUG_STATE: thread_state_flavor_t = 12;
+pub static THREAD_STATE_NONE: thread_state_flavor_t = 13;
+pub static x86_AVX_STATE32: thread_state_flavor_t = 16;
+pub static x86_AVX_STATE64: thread_state_flavor_t = 17;
+pub static x86_AVX_STATE: thread_state_flavor_t = 18;
diff --git a/third_party/rust/mach/src/traps.rs b/third_party/rust/mach/src/traps.rs
new file mode 100644
index 000000000000..bc8694fcbfac
--- /dev/null
+++ b/third_party/rust/mach/src/traps.rs
@@ -0,0 +1,35 @@
+//! This module corresponds to `mach/mach_traps.h`.
+use kern_return::kern_return_t;
+use port::{mach_port_name_t, mach_port_t};
+
+extern "C" {
+    static mach_task_self_: mach_port_t;
+    pub fn task_for_pid(
+        target_tport: mach_port_name_t,
+        pid: ::libc::c_int,
+        tn: *mut mach_port_name_t,
+    ) -> kern_return_t;
+}
+
+pub unsafe fn mach_task_self() -> mach_port_t {
+    mach_task_self_
+}
+
+pub unsafe fn current_task() -> mach_port_t {
+    mach_task_self()
+}
+
+#[cfg(test)]
+mod tests {
+    use port::*;
+    use traps::*;
+
+    #[test]
+    fn mach_task_self_sanity() {
+        unsafe {
+            let this_task = mach_task_self();
+            assert!(this_task != MACH_PORT_NULL);
+            assert!(this_task != MACH_PORT_DEAD);
+        }
+    }
+}
diff --git a/third_party/rust/mach/src/vm.rs b/third_party/rust/mach/src/vm.rs
new file mode 100644
index 000000000000..400ff2bf8a3f
--- /dev/null
+++ b/third_party/rust/mach/src/vm.rs
@@ -0,0 +1,247 @@
+//! This module roughly corresponds to `mach/mach_vm.defs`.
+
+use boolean::boolean_t;
+use kern_return::kern_return_t;
+use mach_types::{mem_entry_name_port_t, vm_task_entry_t};
+use memory_object_types::{memory_object_offset_t, memory_object_size_t};
+use message::mach_msg_type_number_t;
+use port::mach_port_t;
+use vm_attributes::{vm_machine_attribute_t, vm_machine_attribute_val_t};
+use vm_behavior::vm_behavior_t;
+use vm_inherit::vm_inherit_t;
+use vm_prot::vm_prot_t;
+use vm_purgable::vm_purgable_t;
+use vm_region::mach_vm_read_entry_t;
+use vm_region::{
+    vm_page_info_flavor_t, vm_page_info_t, vm_region_flavor_t, vm_region_info_t,
+    vm_region_recurse_info_t,
+};
+use vm_sync::vm_sync_t;
+use vm_types::{
+    integer_t, mach_vm_address_t, mach_vm_offset_t, mach_vm_size_t, natural_t, vm_map_t,
+    vm_offset_t, vm_size_t,
+};
+
+extern "C" {
+    pub fn mach_vm_allocate(
+        target: vm_task_entry_t,
+        address: *mut mach_vm_address_t,
+        size: mach_vm_size_t,
+        flags: ::libc::c_int,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_deallocate(
+        target: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_protect(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        set_maximum: boolean_t,
+        new_protection: vm_prot_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_inherit(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        new_inheritance: vm_inherit_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_read(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        data: *mut vm_offset_t,
+        dataCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_read_list(
+        target_task: vm_task_entry_t,
+        data_list: mach_vm_read_entry_t,
+        count: natural_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_write(
+        target_task: vm_map_t,
+        address: mach_vm_address_t,
+        data: vm_offset_t,
+        dataCnt: mach_msg_type_number_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_copy(
+        target_task: vm_task_entry_t,
+        source_address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        dest_address: mach_vm_address_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_read_overwrite(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        data: mach_vm_address_t,
+        outsize: *mut mach_vm_size_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_msync(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        sync_flags: vm_sync_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_behavior_set(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        new_behavior: vm_behavior_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_map(
+        target_task: vm_task_entry_t,
+        inout: *mut mach_vm_address_t,
+        size: mach_vm_size_t,
+        mask: mach_vm_offset_t,
+        flags: ::libc::c_int,
+        object: mem_entry_name_port_t,
+        offset: memory_object_offset_t,
+        copy: boolean_t,
+        cur_protection: vm_prot_t,
+        max_protection: vm_prot_t,
+        inheritance: vm_inherit_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_machine_attribute(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        size: mach_vm_size_t,
+        attribute: vm_machine_attribute_t,
+        value: *mut vm_machine_attribute_val_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_remap(
+        target_task: vm_task_entry_t,
+        target_address: *mut mach_vm_address_t,
+        size: mach_vm_size_t,
+        mask: mach_vm_offset_t,
+        flags: ::libc::c_int,
+        src_task: vm_task_entry_t,
+        src_address: mach_vm_address_t,
+        copy: boolean_t,
+        cur_protection: *mut vm_prot_t,
+        out: *mut vm_prot_t,
+        inheritance: vm_inherit_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_page_query(
+        target_map: vm_map_t,
+        offset: mach_vm_offset_t,
+        disposition: *mut integer_t,
+        ref_count: *mut integer_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_region_recurse(
+        target_task: vm_task_entry_t,
+        address: *mut mach_vm_address_t,
+        size: *mut mach_vm_size_t,
+        nesting_depth: *mut natural_t,
+        info: vm_region_recurse_info_t,
+        infoCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_region(
+        target_task: vm_task_entry_t,
+        address: *mut mach_vm_address_t,
+        size: *mut mach_vm_size_t,
+        flavor: vm_region_flavor_t,
+        info: vm_region_info_t,
+        infoCnt: *mut mach_msg_type_number_t,
+        object_name: *mut mach_port_t,
+    ) -> kern_return_t;
+
+    pub fn mach_make_memory_entry(
+        target_task: vm_map_t,
+        size: *mut vm_size_t,
+        offset: vm_offset_t,
+        permission: vm_prot_t,
+        object_handle: *mut mem_entry_name_port_t,
+        parent_handle: mem_entry_name_port_t,
+    ) -> kern_return_t;
+
+    pub fn mach_make_memory_entry_64(
+        target_task: vm_map_t,
+        size: *mut memory_object_size_t,
+        offset: memory_object_offset_t,
+        permission: vm_prot_t,
+        object_handle: *mut mach_port_t,
+        parent_entry: mem_entry_name_port_t,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_purgable_control(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        control: vm_purgable_t,
+        state: *mut ::libc::c_int,
+    ) -> kern_return_t;
+
+    pub fn mach_vm_page_info(
+        target_task: vm_task_entry_t,
+        address: mach_vm_address_t,
+        flavor: vm_page_info_flavor_t,
+        info: vm_page_info_t,
+        infoCnt: *mut mach_msg_type_number_t,
+    ) -> kern_return_t;
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use kern_return::KERN_SUCCESS;
+    use traps::mach_task_self;
+    use vm_statistics::VM_FLAGS_ANYWHERE;
+
+    #[test]
+    fn mach_vm_allocate_sanity() {
+        unsafe {
+            let size = 0x100;
+            let task = mach_task_self();
+
+            let mut address: mach_vm_address_t = 0;
+            assert_eq!(
+                mach_vm_allocate(task, &mut address, size, VM_FLAGS_ANYWHERE),
+                KERN_SUCCESS
+            );
+            assert_eq!(mach_vm_deallocate(task, address, size), KERN_SUCCESS);
+        }
+    }
+
+    #[test]
+    fn mach_vm_region_sanity() {
+        use mem;
+        use vm_prot::{VM_PROT_EXECUTE, VM_PROT_READ};
+        use vm_region::{vm_region_basic_info_64, VM_REGION_BASIC_INFO_64};
+        unsafe {
+            let mut size = 0x10;
+            let mut object_name = 0;
+            let mut address = mach_vm_region_sanity as mach_vm_address_t;
+            let mut info: vm_region_basic_info_64 = mem::zeroed();
+            let mut info_size = vm_region_basic_info_64::count();
+
+            let result = mach_vm_region(
+                mach_task_self(),
+                &mut address,
+                &mut size,
+                VM_REGION_BASIC_INFO_64,
+                (&mut info as *mut _) as vm_region_info_t,
+                &mut info_size,
+                &mut object_name,
+            );
+            assert_eq!(result, KERN_SUCCESS);
+            assert_eq!(info.protection, VM_PROT_READ | VM_PROT_EXECUTE);
+        }
+    }
+}
diff --git a/third_party/rust/mach/src/vm_attributes.rs b/third_party/rust/mach/src/vm_attributes.rs
new file mode 100644
index 000000000000..9c484b1d1797
--- /dev/null
+++ b/third_party/rust/mach/src/vm_attributes.rs
@@ -0,0 +1,18 @@
+//! This module corresponds to `mach/vm_attributes.h`.
+
+pub type vm_machine_attribute_t = ::libc::c_uint;
+
+pub const MATTR_CACHE: vm_machine_attribute_t = 1;
+pub const MATTR_MIGRATE: vm_machine_attribute_t = (1 << 1);
+pub const MATTR_REPLICATE: vm_machine_attribute_t = (1 << 2);
+
+pub type vm_machine_attribute_val_t = ::libc::c_int;
+
+pub const MATTR_VAL_OFF: vm_machine_attribute_val_t = 0;
+pub const MATTR_VAL_ON: vm_machine_attribute_val_t = 1;
+pub const MATTR_VAL_GET: vm_machine_attribute_val_t = 2;
+pub const MATTR_VAL_CACHE_FLUSH: vm_machine_attribute_val_t = 6;
+pub const MATTR_VAL_DCACHE_FLUSH: vm_machine_attribute_val_t = 7;
+pub const MATTR_VAL_ICACHE_FLUSH: vm_machine_attribute_val_t = 8;
+pub const MATTR_VAL_CACHE_SYNC: vm_machine_attribute_val_t = 9;
+pub const MATTR_VAL_GET_INFO: vm_machine_attribute_val_t = 10;
diff --git a/third_party/rust/mach/src/vm_behavior.rs b/third_party/rust/mach/src/vm_behavior.rs
new file mode 100644
index 000000000000..8ab692e550e9
--- /dev/null
+++ b/third_party/rust/mach/src/vm_behavior.rs
@@ -0,0 +1,15 @@
+//! This module corresponds to `mach/vm_behavior.h`.
+
+pub type vm_behavior_t = ::libc::c_int;
+
+pub const VM_BEHAVIOR_DEFAULT: vm_behavior_t = 0;
+pub const VM_BEHAVIOR_RANDOM: vm_behavior_t = 1;
+pub const VM_BEHAVIOR_SEQUENTIAL: vm_behavior_t = 2;
+pub const VM_BEHAVIOR_RSEQNTL: vm_behavior_t = 3;
+pub const VM_BEHAVIOR_WILLNEED: vm_behavior_t = 4;
+pub const VM_BEHAVIOR_DONTNEED: vm_behavior_t = 5;
+pub const VM_BEHAVIOR_FREE: vm_behavior_t = 6;
+pub const VM_BEHAVIOR_ZERO_WIRED_PAGES: vm_behavior_t = 7;
+pub const VM_BEHAVIOR_REUSABLE: vm_behavior_t = 8;
+pub const VM_BEHAVIOR_REUSE: vm_behavior_t = 9;
+pub const VM_BEHAVIOR_CAN_REUSE: vm_behavior_t = 10;
diff --git a/third_party/rust/mach/src/vm_inherit.rs b/third_party/rust/mach/src/vm_inherit.rs
new file mode 100644
index 000000000000..4f4c9e5ef734
--- /dev/null
+++ b/third_party/rust/mach/src/vm_inherit.rs
@@ -0,0 +1,10 @@
+//! This module corresponds to `mach/vm_inherit.h`.
+
+pub type vm_inherit_t = ::libc::c_uint;
+
+pub const VM_INHERIT_SHARE: vm_inherit_t = 0;
+pub const VM_INHERIT_COPY: vm_inherit_t = 1;
+pub const VM_INHERIT_NONE: vm_inherit_t = 2;
+pub const VM_INHERIT_DONATE_COPY: vm_inherit_t = 3;
+pub const VM_INHERIT_DEFAULT: vm_inherit_t = VM_INHERIT_COPY;
+pub const VM_INHERIT_LAST_VALID: vm_inherit_t = VM_INHERIT_NONE;
diff --git a/third_party/rust/mach/src/vm_page_size.rs b/third_party/rust/mach/src/vm_page_size.rs
new file mode 100644
index 000000000000..511932eb09a5
--- /dev/null
+++ b/third_party/rust/mach/src/vm_page_size.rs
@@ -0,0 +1,33 @@
+//! This module roughly corresponds to `mach/vm_page_size.h`
+
+use vm_types::{mach_vm_offset_t, mach_vm_size_t, vm_size_t};
+
+extern "C" {
+    pub static vm_page_size: vm_size_t;
+    pub static vm_page_mask: vm_size_t;
+    pub static vm_page_shift: ::libc::c_int;
+}
+
+pub unsafe fn mach_vm_trunc_page(x: mach_vm_offset_t) -> mach_vm_offset_t {
+    (x & !(vm_page_mask as mach_vm_size_t))
+}
+
+pub unsafe fn mach_vm_round_page(x: mach_vm_offset_t) -> mach_vm_offset_t {
+    ((x + vm_page_mask as mach_vm_size_t) & !(vm_page_mask as mach_vm_size_t))
+}
+
+#[cfg(test)]
+mod tests {
+    use vm_page_size::*;
+    use vm_types::mach_vm_size_t;
+
+    #[test]
+    fn page_size() {
+        unsafe {
+            assert!(vm_page_size > 0);
+            assert!(vm_page_size % 2 == 0);
+            assert_eq!(mach_vm_round_page(1), vm_page_size as mach_vm_size_t);
+            assert_eq!(vm_page_size, 4096);
+        }
+    }
+}
diff --git a/third_party/rust/mach/src/vm_prot.rs b/third_party/rust/mach/src/vm_prot.rs
new file mode 100644
index 000000000000..8f7d3fbc53f4
--- /dev/null
+++ b/third_party/rust/mach/src/vm_prot.rs
@@ -0,0 +1,14 @@
+//! This module corresponds to `mach/vm_prot.h`.
+
+pub type vm_prot_t = ::libc::c_int;
+
+pub const VM_PROT_NONE: vm_prot_t = 0;
+pub const VM_PROT_READ: vm_prot_t = 1;
+pub const VM_PROT_WRITE: vm_prot_t = (1 << 1);
+pub const VM_PROT_EXECUTE: vm_prot_t = (1 << 2);
+pub const VM_PROT_NO_CHANGE: vm_prot_t = (1 << 3);
+pub const VM_PROT_COPY: vm_prot_t = (1 << 4);
+pub const VM_PROT_WANTS_COPY: vm_prot_t = (1 << 4);
+pub const VM_PROT_TRUSTED: vm_prot_t = (1 << 5);
+pub const VM_PROT_DEFAULT: vm_prot_t = VM_PROT_READ | VM_PROT_WRITE;
+pub const VM_PROT_ALL: vm_prot_t = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
diff --git a/third_party/rust/mach/src/vm_purgable.rs b/third_party/rust/mach/src/vm_purgable.rs
new file mode 100644
index 000000000000..622f3b8bb01f
--- /dev/null
+++ b/third_party/rust/mach/src/vm_purgable.rs
@@ -0,0 +1,42 @@
+//! This module corresponds to `mach/vm_purgable.h`.
+
+pub type vm_purgable_t = ::libc::c_int;
+
+pub const VM_PURGABLE_SET_STATE: vm_purgable_t = 0;
+pub const VM_PURGABLE_GET_STATE: vm_purgable_t = 1;
+
+pub const VM_VOLATILE_GROUP_SHIFT: ::libc::c_int = 8;
+pub const VM_VOLATILE_GROUP_MASK: ::libc::c_int = (7 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_DEFAULT: ::libc::c_int = VM_VOLATILE_GROUP_0;
+
+pub const VM_VOLATILE_GROUP_0: ::libc::c_int = (0 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_1: ::libc::c_int = (1 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_2: ::libc::c_int = (2 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_3: ::libc::c_int = (3 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_4: ::libc::c_int = (4 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_5: ::libc::c_int = (5 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_6: ::libc::c_int = (6 << VM_VOLATILE_GROUP_SHIFT);
+pub const VM_VOLATILE_GROUP_7: ::libc::c_int = (7 << VM_VOLATILE_GROUP_SHIFT);
+
+pub const VM_PURGABLE_BEHAVIOR_SHIFT: ::libc::c_int = 6;
+pub const VM_PURGABLE_BEHAVIOR_MASK: ::libc::c_int = (1 << VM_PURGABLE_BEHAVIOR_SHIFT);
+pub const VM_PURGABLE_BEHAVIOR_FIFO: ::libc::c_int = (0 << VM_PURGABLE_BEHAVIOR_SHIFT);
+pub const VM_PURGABLE_BEHAVIOR_LIFO: ::libc::c_int = (1 << VM_PURGABLE_BEHAVIOR_SHIFT);
+
+pub const VM_PURGABLE_ORDERING_SHIFT: ::libc::c_int = 5;
+pub const VM_PURGABLE_ORDERING_MASK: ::libc::c_int = (1 << VM_PURGABLE_ORDERING_SHIFT);
+pub const VM_PURGABLE_ORDERING_OBSOLETE: ::libc::c_int = (1 << VM_PURGABLE_ORDERING_SHIFT);
+pub const VM_PURGABLE_ORDERING_NORMAL: ::libc::c_int = (0 << VM_PURGABLE_ORDERING_SHIFT);
+
+pub const VM_VOLATILE_ORDER_SHIFT: ::libc::c_int = 4;
+pub const VM_VOLATILE_ORDER_MASK: ::libc::c_int = (1 << VM_VOLATILE_ORDER_SHIFT);
+pub const VM_VOLATILE_MAKE_FIRST_IN_GROUP: ::libc::c_int = (1 << VM_VOLATILE_ORDER_SHIFT);
+pub const VM_VOLATILE_MAKE_LAST_IN_GROUP: ::libc::c_int = (0 << VM_VOLATILE_ORDER_SHIFT);
+
+pub const VM_PURGABLE_STATE_MIN: ::libc::c_int = 0;
+pub const VM_PURGABLE_STATE_MAX: ::libc::c_int = 3;
+pub const VM_PURGABLE_STATE_MASK: ::libc::c_int = 3;
+pub const VM_PURGABLE_NONVOLATILE: ::libc::c_int = 0;
+pub const VM_PURGABLE_VOLATILE: ::libc::c_int = 1;
+pub const VM_PURGABLE_EMPTY: ::libc::c_int = 2;
+pub const VM_PURGABLE_DENY: ::libc::c_int = 3;
diff --git a/third_party/rust/mach/src/vm_region.rs b/third_party/rust/mach/src/vm_region.rs
new file mode 100644
index 000000000000..0586d4ea5732
--- /dev/null
+++ b/third_party/rust/mach/src/vm_region.rs
@@ -0,0 +1,238 @@
+//! This module roughly corresponds to `mach/vm_region.h`.
+
+use boolean::boolean_t;
+use mem;
+use memory_object_types::{memory_object_offset_t, vm_object_id_t};
+use message::mach_msg_type_number_t;
+use vm_behavior::vm_behavior_t;
+use vm_inherit::vm_inherit_t;
+use vm_prot::vm_prot_t;
+use vm_types::{mach_vm_address_t, mach_vm_size_t};
+
+pub type vm32_object_id_t = u32;
+
+pub type vm_region_info_t = *mut ::libc::c_int;
+pub type vm_region_info_64_t = *mut ::libc::c_int;
+pub type vm_region_recurse_info_t = *mut ::libc::c_int;
+pub type vm_region_recurse_info_64_t = *mut ::libc::c_int;
+pub type vm_region_flavor_t = ::libc::c_int;
+pub type vm_region_info_data_t = [::libc::c_int; VM_REGION_INFO_MAX as usize];
+
+pub type vm_region_basic_info_64_t = *mut vm_region_basic_info_64;
+pub type vm_region_basic_info_data_64_t = vm_region_basic_info_64;
+pub type vm_region_basic_info_t = *mut vm_region_basic_info;
+pub type vm_region_basic_info_data_t = vm_region_basic_info;
+pub type vm_region_extended_info_t = *mut vm_region_extended_info;
+pub type vm_region_extended_info_data_t = vm_region_extended_info;
+pub type vm_region_top_info_t = *mut vm_region_top_info;
+pub type vm_region_top_info_data_t = vm_region_top_info;
+pub type vm_region_submap_info_t = *mut vm_region_submap_info;
+pub type vm_region_submap_info_data_t = vm_region_submap_info;
+pub type vm_region_submap_info_64_t = *mut vm_region_submap_info_64;
+pub type vm_region_submap_info_data_64_t = vm_region_submap_info_64;
+pub type vm_region_submap_short_info_64_t = *mut vm_region_submap_short_info_64;
+pub type vm_region_submap_short_info_data_64_t = vm_region_submap_short_info_64;
+pub type vm_page_info_t = *mut ::libc::c_int;
+pub type vm_page_info_flavor_t = ::libc::c_int;
+pub type vm_page_info_basic_t = *mut vm_page_info_basic;
+pub type vm_page_info_basic_data_t = vm_page_info_basic;
+pub type mach_vm_read_entry_t = [mach_vm_read_entry; VM_MAP_ENTRY_MAX as usize];
+
+pub const VM_REGION_INFO_MAX: ::libc::c_int = (1 << 10);
+pub const VM_MAP_ENTRY_MAX: ::libc::c_int = (1 << 8);
+
+pub const VM_PAGE_INFO_BASIC: vm_page_info_flavor_t = 1;
+
+pub const VM_REGION_BASIC_INFO_64: vm_region_flavor_t = 9;
+pub const VM_REGION_BASIC_INFO: vm_region_flavor_t = 10;
+pub const VM_REGION_EXTENDED_INFO: vm_region_flavor_t = 13;
+pub const VM_REGION_TOP_INFO: vm_region_flavor_t = 12;
+
+pub const SM_COW: ::libc::c_uchar = 1;
+pub const SM_PRIVATE: ::libc::c_uchar = 2;
+pub const SM_EMPTY: ::libc::c_uchar = 3;
+pub const SM_SHARED: ::libc::c_uchar = 4;
+pub const SM_TRUESHARED: ::libc::c_uchar = 5;
+pub const SM_PRIVATE_ALIASED: ::libc::c_uchar = 6;
+pub const SM_SHARED_ALIASED: ::libc::c_uchar = 7;
+
+#[repr(C, packed(4))]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_basic_info_64 {
+    pub protection: vm_prot_t,
+    pub max_protection: vm_prot_t,
+    pub inheritance: vm_inherit_t,
+    pub shared: boolean_t,
+    pub reserved: boolean_t,
+    pub offset: memory_object_offset_t,
+    pub behavior: vm_behavior_t,
+    pub user_wired_count: ::libc::c_ushort,
+}
+
+impl vm_region_basic_info_64 {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_basic_info {
+    pub protection: vm_prot_t,
+    pub max_protection: vm_prot_t,
+    pub inheritance: vm_inherit_t,
+    pub shared: boolean_t,
+    pub reserved: boolean_t,
+    pub offset: u32,
+    pub behavior: vm_behavior_t,
+    pub user_wired_count: ::libc::c_ushort,
+}
+
+impl vm_region_basic_info {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_extended_info {
+    pub protection: vm_prot_t,
+    pub user_tag: ::libc::c_uint,
+    pub pages_resident: ::libc::c_uint,
+    pub pages_shared_now_private: ::libc::c_uint,
+    pub pages_swapped_out: ::libc::c_uint,
+    pub pages_dirtied: ::libc::c_uint,
+    pub ref_count: ::libc::c_uint,
+    pub shadow_depth: ::libc::c_ushort,
+    pub external_pager: ::libc::c_uchar,
+    pub share_mode: ::libc::c_uchar,
+    pub pages_reusable: ::libc::c_uint,
+}
+
+impl vm_region_extended_info {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_top_info {
+    pub obj_id: ::libc::c_uint,
+    pub ref_count: ::libc::c_uint,
+    pub private_pages_resident: ::libc::c_uint,
+    pub shared_pages_resident: ::libc::c_uint,
+    pub share_mode: ::libc::c_uchar,
+}
+
+impl vm_region_top_info {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_submap_info {
+    pub protection: vm_prot_t,
+    pub max_protection: vm_prot_t,
+    pub inheritance: vm_inherit_t,
+    pub offset: u32,
+    pub user_tag: ::libc::c_uint,
+    pub pages_resident: ::libc::c_uint,
+    pub pages_shared_now_private: ::libc::c_uint,
+    pub pages_swapped_out: ::libc::c_uint,
+    pub pages_dirtied: ::libc::c_uint,
+    pub ref_count: ::libc::c_uint,
+    pub shadow_depth: ::libc::c_ushort,
+    pub external_pager: ::libc::c_uchar,
+    pub share_mode: ::libc::c_uchar,
+    pub is_submap: boolean_t,
+    pub behavior: vm_behavior_t,
+    pub object_id: vm32_object_id_t,
+    pub user_wired_count: ::libc::c_ushort,
+}
+
+impl vm_region_submap_info {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C, packed(4))]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_submap_info_64 {
+    pub protection: vm_prot_t,
+    pub max_protection: vm_prot_t,
+    pub inheritance: vm_inherit_t,
+    pub offset: memory_object_offset_t,
+    pub user_tag: ::libc::c_uint,
+    pub pages_resident: ::libc::c_uint,
+    pub pages_shared_now_private: ::libc::c_uint,
+    pub pages_swapped_out: ::libc::c_uint,
+    pub pages_dirtied: ::libc::c_uint,
+    pub ref_count: ::libc::c_uint,
+    pub shadow_depth: ::libc::c_ushort,
+    pub external_pager: ::libc::c_uchar,
+    pub share_mode: ::libc::c_uchar,
+    pub is_submap: boolean_t,
+    pub behavior: vm_behavior_t,
+    pub object_id: vm32_object_id_t,
+    pub user_wired_count: ::libc::c_ushort,
+    pub pages_reusable: ::libc::c_uint,
+}
+
+impl vm_region_submap_info_64 {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C, packed(4))]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_region_submap_short_info_64 {
+    pub protection: vm_prot_t,
+    pub max_protection: vm_prot_t,
+    pub inheritance: vm_inherit_t,
+    pub offset: memory_object_offset_t,
+    pub user_tag: ::libc::c_uint,
+    pub ref_count: ::libc::c_uint,
+    pub shadow_depth: ::libc::c_ushort,
+    pub external_pager: ::libc::c_uchar,
+    pub share_mode: ::libc::c_uchar,
+    pub is_submap: boolean_t,
+    pub behavior: vm_behavior_t,
+    pub object_id: vm32_object_id_t,
+    pub user_wired_count: ::libc::c_ushort,
+}
+
+impl vm_region_submap_short_info_64 {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_page_info_basic {
+    pub disposition: ::libc::c_int,
+    pub ref_count: ::libc::c_int,
+    pub object_id: vm_object_id_t,
+    pub offset: memory_object_offset_t,
+    pub depth: ::libc::c_int,
+    pub __pad: ::libc::c_int,
+}
+
+impl vm_page_info_basic {
+    pub fn count() -> mach_msg_type_number_t {
+        (mem::size_of::<Self>() / mem::size_of::<::libc::c_int>()) as mach_msg_type_number_t
+    }
+}
+
+#[repr(C, packed(4))]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct mach_vm_read_entry {
+    pub address: mach_vm_address_t,
+    pub size: mach_vm_size_t,
+}
diff --git a/third_party/rust/mach/src/vm_statistics.rs b/third_party/rust/mach/src/vm_statistics.rs
new file mode 100644
index 000000000000..5cc3a15548cb
--- /dev/null
+++ b/third_party/rust/mach/src/vm_statistics.rs
@@ -0,0 +1,78 @@
+//! This module roughly corresponds to `mach/vm_statistics.h`
+
+use vm_types::{integer_t, natural_t};
+
+pub type vm_statistics_t = *mut vm_statistics;
+pub type vm_statistics_data_t = vm_statistics;
+#[cfg(feature = "deprecated")]
+#[deprecated(
+    since = "0.2.3",
+    note = "`pmap_statistics_t` was removed after MacOSX 10.3.9"
+)]
+#[allow(deprecated)]
+pub type pmap_statistics_t = *mut pmap_statistics;
+
+pub const VM_PAGE_QUERY_PAGE_PRESENT: integer_t = 1;
+pub const VM_PAGE_QUERY_PAGE_FICTITIOUS: integer_t = (1 << 1);
+pub const VM_PAGE_QUERY_PAGE_REF: integer_t = (1 << 2);
+pub const VM_PAGE_QUERY_PAGE_DIRTY: integer_t = (1 << 3);
+
+pub const VM_MEMORY_MALLOC: ::libc::c_uint = 1;
+pub const VM_MEMORY_MALLOC_SMALL: ::libc::c_uint = 2;
+pub const VM_MEMORY_MALLOC_LARGE: ::libc::c_uint = 3;
+pub const VM_MEMORY_MALLOC_HUGE: ::libc::c_uint = 4;
+pub const VM_MEMORY_SBRK: ::libc::c_uint = 5;
+pub const VM_MEMORY_ANALYSIS_TOOL: ::libc::c_uint = 10;
+pub const VM_MEMORY_MACH_MSG: ::libc::c_uint = 20;
+pub const VM_MEMORY_IOKIT: ::libc::c_uint = 21;
+pub const VM_MEMORY_STACK: ::libc::c_uint = 30;
+pub const VM_MEMORY_GUARD: ::libc::c_uint = 31;
+pub const VM_MEMORY_SHARED_PMAP: ::libc::c_uint = 32;
+pub const VM_MEMORY_DYLIB: ::libc::c_uint = 33;
+pub const VM_MEMORY_APPKIT: ::libc::c_uint = 40;
+pub const VM_MEMORY_FOUNDATION: ::libc::c_uint = 41;
+pub const VM_MEMORY_COREGRAPHICS: ::libc::c_uint = 42;
+pub const VM_MEMORY_CARBON: ::libc::c_uint = 43;
+pub const VM_MEMORY_JAVA: ::libc::c_uint = 44;
+pub const VM_MEMORY_ATS: ::libc::c_uint = 50;
+pub const VM_MEMORY_DYLD: ::libc::c_uint = 60;
+pub const VM_MEMORY_DYLD_MALLOC: ::libc::c_uint = 61;
+pub const VM_MEMORY_APPLICATION_SPECIFIC_1: ::libc::c_uint = 240;
+pub const VM_MEMORY_APPLICATION_SPECIFIC_16: ::libc::c_uint = 255;
+
+pub const VM_FLAGS_FIXED: ::libc::c_int = 0x0;
+pub const VM_FLAGS_ANYWHERE: ::libc::c_int = 0x1;
+pub const VM_FLAGS_OVERWRITE: ::libc::c_int = 0x4000;
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct vm_statistics {
+    pub free_count: natural_t,
+    pub active_count: natural_t,
+    pub inactive_count: natural_t,
+    pub wire_count: natural_t,
+    pub zero_fill_count: natural_t,
+    pub reactivations: natural_t,
+    pub pageins: natural_t,
+    pub pageouts: natural_t,
+    pub faults: natural_t,
+    pub cow_faults: natural_t,
+    pub lookups: natural_t,
+    pub hits: natural_t,
+    pub purgeable_count: natural_t,
+    pub purges: natural_t,
+    pub speculative_count: natural_t,
+}
+
+#[cfg(feature = "deprecated")]
+#[deprecated(
+    since = "0.2.3",
+    note = "`pmap_statistics` was removed after MacOSX 10.3.9"
+)]
+#[cfg_attr(feature = "deprecated", allow(deprecated))]
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Hash, PartialOrd, PartialEq, Eq, Ord)]
+pub struct pmap_statistics {
+    pub resident_count: integer_t,
+    pub wired_count: integer_t,
+}
diff --git a/third_party/rust/mach/src/vm_sync.rs b/third_party/rust/mach/src/vm_sync.rs
new file mode 100644
index 000000000000..b4e21c224a28
--- /dev/null
+++ b/third_party/rust/mach/src/vm_sync.rs
@@ -0,0 +1,11 @@
+//! This module corresponds to `mach/vm_sync.h`.
+
+pub type vm_sync_t = ::libc::c_uint;
+
+pub const VM_SYNC_ASYNCHRONOUS: vm_sync_t = 1;
+pub const VM_SYNC_SYNCHRONOUS: vm_sync_t = (1 << 1);
+pub const VM_SYNC_INVALIDATE: vm_sync_t = (1 << 2);
+pub const VM_SYNC_KILLPAGES: vm_sync_t = (1 << 3);
+pub const VM_SYNC_DEACTIVATE: vm_sync_t = (1 << 4);
+pub const VM_SYNC_CONTIGUOUS: vm_sync_t = (1 << 5);
+pub const VM_SYNC_REUSABLEPAGES: vm_sync_t = (1 << 6);
diff --git a/third_party/rust/mach/src/vm_types.rs b/third_party/rust/mach/src/vm_types.rs
new file mode 100644
index 000000000000..e37b9804c4bc
--- /dev/null
+++ b/third_party/rust/mach/src/vm_types.rs
@@ -0,0 +1,19 @@
+//! This module roughly corresponds to `mach/i386/vm_types.h`.
+
+pub type natural_t = ::libc::c_uint;
+pub type integer_t = ::libc::c_int;
+
+pub type user_addr_t = u64;
+
+pub type mach_vm_address_t = u64;
+pub type mach_vm_offset_t = u64;
+pub type mach_vm_size_t = u64;
+pub type vm_map_offset_t = u64;
+pub type vm_map_address_t = u64;
+pub type vm_map_size_t = u64;
+pub type vm_map_t = ::port::mach_port_t;
+pub type vm_offset_t = ::libc::uintptr_t;
+pub type vm_size_t = ::libc::uintptr_t;
+pub type vm_address_t = vm_offset_t;
+
+pub type mach_port_context_t = mach_vm_address_t;
diff --git a/third_party/rust/raw-cpuid/.cargo-checksum.json b/third_party/rust/raw-cpuid/.cargo-checksum.json
new file mode 100644
index 000000000000..e29d34a684e0
--- /dev/null
+++ b/third_party/rust/raw-cpuid/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"AUTHORS":"f435ebf37000741d24baea378a85227fd6dcd57612a384ae7aea09e8525f9a1c","Cargo.toml":"656c0b786a78bd17e4b28f6d8ce989114d42a11f0cc9e9d071230e8777ee238a","LICENSE.md":"cdd45f4d0c552c3a51725728215919e0dedb1e1af250f130e7c2d60eef6721fe","README.md":"0eb82fa97cceb17f63e2d089258fd2db3581d226dd214951f335a88c1450684f","build.rs":"543d76bcb20e6b8e29bbbb7ac47a62efbc62db1422a0f67d6f16a8a1cc5a55c3","ci/before_deploy.ps1":"a8ee0204dd1397a245a47626fecd98eff5da76e12b15139c06271b3cc309a3e1","ci/before_deploy.sh":"ea008e2c544482cba5b659c17887ccd5354779c629096f28e667d40391299cc5","ci/install.sh":"8841985e8645d391829ba52cd669bc5c5d98b1fdd8979c7cfd3cd3573c4a0a4b","ci/script.sh":"e52273d595c672884a2a8b429765aa04708b01735055bc8e11bd3ae73d57bab2","examples/cache.rs":"c8fc57159c15a67aaf64cba3f68405357e99c55607c4f8c5ff2cb7d88fb56c30","examples/cpu.rs":"d868a1b27494ed2d2cf3a940fc51ce50cbb56545575b43d47eea82a663cdf02b","examples/topology.rs":"514a41877c4f2f7a8835c700667e87b78b72e28a695e43da35c0fde512c68a85","examples/tsc_frequency.rs":"f5fb92a82b72d6bd8a55006d9b494da650c5bb398c0635f198616196421f243c","src/bin/cpuid.rs":"10f50c6e5d2917cea59c273b2bad439646c5ca53b8224a44c80ca30c7b378408","src/cpuid.c":"79fa0d852dba6e5e8fd1e7a0e9b8e28369818651a25bbf5d4a0c5e79320053aa","src/lib.rs":"27a1278fd3a1de7c529a98de05658dc328463ee14e05761a68ac388182e7a31e","src/tests.rs":"0fbdd825301037d7f6efc01ba6931e46b33d3363e27bb3c982cdb86a55c2518b"},"package":"b4a349ca83373cfa5d6dbb66fd76e58b2cca08da71a5f6400de0a0a6a9bceeaf"}
\ No newline at end of file
diff --git a/third_party/rust/raw-cpuid/AUTHORS b/third_party/rust/raw-cpuid/AUTHORS
new file mode 100644
index 000000000000..16a6b2880733
--- /dev/null
+++ b/third_party/rust/raw-cpuid/AUTHORS
@@ -0,0 +1,3 @@
+Gerd Zellweger <mail@gerdzellweger.com>
+Bence Meszaros <bence.me@gmail.com>
+Rafal Mielniczuk <rafalm3@gmail.com>
diff --git a/third_party/rust/raw-cpuid/Cargo.toml b/third_party/rust/raw-cpuid/Cargo.toml
new file mode 100644
index 000000000000..58c95d775724
--- /dev/null
+++ b/third_party/rust/raw-cpuid/Cargo.toml
@@ -0,0 +1,55 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "raw-cpuid"
+version = "7.0.3"
+authors = ["Gerd Zellweger <mail@gerdzellweger.com>"]
+build = "build.rs"
+description = "A library to parse the x86 CPUID instruction, written in rust with no external dependencies. The implementation closely resembles the Intel CPUID manual description. The library does only depend on libcore."
+homepage = "https://github.com/gz/rust-cpuid"
+documentation = "https://docs.rs/raw-cpuid/"
+readme = "README.md"
+keywords = ["cpuid", "x86", "amd64", "os", "libcore"]
+license = "MIT"
+repository = "https://github.com/gz/rust-cpuid"
+
+[[bin]]
+name = "cpuid"
+path = "src/bin/cpuid.rs"
+[dependencies.bitflags]
+version = "1.1"
+
+[dependencies.serde]
+version = "1.0"
+optional = true
+default-features = false
+
+[dependencies.serde_derive]
+version = "1.0"
+optional = true
+[build-dependencies.cc]
+version = "1"
+
+[build-dependencies.rustc_version]
+version = "0.2"
+
+[features]
+nightly = []
+serialize = ["serde", "serde_derive"]
+use_arch = []
+[target."cfg(unix)".dev-dependencies.core_affinity]
+version = "0.5.9"
+
+[target."cfg(unix)".dev-dependencies.libc]
+version = "0.2"
+default-features = false
diff --git a/third_party/rust/raw-cpuid/LICENSE.md b/third_party/rust/raw-cpuid/LICENSE.md
new file mode 100644
index 000000000000..e734b146b0e8
--- /dev/null
+++ b/third_party/rust/raw-cpuid/LICENSE.md
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015 Gerd Zellweger
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/third_party/rust/raw-cpuid/README.md b/third_party/rust/raw-cpuid/README.md
new file mode 100644
index 000000000000..a17ccad8b1ee
--- /dev/null
+++ b/third_party/rust/raw-cpuid/README.md
@@ -0,0 +1,38 @@
+# cpuid [![Build Status](https://travis-ci.org/gz/rust-cpuid.svg)](https://travis-ci.org/gz/rust-cpuid) [![Crates.io](https://img.shields.io/crates/v/raw_cpuid.svg)](https://crates.io/crates/raw-cpuid)
+
+A library to parse the x86 CPUID instruction, written in rust with no external dependencies. The implementation closely resembles the Intel CPUID manual description. The library does only depend on libcore.
+
+The code should be in sync with the latest March 2018 revision of the Intel Architectures Software Developer’s Manual.
+
+## Library usage
+```rust
+let cpuid = CpuId::new();
+
+match cpuid.get_vendor_info() {
+    Some(vf) => assert!(vf.as_string() == "GenuineIntel"),
+    None => ()
+}
+
+let has_sse = match cpuid.get_feature_info() {
+    Some(finfo) => finfo.has_sse(),
+    None => false
+};
+
+if has_sse {
+    println!("CPU supports SSE!");
+}
+
+match cpuid.get_cache_parameters() {
+    Some(cparams) => {
+        for cache in cparams {
+            let size = cache.associativity() * cache.physical_line_partitions() * cache.coherency_line_size() * cache.sets();
+            println!("L{}-Cache size is {}", cache.level(), size);
+        }
+    },
+    None => println!("No cache parameter information available"),
+}
+```
+
+## Documentation
+* [API Documentation](https://docs.rs/raw-cpuid/)
+* [Examples](https://github.com/gz/rust-cpuid/tree/master/examples)
diff --git a/third_party/rust/raw-cpuid/build.rs b/third_party/rust/raw-cpuid/build.rs
new file mode 100644
index 000000000000..1c41b6ee7e54
--- /dev/null
+++ b/third_party/rust/raw-cpuid/build.rs
@@ -0,0 +1,16 @@
+extern crate cc;
+extern crate rustc_version;
+use rustc_version::{version, version_meta, Channel, Version};
+
+fn main() {
+    let newer_than_1_27 = version().unwrap() >= Version::parse("1.27.0").unwrap();
+    if newer_than_1_27 {
+        println!("cargo:rustc-cfg=feature=\"use_arch\"");
+    } else {
+        cc::Build::new().file("src/cpuid.c").compile("libcpuid.a");
+    }
+
+    if version_meta().unwrap().channel == Channel::Nightly {
+        println!("cargo:rustc-cfg=feature=\"nightly\"");
+    }
+}
diff --git a/third_party/rust/raw-cpuid/ci/before_deploy.ps1 b/third_party/rust/raw-cpuid/ci/before_deploy.ps1
new file mode 100644
index 000000000000..191a30b88d75
--- /dev/null
+++ b/third_party/rust/raw-cpuid/ci/before_deploy.ps1
@@ -0,0 +1,23 @@
+# This script takes care of packaging the build artifacts that will go in the
+# release zipfile
+
+$SRC_DIR = $PWD.Path
+$STAGE = [System.Guid]::NewGuid().ToString()
+
+Set-Location $ENV:Temp
+New-Item -Type Directory -Name $STAGE
+Set-Location $STAGE
+
+$ZIP = "$SRC_DIR\$($Env:CRATE_NAME)-$($Env:APPVEYOR_REPO_TAG_NAME)-$($Env:TARGET).zip"
+
+# TODO Update this to package the right artifacts
+Copy-Item "$SRC_DIR\target\$($Env:TARGET)\release\hello.exe" '.\'
+
+7z a "$ZIP" *
+
+Push-AppveyorArtifact "$ZIP"
+
+Remove-Item *.* -Force
+Set-Location ..
+Remove-Item $STAGE
+Set-Location $SRC_DIR
diff --git a/third_party/rust/raw-cpuid/ci/before_deploy.sh b/third_party/rust/raw-cpuid/ci/before_deploy.sh
new file mode 100644
index 000000000000..026dc2898d07
--- /dev/null
+++ b/third_party/rust/raw-cpuid/ci/before_deploy.sh
@@ -0,0 +1,33 @@
+# This script takes care of building your crate and packaging it for release
+
+set -ex
+
+main() {
+    local src=$(pwd) \
+          stage=
+
+    case $TRAVIS_OS_NAME in
+        linux)
+            stage=$(mktemp -d)
+            ;;
+        osx)
+            stage=$(mktemp -d -t tmp)
+            ;;
+    esac
+
+    test -f Cargo.lock || cargo generate-lockfile
+
+    # TODO Update this to build the artifacts that matter to you
+    cross rustc --bin hello --target $TARGET --release -- -C lto
+
+    # TODO Update this to package the right artifacts
+    cp target/$TARGET/release/hello $stage/
+
+    cd $stage
+    tar czf $src/$CRATE_NAME-$TRAVIS_TAG-$TARGET.tar.gz *
+    cd $src
+
+    rm -rf $stage
+}
+
+main
diff --git a/third_party/rust/raw-cpuid/ci/install.sh b/third_party/rust/raw-cpuid/ci/install.sh
new file mode 100644
index 000000000000..80e18e472087
--- /dev/null
+++ b/third_party/rust/raw-cpuid/ci/install.sh
@@ -0,0 +1,47 @@
+set -ex
+
+main() {
+    local target=
+    if [ $TRAVIS_OS_NAME = linux ]; then
+        target=x86_64-unknown-linux-musl
+        sort=sort
+    else
+        target=x86_64-apple-darwin
+        sort=gsort  # for `sort --sort-version`, from brew's coreutils.
+    fi
+
+    # Builds for iOS are done on OSX, but require the specific target to be
+    # installed.
+    case $TARGET in
+        aarch64-apple-ios)
+            rustup target install aarch64-apple-ios
+            ;;
+        armv7-apple-ios)
+            rustup target install armv7-apple-ios
+            ;;
+        armv7s-apple-ios)
+            rustup target install armv7s-apple-ios
+            ;;
+        i386-apple-ios)
+            rustup target install i386-apple-ios
+            ;;
+        x86_64-apple-ios)
+            rustup target install x86_64-apple-ios
+            ;;
+    esac
+
+    # This fetches latest stable release
+    local tag=$(git ls-remote --tags --refs --exit-code https://github.com/japaric/cross \
+                       | cut -d/ -f3 \
+                       | grep -E '^v[0.1.0-9.]+$' \
+                       | $sort --version-sort \
+                       | tail -n1)
+    curl -LSfs https://japaric.github.io/trust/install.sh | \
+        sh -s -- \
+           --force \
+           --git japaric/cross \
+           --tag $tag \
+           --target $target
+}
+
+main
diff --git a/third_party/rust/raw-cpuid/ci/script.sh b/third_party/rust/raw-cpuid/ci/script.sh
new file mode 100644
index 000000000000..ddd7f9362a44
--- /dev/null
+++ b/third_party/rust/raw-cpuid/ci/script.sh
@@ -0,0 +1,24 @@
+# This script takes care of testing your crate
+
+set -ex
+
+# TODO This is the "test phase", tweak it as you see fit
+main() {
+    cross build --target $TARGET
+    cross build --target $TARGET --release
+
+    if [ ! -z $DISABLE_TESTS ]; then
+        return
+    fi
+
+    cross test --target $TARGET
+    cross test --target $TARGET --release
+
+    cross run --target $TARGET
+    cross run --target $TARGET --release
+}
+
+# we don't run the "test phase" when doing deploys
+if [ -z $TRAVIS_TAG ]; then
+    main
+fi
diff --git a/third_party/rust/raw-cpuid/examples/cache.rs b/third_party/rust/raw-cpuid/examples/cache.rs
new file mode 100644
index 000000000000..f71d22cdee33
--- /dev/null
+++ b/third_party/rust/raw-cpuid/examples/cache.rs
@@ -0,0 +1,52 @@
+//! Example that displays information about the caches.
+extern crate raw_cpuid;
+use raw_cpuid::{CacheType, CpuId};
+
+fn main() {
+    let cpuid = CpuId::new();
+    cpuid.get_cache_parameters().map_or_else(
+        || println!("No cache parameter information available"),
+        |cparams| {
+            for cache in cparams {
+                let size = cache.associativity()
+                    * cache.physical_line_partitions()
+                    * cache.coherency_line_size()
+                    * cache.sets();
+
+                let typ = match cache.cache_type() {
+                    CacheType::Data => "Instruction-Cache",
+                    CacheType::Instruction => "Data-Cache",
+                    CacheType::Unified => "Unified-Cache",
+                    _ => "Unknown cache type",
+                };
+
+                let associativity = if cache.is_fully_associative() {
+                    format!("fully associative")
+                } else {
+                    format!("{}-way associativity", cache.associativity())
+                };
+
+                let size_repr = if size > 1024 * 1024 {
+                    format!("{} MiB", size / (1024 * 1024))
+                } else {
+                    format!("{} KiB", size / 1024)
+                };
+
+                let mapping = if cache.has_complex_indexing() {
+                    "hash-based-mapping"
+                } else {
+                    "direct-mapped"
+                };
+
+                println!(
+                    "L{} {}: ({}, {}, {})",
+                    cache.level(),
+                    typ,
+                    size_repr,
+                    associativity,
+                    mapping
+                );
+            }
+        },
+    );
+}
diff --git a/third_party/rust/raw-cpuid/examples/cpu.rs b/third_party/rust/raw-cpuid/examples/cpu.rs
new file mode 100644
index 000000000000..d6812916b978
--- /dev/null
+++ b/third_party/rust/raw-cpuid/examples/cpu.rs
@@ -0,0 +1,27 @@
+//! An example that displays the type/features/configuration of the CPU.
+extern crate raw_cpuid;
+
+fn main() {
+    let cpuid = raw_cpuid::CpuId::new();
+
+    let vendor_string = cpuid.get_vendor_info().map_or_else(
+        || String::from("Unknown Vendor"),
+        |vf| String::from(vf.as_string()),
+    );
+
+    let brand_string: String = cpuid.get_extended_function_info().map_or_else(
+        || String::from("Unknown CPU"),
+        |extfuninfo| {
+            println!("{:?}", extfuninfo.extended_signature());
+            String::from(extfuninfo.processor_brand_string().unwrap_or("Unknown CPU"))
+        },
+    );
+
+    /*let serial_nr = cpuid.get_processor_serial().map_or_else(
+        || String::from(""),
+        |extfuninfo| String::from(extfuninfo.processor_brand_string().unwrap_or("Unknown CPU")),
+    );*/
+
+    println!("Vendor is: {}", vendor_string);
+    println!("CPU Model is: {}", brand_string);
+}
diff --git a/third_party/rust/raw-cpuid/examples/topology.rs b/third_party/rust/raw-cpuid/examples/topology.rs
new file mode 100644
index 000000000000..fe023454d539
--- /dev/null
+++ b/third_party/rust/raw-cpuid/examples/topology.rs
@@ -0,0 +1,196 @@
+//! An example that uses CPUID to determine the system topology.
+//!
+//! Intel Topology is a pretty complicated subject (unfortunately):
+//! https://software.intel.com/en-us/articles/intel-64-architecture-processor-topology-enumeration/
+extern crate core_affinity;
+extern crate raw_cpuid;
+
+use raw_cpuid::{CpuId, ExtendedTopologyLevel, TopologyType};
+use std::thread;
+
+/// Runs CPU ID on every core in the system (to gather all APIC IDs).
+///
+/// # Note
+/// This won't work on macOS, apparently there is no guarantee after setting the affinity
+/// that a thread will really execute on the pinned core.
+fn gather_all_xapic_ids() -> Vec<u8> {
+    let core_ids = core_affinity::get_core_ids().unwrap();
+
+    // Create a thread for each active CPU core.
+    core_ids
+        .into_iter()
+        .map(|id| {
+            thread::spawn(move || {
+                // Pin this thread to a single CPU core.
+                core_affinity::set_for_current(id);
+                // Do more work after this.
+                let cpuid = CpuId::new();
+                cpuid
+                    .get_feature_info()
+                    .map_or_else(|| 0, |finfo| finfo.initial_local_apic_id())
+            })
+            .join()
+            .unwrap_or(0)
+        })
+        .collect::<Vec<_>>()
+}
+
+/// Runs CPU ID on every core in the system (to gather all x2APIC IDs).
+///
+/// # Note
+/// This won't work on macOS, apparently there is no guarantee after setting the affinity
+/// that a thread will really execute on the pinned core.
+fn gather_all_x2apic_ids() -> Vec<u32> {
+    let core_ids = core_affinity::get_core_ids().unwrap();
+
+    // Create a thread for each active CPU core.
+    core_ids
+        .into_iter()
+        .map(|id| {
+            thread::spawn(move || {
+                // Pin this thread to a single CPU core.
+                core_affinity::set_for_current(id);
+                // Do more work after this.
+                let cpuid = CpuId::new();
+                cpuid.get_extended_topology_info().map_or_else(
+                    || 0,
+                    |mut topiter| topiter.next().as_ref().unwrap().x2apic_id(),
+                )
+            })
+            .join()
+            .unwrap_or(0)
+        })
+        .collect::<Vec<_>>()
+}
+
+fn enumerate_with_extended_topology_info() {
+    let cpuid = CpuId::new();
+    let mut smt_x2apic_shift: u32 = 0;
+    let mut core_x2apic_shift: u32 = 0;
+
+    cpuid.get_extended_topology_info().map_or_else(
+        || println!("No topology information available."),
+        |topoiter| {
+            let topology: Vec<ExtendedTopologyLevel> = topoiter.collect();
+            for topolevel in topology.iter() {
+                match topolevel.level_type() {
+                    TopologyType::SMT => {
+                        smt_x2apic_shift = topolevel.shift_right_for_next_apic_id();
+                    }
+                    TopologyType::Core => {
+                        core_x2apic_shift = topolevel.shift_right_for_next_apic_id();
+                    }
+                    _ => panic!("Topology category not supported."),
+                };
+            }
+        },
+    );
+
+    println!("Enumeration of all cores in the system (with x2APIC IDs):");
+    let mut all_x2apic_ids: Vec<u32> = gather_all_x2apic_ids();
+    all_x2apic_ids.sort();
+    for x2apic_id in all_x2apic_ids {
+        let smt_select_mask = !(u32::max_value() << smt_x2apic_shift);
+        let core_select_mask = (!((u32::max_value()) << core_x2apic_shift)) ^ smt_select_mask;
+        let pkg_select_mask = u32::max_value() << core_x2apic_shift;
+
+        let smt_id = x2apic_id & smt_select_mask;
+        let core_id = (x2apic_id & core_select_mask) >> smt_x2apic_shift;
+        let pkg_id = (x2apic_id & pkg_select_mask) >> core_x2apic_shift;
+
+        println!(
+            "x2APIC#{} (pkg: {}, core: {}, smt: {})",
+            x2apic_id, pkg_id, core_id, smt_id
+        );
+    }
+}
+
+fn enumerate_with_legacy_leaf_1_4() {
+    let cpuid = CpuId::new();
+    let max_logical_processor_ids = cpuid
+        .get_feature_info()
+        .map_or_else(|| 0, |finfo| finfo.max_logical_processor_ids());
+
+    let mut smt_max_cores_for_package: u8 = 0;
+    cpuid.get_cache_parameters().map_or_else(
+        || println!("No cache parameter information available"),
+        |cparams| {
+            for (ecx, cache) in cparams.enumerate() {
+                if ecx == 0 {
+                    smt_max_cores_for_package = cache.max_cores_for_package() as u8;
+                }
+            }
+        },
+    );
+
+    fn log2(o: u8) -> u8 {
+        7 - o.leading_zeros() as u8
+    }
+
+    let smt_mask_width: u8 =
+        log2(max_logical_processor_ids.next_power_of_two() / (smt_max_cores_for_package));
+    let smt_select_mask: u8 = !(u8::max_value() << smt_mask_width);
+
+    let core_mask_width: u8 = log2(smt_max_cores_for_package);
+    let core_only_select_mask =
+        (!(u8::max_value() << (core_mask_width + smt_mask_width))) ^ smt_select_mask;
+
+    let pkg_select_mask = u8::max_value() << (core_mask_width + smt_mask_width);
+
+    println!("Enumeration of all cores in the system (with APIC IDs):");
+    let mut all_xapic_ids: Vec<u8> = gather_all_xapic_ids();
+    all_xapic_ids.sort();
+
+    for xapic_id in all_xapic_ids {
+        let smt_id = xapic_id & smt_select_mask;
+        let core_id = (xapic_id & core_only_select_mask) >> smt_mask_width;
+        let pkg_id = (xapic_id & pkg_select_mask) >> (core_mask_width + smt_mask_width);
+
+        println!(
+            "APIC#{} (pkg: {}, core: {}, smt: {})",
+            xapic_id, pkg_id, core_id, smt_id
+        );
+    }
+}
+
+fn main() {
+    let cpuid = CpuId::new();
+
+    cpuid.get_extended_function_info().map_or_else(
+        || println!("Couldn't find processor serial number."),
+        |extfuninfo| {
+            println!(
+                "CPU Model is: {}",
+                extfuninfo.processor_brand_string().unwrap_or("Unknown CPU")
+            )
+        },
+    );
+    cpuid.get_extended_topology_info().map_or_else(
+        || println!("No topology information available."),
+        |topoiter| {
+            let mut topology: Vec<ExtendedTopologyLevel> = topoiter.collect();
+            topology.reverse();
+
+            for topolevel in topology.iter() {
+                let typ = match topolevel.level_type() {
+                    TopologyType::SMT => "SMT-threads",
+                    TopologyType::Core => "cores",
+                    _ => panic!("Topology category not supported."),
+                };
+
+                println!(
+                    "At level {} the CPU has: {} {}",
+                    topolevel.level_number(),
+                    topolevel.processors(),
+                    typ,
+                );
+            }
+        },
+    );
+
+    println!("");
+    enumerate_with_legacy_leaf_1_4();
+
+    println!("");
+    enumerate_with_extended_topology_info();
+}
diff --git a/third_party/rust/raw-cpuid/examples/tsc_frequency.rs b/third_party/rust/raw-cpuid/examples/tsc_frequency.rs
new file mode 100644
index 000000000000..8c7d671a3367
--- /dev/null
+++ b/third_party/rust/raw-cpuid/examples/tsc_frequency.rs
@@ -0,0 +1,80 @@
+//! An example that determines the time stamp counter frequency (RDTSC, RDTSCP) .
+extern crate raw_cpuid;
+
+use std::time;
+
+const MHZ_TO_HZ: u64 = 1000000;
+const KHZ_TO_HZ: u64 = 1000;
+
+fn main() {
+    let cpuid = raw_cpuid::CpuId::new();
+    let has_tsc = cpuid
+        .get_feature_info()
+        .map_or(false, |finfo| finfo.has_tsc());
+
+    let has_invariant_tsc = cpuid
+        .get_extended_function_info()
+        .map_or(false, |efinfo| efinfo.has_invariant_tsc());
+
+    let tsc_frequency_hz = cpuid.get_tsc_info().map(|tinfo| {
+        if tinfo.nominal_frequency() != 0 {
+            Some(tinfo.tsc_frequency())
+        } else if tinfo.numerator() != 0 && tinfo.denominator() != 0 {
+            // Skylake and Kabylake don't report the crystal clock, approximate with base frequency:
+            cpuid
+                .get_processor_frequency_info()
+                .map(|pinfo| pinfo.processor_base_frequency() as u64 * MHZ_TO_HZ)
+                .map(|cpu_base_freq_hz| {
+                    let crystal_hz =
+                        cpu_base_freq_hz * tinfo.denominator() as u64 / tinfo.numerator() as u64;
+                    crystal_hz * tinfo.numerator() as u64 / tinfo.denominator() as u64
+                })
+        } else {
+            None
+        }
+    });
+
+    if has_tsc {
+        // Try to figure out TSC frequency with CPUID
+        println!(
+            "TSC Frequency is: {} ({})",
+            match tsc_frequency_hz {
+                Some(x) => format!("{} Hz", x.unwrap_or(0)),
+                None => String::from("unknown"),
+            },
+            if has_invariant_tsc {
+                "invariant"
+            } else {
+                "TSC frequency varies with speed-stepping"
+            }
+        );
+
+        // Check if we run in a VM and the hypervisor can give us the TSC frequency
+        cpuid.get_hypervisor_info().map(|hv| {
+            hv.tsc_frequency().map(|tsc_khz| {
+                let virtual_tsc_frequency_hz = tsc_khz as u64 * KHZ_TO_HZ;
+                println!(
+                    "Hypervisor reports TSC Frequency at: {} Hz",
+                    virtual_tsc_frequency_hz
+                );
+            })
+        });
+
+        // Determine TSC frequency by measuring it (loop for a second, record ticks)
+        let one_second = time::Duration::from_secs(1);
+        let now = time::Instant::now();
+        let start = unsafe { core::arch::x86_64::_rdtsc() };
+        loop {
+            if now.elapsed() >= one_second {
+                break;
+            }
+        }
+        let end = unsafe { core::arch::x86_64::_rdtsc() };
+        println!(
+            "Empirical measurement of TSC frequency was: {} Hz",
+            (end - start)
+        );
+    } else {
+        println!("System does not have a TSC.")
+    }
+}
diff --git a/third_party/rust/raw-cpuid/src/bin/cpuid.rs b/third_party/rust/raw-cpuid/src/bin/cpuid.rs
new file mode 100644
index 000000000000..8f75433347f8
--- /dev/null
+++ b/third_party/rust/raw-cpuid/src/bin/cpuid.rs
@@ -0,0 +1,98 @@
+extern crate raw_cpuid;
+
+use raw_cpuid::CpuId;
+
+fn main() {
+    let cpuid = CpuId::new();
+    // Implement Display for each of those structs
+    cpuid.get_vendor_info().map(|info| {
+        println!("Vendor");
+        println!("{}", info);
+    });
+    cpuid.get_feature_info().map(|info| {
+        println!("Feature");
+        println!("{:?}", info);
+    });
+    cpuid.get_cache_info().map(|info| {
+        println!("Cache");
+        println!("{:?}", info);
+    });
+    cpuid.get_processor_serial().map(|info| {
+        println!("Processor Serial");
+        println!("{:?}", info);
+    });
+    cpuid.get_cache_parameters().map(|info| {
+        println!("Cache Parameters");
+        println!("{:?}", info);
+    });
+    cpuid.get_monitor_mwait_info().map(|info| {
+        println!("Monitor/MWait");
+        println!("{:?}", info);
+    });
+    cpuid.get_thermal_power_info().map(|info| {
+        println!("Thermal Power");
+        println!("{:?}", info);
+    });
+    cpuid.get_extended_feature_info().map(|info| {
+        println!("Extended Features");
+        println!("{:?}", info);
+    });
+    cpuid.get_direct_cache_access_info().map(|info| {
+        println!("Direct Cache Access");
+        println!("{:?}", info);
+    });
+    cpuid.get_performance_monitoring_info().map(|info| {
+        println!("Performance Monitoring");
+        println!("{:?}", info);
+    });
+    cpuid.get_extended_topology_info().map(|info| {
+        println!("Extended Topology");
+        println!("{:?}", info);
+    });
+    cpuid.get_extended_state_info().map(|info| {
+        println!("Extended State");
+        println!("{:?}", info);
+    });
+    cpuid.get_rdt_monitoring_info().map(|info| {
+        println!("RDT Monitoring");
+        println!("{:?}", info);
+    });
+    cpuid.get_rdt_allocation_info().map(|info| {
+        println!("RDT Allocation");
+        println!("{:?}", info);
+    });
+    cpuid.get_sgx_info().map(|info| {
+        println!("Software Guard Extensions");
+        println!("{:?}", info);
+    });
+    cpuid.get_processor_trace_info().map(|info| {
+        println!("Processor Trace");
+        println!("{:?}", info);
+    });
+    cpuid.get_tsc_info().map(|info| {
+        println!("TSC");
+        println!("{:?}", info);
+    });
+    cpuid.get_processor_frequency_info().map(|info| {
+        println!("Processor Frequency");
+        println!("{:?}", info);
+    });
+    cpuid.deterministic_address_translation_info().map(|dats| {
+        println!("Deterministic Address Translation");
+        for dat in dats {
+            println!("{:?}", dat);
+        }
+    });
+    cpuid.get_soc_vendor_info().map(|info| {
+        println!("SoC Vendor Info");
+        println!("{:?}", info);
+    });
+    cpuid.get_extended_function_info().map(|info| {
+        println!("Extended Function Info");
+        println!("{:?}", info);
+    });
+    cpuid.get_memory_encryption_info().map(|info| {
+        println!("Memory Encryption Info");
+        println!("{:?}", info);
+    });
+}
diff --git a/third_party/rust/raw-cpuid/src/cpuid.c b/third_party/rust/raw-cpuid/src/cpuid.c
new file mode 100644
index 000000000000..c014da437418
--- /dev/null
+++ b/third_party/rust/raw-cpuid/src/cpuid.c
@@ -0,0 +1,32 @@
+#include <stdint.h>
+
+void cpuid(uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx) {
+#ifdef _MSC_VER
+  uint32_t regs[4];
+  __cpuidex((int *)regs, *eax, *ecx);
+  *eax = regs[0], *ebx = regs[1], *ecx = regs[2], *edx = regs[3];
+#else
+  asm volatile(
+#if defined(__i386__) && defined(__PIC__)
+      // The reason for this ebx juggling is the -fPIC rust compilation mode.
+      // On 32-bit to locate variables it uses a global offset table whose
+      // pointer is stored in ebx. Without temporary storing ebx in edi, the
+      // compiler will complain about inconsistent operand constraints in an
+      // 'asm'.
+      // Also note that this is only an issue on older compiler versions.
+      "mov %%ebx, %%edi;"
+      "cpuid;"
+      "xchgl %%ebx, %%edi;"
+      :
+      "+a" (*eax),
+      "=D" (*ebx),
+#else
+      "cpuid"
+      :
+      "+a"(*eax),
+      "=b"(*ebx),
+#endif
+      "+c"(*ecx),
+      "=d"(*edx));
+#endif
+}
diff --git a/third_party/rust/raw-cpuid/src/lib.rs b/third_party/rust/raw-cpuid/src/lib.rs
new file mode 100644
index 000000000000..24ffc49b2d90
--- /dev/null
+++ b/third_party/rust/raw-cpuid/src/lib.rs
@@ -0,0 +1,4392 @@
+#![no_std]
+#![crate_name = "raw_cpuid"]
+#![crate_type = "lib"]
+
+#[cfg(test)]
+#[macro_use]
+extern crate std;
+
+#[cfg(test)]
+mod tests;
+#[cfg(feature = "serialize")]
+#[macro_use]
+extern crate serde_derive;
+
+#[macro_use]
+extern crate bitflags;
+
+/// Provides `cpuid` on stable by linking against a C implementation.
+#[cfg(not(feature = "use_arch"))]
+pub mod native_cpuid {
+    use super::CpuIdResult;
+
+    extern "C" {
+        fn cpuid(a: *mut u32, b: *mut u32, c: *mut u32, d: *mut u32);
+    }
+
+    pub fn cpuid_count(mut eax: u32, mut ecx: u32) -> CpuIdResult {
+        let mut ebx = 0u32;
+        let mut edx = 0u32;
+
+        unsafe {
+            cpuid(&mut eax, &mut ebx, &mut ecx, &mut edx);
+        }
+
+        CpuIdResult { eax, ebx, ecx, edx }
+    }
+}
+
+/// Uses Rust's `cpuid` function from the `arch` module.
+#[cfg(feature = "use_arch")]
+pub mod native_cpuid {
+    use super::CpuIdResult;
+
+    #[cfg(target_arch = "x86")]
+    use core::arch::x86 as arch;
+    #[cfg(target_arch = "x86_64")]
+    use core::arch::x86_64 as arch;
+
+    pub fn cpuid_count(a: u32, c: u32) -> CpuIdResult {
+        let result = unsafe { self::arch::__cpuid_count(a, c) };
+
+        CpuIdResult {
+            eax: result.eax,
+            ebx: result.ebx,
+            ecx: result.ecx,
+            edx: result.edx,
+        }
+    }
+}
+
+use core::cmp::min;
+use core::fmt;
+use core::mem::transmute;
+use core::slice;
+use core::str;
+
+#[cfg(not(test))]
+mod std {
+    pub use core::ops;
+    pub use core::option;
+}
+
+/// Macro which queries cpuid directly.
+///
+/// First parameter is cpuid leaf (EAX register value),
+/// second optional parameter is the subleaf (ECX register value).
+#[macro_export]
+macro_rules! cpuid {
+    ($eax:expr) => {
+        $crate::native_cpuid::cpuid_count($eax as u32, 0)
+    };
+
+    ($eax:expr, $ecx:expr) => {
+        $crate::native_cpuid::cpuid_count($eax as u32, $ecx as u32)
+    };
+}
+
+fn as_bytes(v: &u32) -> &[u8] {
+    let start = v as *const u32 as *const u8;
+    unsafe { slice::from_raw_parts(start, 4) }
+}
+
+fn get_bits(r: u32, from: u32, to: u32) -> u32 {
+    assert!(from <= 31);
+    assert!(to <= 31);
+    assert!(from <= to);
+
+    let mask = match to {
+        31 => 0xffffffff,
+        _ => (1 << (to + 1)) - 1,
+    };
+
+    (r & mask) >> from
+}
+
+macro_rules! check_flag {
+    ($doc:meta, $fun:ident, $flags:ident, $flag:expr) => (
+        #[$doc]
+        pub fn $fun(&self) -> bool {
+            self.$flags.contains($flag)
+        }
+    )
+}
+
+macro_rules! is_bit_set {
+    ($field:expr, $bit:expr) => {
+        $field & (1 << $bit) > 0
+    };
+}
+
+macro_rules! check_bit_fn {
+    ($doc:meta, $fun:ident, $field:ident, $bit:expr) => (
+        #[$doc]
+        pub fn $fun(&self) -> bool {
+            is_bit_set!(self.$field, $bit)
+        }
+    )
+}
+
+/// Main type used to query for information about the CPU we're running on.
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CpuId {
+    max_eax_value: u32,
+}
+
+/// Low-level data-structure to store result of cpuid instruction.
+#[derive(Copy, Clone, Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CpuIdResult {
+    /// Return value EAX register
+    pub eax: u32,
+    /// Return value EBX register
+    pub ebx: u32,
+    /// Return value ECX register
+    pub ecx: u32,
+    /// Return value EDX register
+    pub edx: u32,
+}
+
+const EAX_VENDOR_INFO: u32 = 0x0;
+const EAX_FEATURE_INFO: u32 = 0x1;
+const EAX_CACHE_INFO: u32 = 0x2;
+const EAX_PROCESSOR_SERIAL: u32 = 0x3;
+const EAX_CACHE_PARAMETERS: u32 = 0x4;
+const EAX_MONITOR_MWAIT_INFO: u32 = 0x5;
+const EAX_THERMAL_POWER_INFO: u32 = 0x6;
+const EAX_STRUCTURED_EXTENDED_FEATURE_INFO: u32 = 0x7;
+const EAX_DIRECT_CACHE_ACCESS_INFO: u32 = 0x9;
+const EAX_PERFORMANCE_MONITOR_INFO: u32 = 0xA;
+const EAX_EXTENDED_TOPOLOGY_INFO: u32 = 0xB;
+const EAX_EXTENDED_STATE_INFO: u32 = 0xD;
+const EAX_RDT_MONITORING: u32 = 0xF;
+const EAX_RDT_ALLOCATION: u32 = 0x10;
+const EAX_SGX: u32 = 0x12;
+const EAX_TRACE_INFO: u32 = 0x14;
+const EAX_TIME_STAMP_COUNTER_INFO: u32 = 0x15;
+const EAX_FREQUENCY_INFO: u32 = 0x16;
+const EAX_SOC_VENDOR_INFO: u32 = 0x17;
+const EAX_DETERMINISTIC_ADDRESS_TRANSLATION_INFO: u32 = 0x18;
+const EAX_HYPERVISOR_INFO: u32 = 0x40000000;
+const EAX_EXTENDED_FUNCTION_INFO: u32 = 0x80000000;
+const EAX_MEMORY_ENCRYPTION_INFO: u32 = 0x8000001F;
+
+impl CpuId {
+    /// Return new CPUID struct.
+    pub fn new() -> CpuId {
+        let res = cpuid!(EAX_VENDOR_INFO);
+        CpuId {
+            max_eax_value: res.eax,
+        }
+    }
+
+    fn leaf_is_supported(&self, val: u32) -> bool {
+        val <= self.max_eax_value
+    }
+
+    /// Return information about vendor.
+    /// This is typically a ASCII readable string such as
+    /// GenuineIntel for Intel CPUs or AuthenticAMD for AMD CPUs.
+    pub fn get_vendor_info(&self) -> Option<VendorInfo> {
+        if self.leaf_is_supported(EAX_VENDOR_INFO) {
+            let res = cpuid!(EAX_VENDOR_INFO);
+            Some(VendorInfo {
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Query a set of features that are available on this CPU.
+    pub fn get_feature_info(&self) -> Option<FeatureInfo> {
+        if self.leaf_is_supported(EAX_FEATURE_INFO) {
+            let res = cpuid!(EAX_FEATURE_INFO);
+            Some(FeatureInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                edx_ecx: FeatureInfoFlags {
+                    bits: (((res.edx as u64) << 32) | (res.ecx as u64)),
+                },
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Query basic information about caches. This will just return an index
+    /// into a static table of cache descriptions (see `CACHE_INFO_TABLE`).
+    pub fn get_cache_info(&self) -> Option<CacheInfoIter> {
+        if self.leaf_is_supported(EAX_CACHE_INFO) {
+            let res = cpuid!(EAX_CACHE_INFO);
+            Some(CacheInfoIter {
+                current: 1,
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Retrieve serial number of processor.
+    pub fn get_processor_serial(&self) -> Option<ProcessorSerial> {
+        if self.leaf_is_supported(EAX_PROCESSOR_SERIAL) {
+            let res = cpuid!(EAX_PROCESSOR_SERIAL);
+            Some(ProcessorSerial {
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Retrieve more elaborate information about caches (as opposed
+    /// to `get_cache_info`). This will tell us about associativity,
+    /// set size, line size etc. for each level of the cache hierarchy.
+    pub fn get_cache_parameters(&self) -> Option<CacheParametersIter> {
+        if self.leaf_is_supported(EAX_CACHE_PARAMETERS) {
+            Some(CacheParametersIter { current: 0 })
+        } else {
+            None
+        }
+    }
+
+    /// Information about how monitor/mwait works on this CPU.
+    pub fn get_monitor_mwait_info(&self) -> Option<MonitorMwaitInfo> {
+        if self.leaf_is_supported(EAX_MONITOR_MWAIT_INFO) {
+            let res = cpuid!(EAX_MONITOR_MWAIT_INFO);
+            Some(MonitorMwaitInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Query information about thermal and power management features of the CPU.
+    pub fn get_thermal_power_info(&self) -> Option<ThermalPowerInfo> {
+        if self.leaf_is_supported(EAX_THERMAL_POWER_INFO) {
+            let res = cpuid!(EAX_THERMAL_POWER_INFO);
+            Some(ThermalPowerInfo {
+                eax: ThermalPowerFeaturesEax { bits: res.eax },
+                ebx: res.ebx,
+                ecx: ThermalPowerFeaturesEcx { bits: res.ecx },
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Find out about more features supported by this CPU.
+    pub fn get_extended_feature_info(&self) -> Option<ExtendedFeatures> {
+        if self.leaf_is_supported(EAX_STRUCTURED_EXTENDED_FEATURE_INFO) {
+            let res = cpuid!(EAX_STRUCTURED_EXTENDED_FEATURE_INFO);
+            assert!(res.eax == 0);
+            Some(ExtendedFeatures {
+                eax: res.eax,
+                ebx: ExtendedFeaturesEbx { bits: res.ebx },
+                ecx: ExtendedFeaturesEcx { bits: res.ecx },
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Direct cache access info.
+    pub fn get_direct_cache_access_info(&self) -> Option<DirectCacheAccessInfo> {
+        if self.leaf_is_supported(EAX_DIRECT_CACHE_ACCESS_INFO) {
+            let res = cpuid!(EAX_DIRECT_CACHE_ACCESS_INFO);
+            Some(DirectCacheAccessInfo { eax: res.eax })
+        } else {
+            None
+        }
+    }
+
+    /// Info about performance monitoring (how many counters etc.).
+    pub fn get_performance_monitoring_info(&self) -> Option<PerformanceMonitoringInfo> {
+        if self.leaf_is_supported(EAX_PERFORMANCE_MONITOR_INFO) {
+            let res = cpuid!(EAX_PERFORMANCE_MONITOR_INFO);
+            Some(PerformanceMonitoringInfo {
+                eax: res.eax,
+                ebx: PerformanceMonitoringFeaturesEbx { bits: res.ebx },
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Information about topology (how many cores and what kind of cores).
+    pub fn get_extended_topology_info(&self) -> Option<ExtendedTopologyIter> {
+        if self.leaf_is_supported(EAX_EXTENDED_TOPOLOGY_INFO) {
+            Some(ExtendedTopologyIter { level: 0 })
+        } else {
+            None
+        }
+    }
+
+    /// Information for saving/restoring extended register state.
+    pub fn get_extended_state_info(&self) -> Option<ExtendedStateInfo> {
+        if self.leaf_is_supported(EAX_EXTENDED_STATE_INFO) {
+            let res = cpuid!(EAX_EXTENDED_STATE_INFO, 0);
+            let res1 = cpuid!(EAX_EXTENDED_STATE_INFO, 1);
+            Some(ExtendedStateInfo {
+                eax: ExtendedStateInfoXCR0Flags { bits: res.eax },
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+                eax1: res1.eax,
+                ebx1: res1.ebx,
+                ecx1: ExtendedStateInfoXSSFlags { bits: res1.ecx },
+                edx1: res1.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Quality of service informations.
+    pub fn get_rdt_monitoring_info(&self) -> Option<RdtMonitoringInfo> {
+        let res = cpuid!(EAX_RDT_MONITORING, 0);
+
+        if self.leaf_is_supported(EAX_RDT_MONITORING) {
+            Some(RdtMonitoringInfo {
+                ebx: res.ebx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Quality of service enforcement information.
+    pub fn get_rdt_allocation_info(&self) -> Option<RdtAllocationInfo> {
+        let res = cpuid!(EAX_RDT_ALLOCATION, 0);
+
+        if self.leaf_is_supported(EAX_RDT_ALLOCATION) {
+            Some(RdtAllocationInfo { ebx: res.ebx })
+        } else {
+            None
+        }
+    }
+
+    pub fn get_sgx_info(&self) -> Option<SgxInfo> {
+        // Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
+        self.get_extended_feature_info().and_then(|info| {
+            if self.leaf_is_supported(EAX_SGX) && info.has_sgx() {
+                let res = cpuid!(EAX_SGX, 0);
+                let res1 = cpuid!(EAX_SGX, 1);
+                Some(SgxInfo {
+                    eax: res.eax,
+                    ebx: res.ebx,
+                    ecx: res.ecx,
+                    edx: res.edx,
+                    eax1: res1.eax,
+                    ebx1: res1.ebx,
+                    ecx1: res1.ecx,
+                    edx1: res1.edx,
+                })
+            } else {
+                None
+            }
+        })
+    }
+
+    /// Intel Processor Trace Enumeration Information.
+    pub fn get_processor_trace_info(&self) -> Option<ProcessorTraceInfo> {
+        let res = cpuid!(EAX_TRACE_INFO, 0);
+        if self.leaf_is_supported(EAX_TRACE_INFO) {
+            let res1 = if res.eax >= 1 {
+                Some(cpuid!(EAX_TRACE_INFO, 1))
+            } else {
+                None
+            };
+
+            Some(ProcessorTraceInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+                leaf1: res1,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Time Stamp Counter/Core Crystal Clock Information.
+    pub fn get_tsc_info(&self) -> Option<TscInfo> {
+        let res = cpuid!(EAX_TIME_STAMP_COUNTER_INFO, 0);
+        if self.leaf_is_supported(EAX_TIME_STAMP_COUNTER_INFO) {
+            Some(TscInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Processor Frequency Information.
+    pub fn get_processor_frequency_info(&self) -> Option<ProcessorFrequencyInfo> {
+        let res = cpuid!(EAX_FREQUENCY_INFO, 0);
+        if self.leaf_is_supported(EAX_FREQUENCY_INFO) {
+            Some(ProcessorFrequencyInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+            })
+        } else {
+            None
+        }
+    }
+
+    pub fn deterministic_address_translation_info(&self) -> Option<DatIter> {
+        if self.leaf_is_supported(EAX_DETERMINISTIC_ADDRESS_TRANSLATION_INFO) {
+            let res = cpuid!(EAX_DETERMINISTIC_ADDRESS_TRANSLATION_INFO, 0);
+            Some(DatIter {
+                current: 0,
+                count: res.eax,
+            })
+        } else {
+            None
+        }
+    }
+
+    pub fn get_soc_vendor_info(&self) -> Option<SoCVendorInfo> {
+        let res = cpuid!(EAX_SOC_VENDOR_INFO, 0);
+        if self.leaf_is_supported(EAX_SOC_VENDOR_INFO) {
+            Some(SoCVendorInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            })
+        } else {
+            None
+        }
+    }
+
+    pub fn get_hypervisor_info(&self) -> Option<HypervisorInfo> {
+        let res = cpuid!(EAX_HYPERVISOR_INFO);
+        if res.eax > 0 {
+            Some(HypervisorInfo { res: res })
+        } else {
+            None
+        }
+    }
+
+    /// Extended functionality of CPU described here (including more supported features).
+    /// This also contains a more detailed CPU model identifier.
+    pub fn get_extended_function_info(&self) -> Option<ExtendedFunctionInfo> {
+        let res = cpuid!(EAX_EXTENDED_FUNCTION_INFO);
+
+        if res.eax == 0 {
+            return None;
+        }
+
+        let mut ef = ExtendedFunctionInfo {
+            max_eax_value: res.eax - EAX_EXTENDED_FUNCTION_INFO,
+            data: [
+                CpuIdResult {
+                    eax: res.eax,
+                    ebx: res.ebx,
+                    ecx: res.ecx,
+                    edx: res.edx,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+                CpuIdResult {
+                    eax: 0,
+                    ebx: 0,
+                    ecx: 0,
+                    edx: 0,
+                },
+            ],
+        };
+
+        let max_eax_value = min(ef.max_eax_value + 1, ef.data.len() as u32);
+        for i in 1..max_eax_value {
+            ef.data[i as usize] = cpuid!(EAX_EXTENDED_FUNCTION_INFO + i);
+        }
+
+        Some(ef)
+    }
+
+    pub fn get_memory_encryption_info(&self) -> Option<MemoryEncryptionInfo> {
+        let res = cpuid!(EAX_EXTENDED_FUNCTION_INFO);
+        if res.eax < EAX_MEMORY_ENCRYPTION_INFO {
+            return None;
+        }
+
+        let res = cpuid!(EAX_MEMORY_ENCRYPTION_INFO);
+        Some(MemoryEncryptionInfo {
+            eax: MemoryEncryptionInfoEax { bits: res.eax },
+            ebx: res.ebx,
+            ecx: res.ecx,
+            edx: res.edx,
+        })
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct VendorInfo {
+    ebx: u32,
+    edx: u32,
+    ecx: u32,
+}
+
+impl VendorInfo {
+    /// Return vendor identification as human readable string.
+    pub fn as_string<'a>(&'a self) -> &'a str {
+        unsafe {
+            let brand_string_start = self as *const VendorInfo as *const u8;
+            let slice = slice::from_raw_parts(brand_string_start, 3 * 4);
+            let byte_array: &'a [u8] = transmute(slice);
+            str::from_utf8_unchecked(byte_array)
+        }
+    }
+}
+
+/// Used to iterate over cache information contained in cpuid instruction.
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CacheInfoIter {
+    current: u32,
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl Iterator for CacheInfoIter {
+    type Item = CacheInfo;
+
+    /// Iterate over all cache information.
+    fn next(&mut self) -> Option<CacheInfo> {
+        // Every byte of the 4 register values returned by cpuid
+        // can contain information about a cache (except the
+        // very first one).
+        if self.current >= 4 * 4 {
+            return None;
+        }
+        let reg_index = self.current % 4;
+        let byte_index = self.current / 4;
+
+        let reg = match reg_index {
+            0 => self.eax,
+            1 => self.ebx,
+            2 => self.ecx,
+            3 => self.edx,
+            _ => unreachable!(),
+        };
+
+        let byte = as_bytes(&reg)[byte_index as usize];
+        if byte == 0 {
+            self.current += 1;
+            return self.next();
+        }
+
+        for cache_info in CACHE_INFO_TABLE.into_iter() {
+            if cache_info.num == byte {
+                self.current += 1;
+                return Some(*cache_info);
+            }
+        }
+
+        None
+    }
+}
+
+/// What type of cache are we dealing with?
+#[derive(Copy, Clone, Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum CacheInfoType {
+    General,
+    Cache,
+    TLB,
+    STLB,
+    DTLB,
+    Prefetch,
+}
+
+impl Default for CacheInfoType {
+    fn default() -> CacheInfoType {
+        CacheInfoType::General
+    }
+}
+
+/// Describes any kind of cache (TLB, Data and Instruction caches plus prefetchers).
+#[derive(Copy, Clone, Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CacheInfo {
+    /// Number as retrieved from cpuid
+    pub num: u8,
+    /// Cache type
+    pub typ: CacheInfoType,
+}
+
+impl CacheInfo {
+    /// Description of the cache (from Intel Manual)
+    pub fn desc(&self) -> &'static str {
+        match self.num {
+            0x00 => "Null descriptor, this byte contains no information",
+            0x01 => "Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries",
+            0x02 => "Instruction TLB: 4 MByte pages, fully associative, 2 entries",
+            0x03 => "Data TLB: 4 KByte pages, 4-way set associative, 64 entries",
+            0x04 => "Data TLB: 4 MByte pages, 4-way set associative, 8 entries",
+            0x05 => "Data TLB1: 4 MByte pages, 4-way set associative, 32 entries",
+            0x06 => "1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size",
+            0x08 => "1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size",
+            0x09 => "1st-level instruction cache: 32KBytes, 4-way set associative, 64 byte line size",
+            0x0A => "1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size",
+            0x0B => "Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries",
+            0x0C => "1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size",
+            0x0D => "1st-level data cache: 16 KBytes, 4-way set associative, 64 byte line size",
+            0x0E => "1st-level data cache: 24 KBytes, 6-way set associative, 64 byte line size",
+            0x1D => "2nd-level cache: 128 KBytes, 2-way set associative, 64 byte line size",
+            0x21 => "2nd-level cache: 256 KBytes, 8-way set associative, 64 byte line size",
+            0x22 => "3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector",
+            0x23 => "3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x24 => "2nd-level cache: 1 MBytes, 16-way set associative, 64 byte line size",
+            0x25 => "3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x29 => "3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x2C => "1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size",
+            0x30 => "1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size",
+            0x40 => "No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache",
+            0x41 => "2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size",
+            0x42 => "2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size",
+            0x43 => "2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size",
+            0x44 => "2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size",
+            0x45 => "2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size",
+            0x46 => "3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size",
+            0x47 => "3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size",
+            0x48 => "2nd-level cache: 3MByte, 12-way set associative, 64 byte line size",
+            0x49 => "3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H); 2nd-level cache: 4 MByte, 16-way set ssociative, 64 byte line size",
+            0x4A => "3rd-level cache: 6MByte, 12-way set associative, 64 byte line size",
+            0x4B => "3rd-level cache: 8MByte, 16-way set associative, 64 byte line size",
+            0x4C => "3rd-level cache: 12MByte, 12-way set associative, 64 byte line size",
+            0x4D => "3rd-level cache: 16MByte, 16-way set associative, 64 byte line size",
+            0x4E => "2nd-level cache: 6MByte, 24-way set associative, 64 byte line size",
+            0x4F => "Instruction TLB: 4 KByte pages, 32 entries",
+            0x50 => "Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries",
+            0x51 => "Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries",
+            0x52 => "Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries",
+            0x55 => "Instruction TLB: 2-MByte or 4-MByte pages, fully associative, 7 entries",
+            0x56 => "Data TLB0: 4 MByte pages, 4-way set associative, 16 entries",
+            0x57 => "Data TLB0: 4 KByte pages, 4-way associative, 16 entries",
+            0x59 => "Data TLB0: 4 KByte pages, fully associative, 16 entries",
+            0x5A => "Data TLB0: 2-MByte or 4 MByte pages, 4-way set associative, 32 entries",
+            0x5B => "Data TLB: 4 KByte and 4 MByte pages, 64 entries",
+            0x5C => "Data TLB: 4 KByte and 4 MByte pages,128 entries",
+            0x5D => "Data TLB: 4 KByte and 4 MByte pages,256 entries",
+            0x60 => "1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size",
+            0x61 => "Instruction TLB: 4 KByte pages, fully associative, 48 entries",
+            0x63 => "Data TLB: 2 MByte or 4 MByte pages, 4-way set associative, 32 entries and a separate array with 1 GByte pages, 4-way set associative, 4 entries",
+            0x64 => "Data TLB: 4 KByte pages, 4-way set associative, 512 entries",
+            0x66 => "1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size",
+            0x67 => "1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size",
+            0x68 => "1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size",
+            0x6A => "uTLB: 4 KByte pages, 8-way set associative, 64 entries",
+            0x6B => "DTLB: 4 KByte pages, 8-way set associative, 256 entries",
+            0x6C => "DTLB: 2M/4M pages, 8-way set associative, 128 entries",
+            0x6D => "DTLB: 1 GByte pages, fully associative, 16 entries",
+            0x70 => "Trace cache: 12 K-μop, 8-way set associative",
+            0x71 => "Trace cache: 16 K-μop, 8-way set associative",
+            0x72 => "Trace cache: 32 K-μop, 8-way set associative",
+            0x76 => "Instruction TLB: 2M/4M pages, fully associative, 8 entries",
+            0x78 => "2nd-level cache: 1 MByte, 4-way set associative, 64byte line size",
+            0x79 => "2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x7A => "2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x7B => "2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x7C => "2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector",
+            0x7D => "2nd-level cache: 2 MByte, 8-way set associative, 64byte line size",
+            0x7F => "2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size",
+            0x80 => "2nd-level cache: 512 KByte, 8-way set associative, 64-byte line size",
+            0x82 => "2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size",
+            0x83 => "2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size",
+            0x84 => "2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size",
+            0x85 => "2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size",
+            0x86 => "2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size",
+            0x87 => "2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size",
+            0xA0 => "DTLB: 4k pages, fully associative, 32 entries",
+            0xB0 => "Instruction TLB: 4 KByte pages, 4-way set associative, 128 entries",
+            0xB1 => "Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries",
+            0xB2 => "Instruction TLB: 4KByte pages, 4-way set associative, 64 entries",
+            0xB3 => "Data TLB: 4 KByte pages, 4-way set associative, 128 entries",
+            0xB4 => "Data TLB1: 4 KByte pages, 4-way associative, 256 entries",
+            0xB5 => "Instruction TLB: 4KByte pages, 8-way set associative, 64 entries",
+            0xB6 => "Instruction TLB: 4KByte pages, 8-way set associative, 128 entries",
+            0xBA => "Data TLB1: 4 KByte pages, 4-way associative, 64 entries",
+            0xC0 => "Data TLB: 4 KByte and 4 MByte pages, 4-way associative, 8 entries",
+            0xC1 => "Shared 2nd-Level TLB: 4 KByte/2MByte pages, 8-way associative, 1024 entries",
+            0xC2 => "DTLB: 2 MByte/$MByte pages, 4-way associative, 16 entries",
+            0xC3 => "Shared 2nd-Level TLB: 4 KByte /2 MByte pages, 6-way associative, 1536 entries. Also 1GBbyte pages, 4-way, 16 entries.",
+            0xC4 => "DTLB: 2M/4M Byte pages, 4-way associative, 32 entries",
+            0xCA => "Shared 2nd-Level TLB: 4 KByte pages, 4-way associative, 512 entries",
+            0xD0 => "3rd-level cache: 512 KByte, 4-way set associative, 64 byte line size",
+            0xD1 => "3rd-level cache: 1 MByte, 4-way set associative, 64 byte line size",
+            0xD2 => "3rd-level cache: 2 MByte, 4-way set associative, 64 byte line size",
+            0xD6 => "3rd-level cache: 1 MByte, 8-way set associative, 64 byte line size",
+            0xD7 => "3rd-level cache: 2 MByte, 8-way set associative, 64 byte line size",
+            0xD8 => "3rd-level cache: 4 MByte, 8-way set associative, 64 byte line size",
+            0xDC => "3rd-level cache: 1.5 MByte, 12-way set associative, 64 byte line size",
+            0xDD => "3rd-level cache: 3 MByte, 12-way set associative, 64 byte line size",
+            0xDE => "3rd-level cache: 6 MByte, 12-way set associative, 64 byte line size",
+            0xE2 => "3rd-level cache: 2 MByte, 16-way set associative, 64 byte line size",
+            0xE3 => "3rd-level cache: 4 MByte, 16-way set associative, 64 byte line size",
+            0xE4 => "3rd-level cache: 8 MByte, 16-way set associative, 64 byte line size",
+            0xEA => "3rd-level cache: 12MByte, 24-way set associative, 64 byte line size",
+            0xEB => "3rd-level cache: 18MByte, 24-way set associative, 64 byte line size",
+            0xEC => "3rd-level cache: 24MByte, 24-way set associative, 64 byte line size",
+            0xF0 => "64-Byte prefetching",
+            0xF1 => "128-Byte prefetching",
+            0xFE => "CPUID leaf 2 does not report TLB descriptor information; use CPUID leaf 18H to query TLB and other address translation parameters.",
+            0xFF => "CPUID leaf 2 does not report cache descriptor information, use CPUID leaf 4 to query cache parameters",
+            _ => "Unknown cache type!"
+        }
+    }
+}
+
+impl fmt::Display for CacheInfo {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        let typ = match self.typ {
+            CacheInfoType::General => "N/A",
+            CacheInfoType::Cache => "Cache",
+            CacheInfoType::TLB => "TLB",
+            CacheInfoType::STLB => "STLB",
+            CacheInfoType::DTLB => "DTLB",
+            CacheInfoType::Prefetch => "Prefetcher",
+        };
+
+        write!(f, "{:x}:\t {}: {}", self.num, typ, self.desc())
+    }
+}
+
+/// This table is taken from Intel manual (Section CPUID instruction).
+pub const CACHE_INFO_TABLE: [CacheInfo; 108] = [
+    CacheInfo {
+        num: 0x00,
+        typ: CacheInfoType::General,
+    },
+    CacheInfo {
+        num: 0x01,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x02,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x03,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x04,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x05,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x06,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x08,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x09,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x0A,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x0B,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x0C,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x0D,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x0E,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x21,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x22,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x23,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x24,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x25,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x29,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x2C,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x30,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x40,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x41,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x42,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x43,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x44,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x45,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x46,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x47,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x48,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x49,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4A,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4B,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4C,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4D,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4E,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x4F,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x50,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x51,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x52,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x55,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x56,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x57,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x59,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x5A,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x5B,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x5C,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x5D,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x60,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x61,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x63,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x66,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x67,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x68,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x6A,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x6B,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x6C,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x6D,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x70,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x71,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x72,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x76,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0x78,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x79,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x7A,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x7B,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x7C,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x7D,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x7F,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x80,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x82,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x83,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x84,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x85,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x86,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0x87,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xB0,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB1,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB2,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB3,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB4,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB5,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xB6,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xBA,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xC0,
+        typ: CacheInfoType::TLB,
+    },
+    CacheInfo {
+        num: 0xC1,
+        typ: CacheInfoType::STLB,
+    },
+    CacheInfo {
+        num: 0xC2,
+        typ: CacheInfoType::DTLB,
+    },
+    CacheInfo {
+        num: 0xCA,
+        typ: CacheInfoType::STLB,
+    },
+    CacheInfo {
+        num: 0xD0,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xD1,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xD2,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xD6,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xD7,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xD8,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xDC,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xDD,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xDE,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xE2,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xE3,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xE4,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xEA,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xEB,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xEC,
+        typ: CacheInfoType::Cache,
+    },
+    CacheInfo {
+        num: 0xF0,
+        typ: CacheInfoType::Prefetch,
+    },
+    CacheInfo {
+        num: 0xF1,
+        typ: CacheInfoType::Prefetch,
+    },
+    CacheInfo {
+        num: 0xFE,
+        typ: CacheInfoType::General,
+    },
+    CacheInfo {
+        num: 0xFF,
+        typ: CacheInfoType::General,
+    },
+];
+
+impl fmt::Display for VendorInfo {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(f, "{}", self.as_string())
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ProcessorSerial {
+    ecx: u32,
+    edx: u32,
+}
+
+impl ProcessorSerial {
+    /// Bits 00-31 of 96 bit processor serial number.
+    /// (Available in Pentium III processor only; otherwise, the value in this register is reserved.)
+    pub fn serial_lower(&self) -> u32 {
+        self.ecx
+    }
+
+    /// Bits 32-63 of 96 bit processor serial number.
+    /// (Available in Pentium III processor only; otherwise, the value in this register is reserved.)
+    pub fn serial_middle(&self) -> u32 {
+        self.edx
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct FeatureInfo {
+    eax: u32,
+    ebx: u32,
+    edx_ecx: FeatureInfoFlags,
+}
+
+impl FeatureInfo {
+    /// Version Information: Extended Family
+    pub fn extended_family_id(&self) -> u8 {
+        get_bits(self.eax, 20, 27) as u8
+    }
+
+    /// Version Information: Extended Model
+    pub fn extended_model_id(&self) -> u8 {
+        get_bits(self.eax, 16, 19) as u8
+    }
+
+    /// Version Information: Family
+    pub fn family_id(&self) -> u8 {
+        get_bits(self.eax, 8, 11) as u8
+    }
+
+    /// Version Information: Model
+    pub fn model_id(&self) -> u8 {
+        get_bits(self.eax, 4, 7) as u8
+    }
+
+    /// Version Information: Stepping ID
+    pub fn stepping_id(&self) -> u8 {
+        get_bits(self.eax, 0, 3) as u8
+    }
+
+    /// Brand Index
+    pub fn brand_index(&self) -> u8 {
+        get_bits(self.ebx, 0, 7) as u8
+    }
+
+    /// CLFLUSH line size (Value ∗ 8 = cache line size in bytes)
+    pub fn cflush_cache_line_size(&self) -> u8 {
+        get_bits(self.ebx, 8, 15) as u8
+    }
+
+    /// Initial APIC ID
+    pub fn initial_local_apic_id(&self) -> u8 {
+        get_bits(self.ebx, 24, 31) as u8
+    }
+
+    /// Maximum number of addressable IDs for logical processors in this physical package.
+    pub fn max_logical_processor_ids(&self) -> u8 {
+        get_bits(self.ebx, 16, 23) as u8
+    }
+
+    check_flag!(
+        doc = "Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor \
+               supports this technology.",
+        has_sse3,
+        edx_ecx,
+        FeatureInfoFlags::SSE3
+    );
+
+    check_flag!(
+        doc = "PCLMULQDQ. A value of 1 indicates the processor supports the PCLMULQDQ \
+               instruction",
+        has_pclmulqdq,
+        edx_ecx,
+        FeatureInfoFlags::PCLMULQDQ
+    );
+
+    check_flag!(
+        doc = "64-bit DS Area. A value of 1 indicates the processor supports DS area \
+               using 64-bit layout",
+        has_ds_area,
+        edx_ecx,
+        FeatureInfoFlags::DTES64
+    );
+
+    check_flag!(
+        doc = "MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.",
+        has_monitor_mwait,
+        edx_ecx,
+        FeatureInfoFlags::MONITOR
+    );
+
+    check_flag!(
+        doc = "CPL Qualified Debug Store. A value of 1 indicates the processor supports \
+               the extensions to the  Debug Store feature to allow for branch message \
+               storage qualified by CPL.",
+        has_cpl,
+        edx_ecx,
+        FeatureInfoFlags::DSCPL
+    );
+
+    check_flag!(
+        doc = "Virtual Machine Extensions. A value of 1 indicates that the processor \
+               supports this technology.",
+        has_vmx,
+        edx_ecx,
+        FeatureInfoFlags::VMX
+    );
+
+    check_flag!(
+        doc = "Safer Mode Extensions. A value of 1 indicates that the processor supports \
+               this technology. See Chapter 5, Safer Mode Extensions Reference.",
+        has_smx,
+        edx_ecx,
+        FeatureInfoFlags::SMX
+    );
+
+    check_flag!(
+        doc = "Enhanced Intel SpeedStep® technology. A value of 1 indicates that the \
+               processor supports this technology.",
+        has_eist,
+        edx_ecx,
+        FeatureInfoFlags::EIST
+    );
+
+    check_flag!(
+        doc = "Thermal Monitor 2. A value of 1 indicates whether the processor supports \
+               this technology.",
+        has_tm2,
+        edx_ecx,
+        FeatureInfoFlags::TM2
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates the presence of the Supplemental Streaming SIMD \
+               Extensions 3 (SSSE3). A value of 0 indicates the instruction extensions \
+               are not present in the processor",
+        has_ssse3,
+        edx_ecx,
+        FeatureInfoFlags::SSSE3
+    );
+
+    check_flag!(
+        doc = "L1 Context ID. A value of 1 indicates the L1 data cache mode can be set \
+               to either adaptive mode or shared mode. A value of 0 indicates this \
+               feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit \
+               24 (L1 Data Cache Context Mode) for details.",
+        has_cnxtid,
+        edx_ecx,
+        FeatureInfoFlags::CNXTID
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates the processor supports FMA extensions using YMM \
+               state.",
+        has_fma,
+        edx_ecx,
+        FeatureInfoFlags::FMA
+    );
+
+    check_flag!(
+        doc = "CMPXCHG16B Available. A value of 1 indicates that the feature is \
+               available. See the CMPXCHG8B/CMPXCHG16B Compare and Exchange Bytes \
+               section. 14",
+        has_cmpxchg16b,
+        edx_ecx,
+        FeatureInfoFlags::CMPXCHG16B
+    );
+
+    check_flag!(
+        doc = "Perfmon and Debug Capability: A value of 1 indicates the processor \
+               supports the performance   and debug feature indication MSR \
+               IA32_PERF_CAPABILITIES.",
+        has_pdcm,
+        edx_ecx,
+        FeatureInfoFlags::PDCM
+    );
+
+    check_flag!(
+        doc = "Process-context identifiers. A value of 1 indicates that the processor \
+               supports PCIDs and the software may set CR4.PCIDE to 1.",
+        has_pcid,
+        edx_ecx,
+        FeatureInfoFlags::PCID
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates the processor supports the ability to prefetch \
+               data from a memory mapped device.",
+        has_dca,
+        edx_ecx,
+        FeatureInfoFlags::DCA
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports SSE4.1.",
+        has_sse41,
+        edx_ecx,
+        FeatureInfoFlags::SSE41
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports SSE4.2.",
+        has_sse42,
+        edx_ecx,
+        FeatureInfoFlags::SSE42
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports x2APIC feature.",
+        has_x2apic,
+        edx_ecx,
+        FeatureInfoFlags::X2APIC
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports MOVBE instruction.",
+        has_movbe,
+        edx_ecx,
+        FeatureInfoFlags::MOVBE
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports the POPCNT instruction.",
+        has_popcnt,
+        edx_ecx,
+        FeatureInfoFlags::POPCNT
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processors local APIC timer supports \
+               one-shot operation using a TSC deadline value.",
+        has_tsc_deadline,
+        edx_ecx,
+        FeatureInfoFlags::TSC_DEADLINE
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports the AESNI instruction \
+               extensions.",
+        has_aesni,
+        edx_ecx,
+        FeatureInfoFlags::AESNI
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the processor supports the XSAVE/XRSTOR \
+               processor extended states feature, the XSETBV/XGETBV instructions, and \
+               XCR0.",
+        has_xsave,
+        edx_ecx,
+        FeatureInfoFlags::XSAVE
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that the OS has enabled XSETBV/XGETBV instructions \
+               to access XCR0, and support for processor extended state management using \
+               XSAVE/XRSTOR.",
+        has_oxsave,
+        edx_ecx,
+        FeatureInfoFlags::OSXSAVE
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates the processor supports the AVX instruction \
+               extensions.",
+        has_avx,
+        edx_ecx,
+        FeatureInfoFlags::AVX
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that processor supports 16-bit floating-point \
+               conversion instructions.",
+        has_f16c,
+        edx_ecx,
+        FeatureInfoFlags::F16C
+    );
+
+    check_flag!(
+        doc = "A value of 1 indicates that processor supports RDRAND instruction.",
+        has_rdrand,
+        edx_ecx,
+        FeatureInfoFlags::RDRAND
+    );
+
+    check_flag!(
+        doc = "Floating Point Unit On-Chip. The processor contains an x87 FPU.",
+        has_fpu,
+        edx_ecx,
+        FeatureInfoFlags::FPU
+    );
+
+    check_flag!(
+        doc = "Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including \
+               CR4.VME for controlling the feature, CR4.PVI for protected mode virtual \
+               interrupts, software interrupt indirection, expansion of the TSS with the \
+               software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.",
+        has_vme,
+        edx_ecx,
+        FeatureInfoFlags::VME
+    );
+
+    check_flag!(
+        doc = "Debugging Extensions. Support for I/O breakpoints, including CR4.DE for \
+               controlling the feature, and optional trapping of accesses to DR4 and DR5.",
+        has_de,
+        edx_ecx,
+        FeatureInfoFlags::DE
+    );
+
+    check_flag!(
+        doc = "Page Size Extension. Large pages of size 4 MByte are supported, including \
+               CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page \
+               Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.",
+        has_pse,
+        edx_ecx,
+        FeatureInfoFlags::PSE
+    );
+
+    check_flag!(
+        doc = "Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD \
+               for controlling privilege.",
+        has_tsc,
+        edx_ecx,
+        FeatureInfoFlags::TSC
+    );
+
+    check_flag!(
+        doc = "Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and \
+               WRMSR instructions are supported. Some of the MSRs are implementation \
+               dependent.",
+        has_msr,
+        edx_ecx,
+        FeatureInfoFlags::MSR
+    );
+
+    check_flag!(
+        doc = "Physical Address Extension. Physical addresses greater than 32 bits are \
+               supported: extended page table entry formats, an extra level in the page \
+               translation tables is defined, 2-MByte pages are supported instead of 4 \
+               Mbyte pages if PAE bit is 1.",
+        has_pae,
+        edx_ecx,
+        FeatureInfoFlags::PAE
+    );
+
+    check_flag!(
+        doc = "Machine Check Exception. Exception 18 is defined for Machine Checks, \
+               including CR4.MCE for controlling the feature. This feature does not \
+               define the model-specific implementations of machine-check error logging, \
+               reporting, and processor shutdowns. Machine Check exception handlers may \
+               have to depend on processor version to do model specific processing of \
+               the exception, or test for the presence of the Machine Check feature.",
+        has_mce,
+        edx_ecx,
+        FeatureInfoFlags::MCE
+    );
+
+    check_flag!(
+        doc = "CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) \
+               instruction is supported (implicitly locked and atomic).",
+        has_cmpxchg8b,
+        edx_ecx,
+        FeatureInfoFlags::CX8
+    );
+
+    check_flag!(
+        doc = "APIC On-Chip. The processor contains an Advanced Programmable Interrupt \
+               Controller (APIC), responding to memory mapped commands in the physical \
+               address range FFFE0000H to FFFE0FFFH (by default - some processors permit \
+               the APIC to be relocated).",
+        has_apic,
+        edx_ecx,
+        FeatureInfoFlags::APIC
+    );
+
+    check_flag!(
+        doc = "SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and \
+               associated MSRs are supported.",
+        has_sysenter_sysexit,
+        edx_ecx,
+        FeatureInfoFlags::SEP
+    );
+
+    check_flag!(
+        doc = "Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR \
+               contains feature bits that describe what memory types are supported, how \
+               many variable MTRRs are supported, and whether fixed MTRRs are supported.",
+        has_mtrr,
+        edx_ecx,
+        FeatureInfoFlags::MTRR
+    );
+
+    check_flag!(
+        doc = "Page Global Bit. The global bit is supported in paging-structure entries \
+               that map a page, indicating TLB entries that are common to different \
+               processes and need not be flushed. The CR4.PGE bit controls this feature.",
+        has_pge,
+        edx_ecx,
+        FeatureInfoFlags::PGE
+    );
+
+    check_flag!(
+        doc = "Machine Check Architecture. A value of 1 indicates the Machine Check \
+               Architecture of reporting machine errors is supported. The MCG_CAP MSR \
+               contains feature bits describing how many banks of error reporting MSRs \
+               are supported.",
+        has_mca,
+        edx_ecx,
+        FeatureInfoFlags::MCA
+    );
+
+    check_flag!(
+        doc = "Conditional Move Instructions. The conditional move instruction CMOV is \
+               supported. In addition, if x87 FPU is present as indicated by the \
+               CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported",
+        has_cmov,
+        edx_ecx,
+        FeatureInfoFlags::CMOV
+    );
+
+    check_flag!(
+        doc = "Page Attribute Table. Page Attribute Table is supported. This feature \
+               augments the Memory Type Range Registers (MTRRs), allowing an operating \
+               system to specify attributes of memory accessed through a linear address \
+               on a 4KB granularity.",
+        has_pat,
+        edx_ecx,
+        FeatureInfoFlags::PAT
+    );
+
+    check_flag!(
+        doc = "36-Bit Page Size Extension. 4-MByte pages addressing physical memory \
+               beyond 4 GBytes are supported with 32-bit paging. This feature indicates \
+               that upper bits of the physical address of a 4-MByte page are encoded in \
+               bits 20:13 of the page-directory entry. Such physical addresses are \
+               limited by MAXPHYADDR and may be up to 40 bits in size.",
+        has_pse36,
+        edx_ecx,
+        FeatureInfoFlags::PSE36
+    );
+
+    check_flag!(
+        doc = "Processor Serial Number. The processor supports the 96-bit processor \
+               identification number feature and the feature is enabled.",
+        has_psn,
+        edx_ecx,
+        FeatureInfoFlags::PSN
+    );
+
+    check_flag!(
+        doc = "CLFLUSH Instruction. CLFLUSH Instruction is supported.",
+        has_clflush,
+        edx_ecx,
+        FeatureInfoFlags::CLFSH
+    );
+
+    check_flag!(
+        doc = "Debug Store. The processor supports the ability to write debug \
+               information into a memory resident buffer. This feature is used by the \
+               branch trace store (BTS) and processor event-based sampling (PEBS) \
+               facilities (see Chapter 23, Introduction to Virtual-Machine Extensions, \
+               in the Intel® 64 and IA-32 Architectures Software Developers Manual, \
+               Volume 3C).",
+        has_ds,
+        edx_ecx,
+        FeatureInfoFlags::DS
+    );
+
+    check_flag!(
+        doc = "Thermal Monitor and Software Controlled Clock Facilities. The processor \
+               implements internal MSRs that allow processor temperature to be monitored \
+               and processor performance to be modulated in predefined duty cycles under \
+               software control.",
+        has_acpi,
+        edx_ecx,
+        FeatureInfoFlags::ACPI
+    );
+
+    check_flag!(
+        doc = "Intel MMX Technology. The processor supports the Intel MMX technology.",
+        has_mmx,
+        edx_ecx,
+        FeatureInfoFlags::MMX
+    );
+
+    check_flag!(
+        doc = "FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are \
+               supported for fast save and restore of the floating point context. \
+               Presence of this bit also indicates that CR4.OSFXSR is available for an \
+               operating system to indicate that it supports the FXSAVE and FXRSTOR \
+               instructions.",
+        has_fxsave_fxstor,
+        edx_ecx,
+        FeatureInfoFlags::FXSR
+    );
+
+    check_flag!(
+        doc = "SSE. The processor supports the SSE extensions.",
+        has_sse,
+        edx_ecx,
+        FeatureInfoFlags::SSE
+    );
+
+    check_flag!(
+        doc = "SSE2. The processor supports the SSE2 extensions.",
+        has_sse2,
+        edx_ecx,
+        FeatureInfoFlags::SSE2
+    );
+
+    check_flag!(
+        doc = "Self Snoop. The processor supports the management of conflicting memory \
+               types by performing a snoop of its own cache structure for transactions \
+               issued to the bus.",
+        has_ss,
+        edx_ecx,
+        FeatureInfoFlags::SS
+    );
+
+    check_flag!(
+        doc = "Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates \
+               there is only a single logical processor in the package and software \
+               should assume only a single APIC ID is reserved.  A value of 1 for HTT \
+               indicates the value in CPUID.1.EBX\\[23:16\\] (the Maximum number of \
+               addressable IDs for logical processors in this package) is valid for the \
+               package.",
+        has_htt,
+        edx_ecx,
+        FeatureInfoFlags::HTT
+    );
+
+    check_flag!(
+        doc = "Thermal Monitor. The processor implements the thermal monitor automatic \
+               thermal control circuitry (TCC).",
+        has_tm,
+        edx_ecx,
+        FeatureInfoFlags::TM
+    );
+
+    check_flag!(
+        doc = "Pending Break Enable. The processor supports the use of the FERR#/PBE# \
+               pin when the processor is in the stop-clock state (STPCLK# is asserted) \
+               to signal the processor that an interrupt is pending and that the \
+               processor should return to normal operation to handle the interrupt. Bit \
+               10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.",
+        has_pbe,
+        edx_ecx,
+        FeatureInfoFlags::PBE
+    );
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct FeatureInfoFlags: u64 {
+
+        // ECX flags
+
+        /// Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.
+        const SSE3 = 1 << 0;
+        /// PCLMULQDQ. A value of 1 indicates the processor supports the PCLMULQDQ instruction
+        const PCLMULQDQ = 1 << 1;
+        /// 64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout
+        const DTES64 = 1 << 2;
+        /// MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.
+        const MONITOR = 1 << 3;
+        /// CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the  Debug Store feature to allow for branch message storage qualified by CPL.
+        const DSCPL = 1 << 4;
+        /// Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.
+        const VMX = 1 << 5;
+        /// Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See Chapter 5, Safer Mode Extensions Reference.
+        const SMX = 1 << 6;
+        /// Enhanced Intel SpeedStep® technology. A value of 1 indicates that the processor supports this technology.
+        const EIST = 1 << 7;
+        /// Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.
+        const TM2 = 1 << 8;
+        /// A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0 indicates the instruction extensions are not present in the processor
+        const SSSE3 = 1 << 9;
+        /// L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.
+        const CNXTID = 1 << 10;
+        /// A value of 1 indicates the processor supports FMA extensions using YMM state.
+        const FMA = 1 << 12;
+        /// CMPXCHG16B Available. A value of 1 indicates that the feature is available. See the CMPXCHG8B/CMPXCHG16B Compare and Exchange Bytes section. 14
+        const CMPXCHG16B = 1 << 13;
+        /// Perfmon and Debug Capability: A value of 1 indicates the processor supports the performance   and debug feature indication MSR IA32_PERF_CAPABILITIES.
+        const PDCM = 1 << 15;
+        /// Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and the software may set CR4.PCIDE to 1.
+        const PCID = 1 << 17;
+        /// A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device.
+        const DCA = 1 << 18;
+        /// A value of 1 indicates that the processor supports SSE4.1.
+        const SSE41 = 1 << 19;
+        /// A value of 1 indicates that the processor supports SSE4.2.
+        const SSE42 = 1 << 20;
+        /// A value of 1 indicates that the processor supports x2APIC feature.
+        const X2APIC = 1 << 21;
+        /// A value of 1 indicates that the processor supports MOVBE instruction.
+        const MOVBE = 1 << 22;
+        /// A value of 1 indicates that the processor supports the POPCNT instruction.
+        const POPCNT = 1 << 23;
+        /// A value of 1 indicates that the processors local APIC timer supports one-shot operation using a TSC deadline value.
+        const TSC_DEADLINE = 1 << 24;
+        /// A value of 1 indicates that the processor supports the AESNI instruction extensions.
+        const AESNI = 1 << 25;
+        /// A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the XSETBV/XGETBV instructions, and XCR0.
+        const XSAVE = 1 << 26;
+        /// A value of 1 indicates that the OS has enabled XSETBV/XGETBV instructions to access XCR0, and support for processor extended state management using XSAVE/XRSTOR.
+        const OSXSAVE = 1 << 27;
+        /// A value of 1 indicates the processor supports the AVX instruction extensions.
+        const AVX = 1 << 28;
+        /// A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
+        const F16C = 1 << 29;
+        /// A value of 1 indicates that processor supports RDRAND instruction.
+        const RDRAND = 1 << 30;
+
+
+        // EDX flags
+
+        /// Floating Point Unit On-Chip. The processor contains an x87 FPU.
+        const FPU = 1 << (32 + 0);
+        /// Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.
+        const VME = 1 << (32 + 1);
+        /// Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.
+        const DE = 1 << (32 + 2);
+        /// Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
+        const PSE = 1 << (32 + 3);
+        /// Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
+        const TSC = 1 << (32 + 4);
+        /// Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
+        const MSR = 1 << (32 + 5);
+        /// Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
+        const PAE = 1 << (32 + 6);
+        /// Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.
+        const MCE = 1 << (32 + 7);
+        /// CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
+        const CX8 = 1 << (32 + 8);
+        /// APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).
+        const APIC = 1 << (32 + 9);
+        /// SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported.
+        const SEP = 1 << (32 + 11);
+        /// Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.
+        const MTRR = 1 << (32 + 12);
+        /// Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.
+        const PGE = 1 << (32 + 13);
+        /// Machine Check Architecture. The Machine Check exArchitecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.
+        const MCA = 1 << (32 + 14);
+        /// Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
+        const CMOV = 1 << (32 + 15);
+        /// Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
+        const PAT = 1 << (32 + 16);
+        /// 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
+        const PSE36 = 1 << (32 + 17);
+        /// Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.
+        const PSN = 1 << (32 + 18);
+        /// CLFLUSH Instruction. CLFLUSH Instruction is supported.
+        const CLFSH = 1 << (32 + 19);
+        /// Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 23, Introduction to Virtual-Machine Extensions, in the Intel® 64 and IA-32 Architectures Software Developers Manual, Volume 3C).
+        const DS = 1 << (32 + 21);
+        /// Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.
+        const ACPI = 1 << (32 + 22);
+        /// Intel MMX Technology. The processor supports the Intel MMX technology.
+        const MMX = 1 << (32 + 23);
+        /// FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.
+        const FXSR = 1 << (32 + 24);
+        /// SSE. The processor supports the SSE extensions.
+        const SSE = 1 << (32 + 25);
+        /// SSE2. The processor supports the SSE2 extensions.
+        const SSE2 = 1 << (32 + 26);
+        /// Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.
+        const SS = 1 << (32 + 27);
+        /// Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in the package and software should assume only a single APIC ID is reserved.  A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is valid for the package.
+        const HTT = 1 << (32 + 28);
+        /// Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).
+        const TM = 1 << (32 + 29);
+        /// Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
+        const PBE = 1 << (32 + 31);
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CacheParametersIter {
+    current: u32,
+}
+
+impl Iterator for CacheParametersIter {
+    type Item = CacheParameter;
+
+    /// Iterate over all caches for this CPU.
+    /// Note: cpuid is called every-time we this function to get information
+    /// about next cache.
+    fn next(&mut self) -> Option<CacheParameter> {
+        let res = cpuid!(EAX_CACHE_PARAMETERS, self.current);
+        let cp = CacheParameter {
+            eax: res.eax,
+            ebx: res.ebx,
+            ecx: res.ecx,
+            edx: res.edx,
+        };
+
+        match cp.cache_type() {
+            CacheType::Null => None,
+            CacheType::Reserved => None,
+            _ => {
+                self.current += 1;
+                Some(cp)
+            }
+        }
+    }
+}
+
+#[derive(Copy, Clone, Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct CacheParameter {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+#[derive(PartialEq, Eq, Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum CacheType {
+    /// Null - No more caches
+    Null = 0,
+    /// Data cache
+    Data,
+    /// Instruction cache
+    Instruction,
+    /// Data and Instruction cache
+    Unified,
+    /// 4-31 = Reserved
+    Reserved,
+}
+
+impl Default for CacheType {
+    fn default() -> CacheType {
+        CacheType::Null
+    }
+}
+
+impl CacheParameter {
+    /// Cache Type
+    pub fn cache_type(&self) -> CacheType {
+        let typ = get_bits(self.eax, 0, 4) as u8;
+        match typ {
+            0 => CacheType::Null,
+            1 => CacheType::Data,
+            2 => CacheType::Instruction,
+            3 => CacheType::Unified,
+            _ => CacheType::Reserved,
+        }
+    }
+
+    /// Cache Level (starts at 1)
+    pub fn level(&self) -> u8 {
+        get_bits(self.eax, 5, 7) as u8
+    }
+
+    /// Self Initializing cache level (does not need SW initialization).
+    pub fn is_self_initializing(&self) -> bool {
+        get_bits(self.eax, 8, 8) == 1
+    }
+
+    /// Fully Associative cache
+    pub fn is_fully_associative(&self) -> bool {
+        get_bits(self.eax, 9, 9) == 1
+    }
+
+    /// Maximum number of addressable IDs for logical processors sharing this cache
+    pub fn max_cores_for_cache(&self) -> usize {
+        (get_bits(self.eax, 14, 25) + 1) as usize
+    }
+
+    /// Maximum number of addressable IDs for processor cores in the physical package
+    pub fn max_cores_for_package(&self) -> usize {
+        (get_bits(self.eax, 26, 31) + 1) as usize
+    }
+
+    /// System Coherency Line Size (Bits 11-00)
+    pub fn coherency_line_size(&self) -> usize {
+        (get_bits(self.ebx, 0, 11) + 1) as usize
+    }
+
+    /// Physical Line partitions (Bits 21-12)
+    pub fn physical_line_partitions(&self) -> usize {
+        (get_bits(self.ebx, 12, 21) + 1) as usize
+    }
+
+    /// Ways of associativity (Bits 31-22)
+    pub fn associativity(&self) -> usize {
+        (get_bits(self.ebx, 22, 31) + 1) as usize
+    }
+
+    /// Number of Sets (Bits 31-00)
+    pub fn sets(&self) -> usize {
+        (self.ecx + 1) as usize
+    }
+
+    /// Write-Back Invalidate/Invalidate (Bit 0)
+    /// False: WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
+    /// True: WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
+    pub fn is_write_back_invalidate(&self) -> bool {
+        get_bits(self.edx, 0, 0) == 1
+    }
+
+    /// Cache Inclusiveness (Bit 1)
+    /// False: Cache is not inclusive of lower cache levels.
+    /// True: Cache is inclusive of lower cache levels.
+    pub fn is_inclusive(&self) -> bool {
+        get_bits(self.edx, 1, 1) == 1
+    }
+
+    /// Complex Cache Indexing (Bit 2)
+    /// False: Direct mapped cache.
+    /// True: A complex function is used to index the cache, potentially using all address bits.
+    pub fn has_complex_indexing(&self) -> bool {
+        get_bits(self.edx, 2, 2) == 1
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct MonitorMwaitInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl MonitorMwaitInfo {
+    /// Smallest monitor-line size in bytes (default is processor's monitor granularity)
+    pub fn smallest_monitor_line(&self) -> u16 {
+        get_bits(self.eax, 0, 15) as u16
+    }
+
+    /// Largest monitor-line size in bytes (default is processor's monitor granularity
+    pub fn largest_monitor_line(&self) -> u16 {
+        get_bits(self.ebx, 0, 15) as u16
+    }
+
+    ///  Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported
+    pub fn extensions_supported(&self) -> bool {
+        get_bits(self.ecx, 0, 0) == 1
+    }
+
+    ///  Supports treating interrupts as break-event for MWAIT, even when interrupts disabled
+    pub fn interrupts_as_break_event(&self) -> bool {
+        get_bits(self.ecx, 1, 1) == 1
+    }
+
+    /// Number of C0 sub C-states supported using MWAIT (Bits 03 - 00)
+    pub fn supported_c0_states(&self) -> u16 {
+        get_bits(self.edx, 0, 3) as u16
+    }
+
+    /// Number of C1 sub C-states supported using MWAIT (Bits 07 - 04)
+    pub fn supported_c1_states(&self) -> u16 {
+        get_bits(self.edx, 4, 7) as u16
+    }
+
+    /// Number of C2 sub C-states supported using MWAIT (Bits 11 - 08)
+    pub fn supported_c2_states(&self) -> u16 {
+        get_bits(self.edx, 8, 11) as u16
+    }
+
+    /// Number of C3 sub C-states supported using MWAIT (Bits 15 - 12)
+    pub fn supported_c3_states(&self) -> u16 {
+        get_bits(self.edx, 12, 15) as u16
+    }
+
+    /// Number of C4 sub C-states supported using MWAIT (Bits 19 - 16)
+    pub fn supported_c4_states(&self) -> u16 {
+        get_bits(self.edx, 16, 19) as u16
+    }
+
+    /// Number of C5 sub C-states supported using MWAIT (Bits 23 - 20)
+    pub fn supported_c5_states(&self) -> u16 {
+        get_bits(self.edx, 20, 23) as u16
+    }
+
+    /// Number of C6 sub C-states supported using MWAIT (Bits 27 - 24)
+    pub fn supported_c6_states(&self) -> u16 {
+        get_bits(self.edx, 24, 27) as u16
+    }
+
+    /// Number of C7 sub C-states supported using MWAIT (Bits 31 - 28)
+    pub fn supported_c7_states(&self) -> u16 {
+        get_bits(self.edx, 28, 31) as u16
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ThermalPowerInfo {
+    eax: ThermalPowerFeaturesEax,
+    ebx: u32,
+    ecx: ThermalPowerFeaturesEcx,
+    edx: u32,
+}
+
+impl ThermalPowerInfo {
+    /// Number of Interrupt Thresholds in Digital Thermal Sensor
+    pub fn dts_irq_threshold(&self) -> u8 {
+        get_bits(self.ebx, 0, 3) as u8
+    }
+
+    check_flag!(
+        doc = "Digital temperature sensor is supported if set.",
+        has_dts,
+        eax,
+        ThermalPowerFeaturesEax::DTS
+    );
+
+    check_flag!(
+        doc = "Intel Turbo Boost Technology Available (see description of \
+               IA32_MISC_ENABLE\\[38\\]).",
+        has_turbo_boost,
+        eax,
+        ThermalPowerFeaturesEax::TURBO_BOOST
+    );
+
+    check_flag!(
+        doc = "ARAT. APIC-Timer-always-running feature is supported if set.",
+        has_arat,
+        eax,
+        ThermalPowerFeaturesEax::ARAT
+    );
+
+    check_flag!(
+        doc = "PLN. Power limit notification controls are supported if set.",
+        has_pln,
+        eax,
+        ThermalPowerFeaturesEax::PLN
+    );
+
+    check_flag!(
+        doc = "ECMD. Clock modulation duty cycle extension is supported if set.",
+        has_ecmd,
+        eax,
+        ThermalPowerFeaturesEax::ECMD
+    );
+
+    check_flag!(
+        doc = "PTM. Package thermal management is supported if set.",
+        has_ptm,
+        eax,
+        ThermalPowerFeaturesEax::PTM
+    );
+
+    check_flag!(
+        doc = "HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, \
+               IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.",
+        has_hwp,
+        eax,
+        ThermalPowerFeaturesEax::HWP
+    );
+
+    check_flag!(
+        doc = "HWP Notification. IA32_HWP_INTERRUPT MSR is supported if set.",
+        has_hwp_notification,
+        eax,
+        ThermalPowerFeaturesEax::HWP_NOTIFICATION
+    );
+
+    check_flag!(
+        doc = "HWP Activity Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.",
+        has_hwp_activity_window,
+        eax,
+        ThermalPowerFeaturesEax::HWP_ACTIVITY_WINDOW
+    );
+
+    check_flag!(
+        doc =
+            "HWP Energy Performance Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.",
+        has_hwp_energy_performance_preference,
+        eax,
+        ThermalPowerFeaturesEax::HWP_ENERGY_PERFORMANCE_PREFERENCE
+    );
+
+    check_flag!(
+        doc = "HWP Package Level Request. IA32_HWP_REQUEST_PKG MSR is supported if set.",
+        has_hwp_package_level_request,
+        eax,
+        ThermalPowerFeaturesEax::HWP_PACKAGE_LEVEL_REQUEST
+    );
+
+    check_flag!(
+        doc = "HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL \
+               MSRs are supported if set.",
+        has_hdc,
+        eax,
+        ThermalPowerFeaturesEax::HDC
+    );
+
+    check_flag!(
+        doc = "Intel® Turbo Boost Max Technology 3.0 available.",
+        has_turbo_boost3,
+        eax,
+        ThermalPowerFeaturesEax::TURBO_BOOST_3
+    );
+
+    check_flag!(
+        doc = "HWP Capabilities. Highest Performance change is supported if set.",
+        has_hwp_capabilities,
+        eax,
+        ThermalPowerFeaturesEax::HWP_CAPABILITIES
+    );
+
+    check_flag!(
+        doc = "HWP PECI override is supported if set.",
+        has_hwp_peci_override,
+        eax,
+        ThermalPowerFeaturesEax::HWP_PECI_OVERRIDE
+    );
+
+    check_flag!(
+        doc = "Flexible HWP is supported if set.",
+        has_flexible_hwp,
+        eax,
+        ThermalPowerFeaturesEax::FLEXIBLE_HWP
+    );
+
+    check_flag!(
+        doc = "Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.",
+        has_hwp_fast_access_mode,
+        eax,
+        ThermalPowerFeaturesEax::HWP_REQUEST_MSR_FAST_ACCESS
+    );
+
+    check_flag!(
+        doc = "Ignoring Idle Logical Processor HWP request is supported if set.",
+        has_ignore_idle_processor_hwp_request,
+        eax,
+        ThermalPowerFeaturesEax::IGNORE_IDLE_PROCESSOR_HWP_REQUEST
+    );
+
+    check_flag!(
+        doc = "Hardware Coordination Feedback Capability (Presence of IA32_MPERF and \
+               IA32_APERF). The capability to provide a measure of delivered processor \
+               performance (since last reset of the counters), as a percentage of \
+               expected processor performance at frequency specified in CPUID Brand \
+               String Bits 02 - 01",
+        has_hw_coord_feedback,
+        ecx,
+        ThermalPowerFeaturesEcx::HW_COORD_FEEDBACK
+    );
+
+    check_flag!(
+        doc = "The processor supports performance-energy bias preference if \
+               CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a \
+               new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)",
+        has_energy_bias_pref,
+        ecx,
+        ThermalPowerFeaturesEcx::ENERGY_BIAS_PREF
+    );
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ThermalPowerFeaturesEax: u32 {
+        /// Digital temperature sensor is supported if set. (Bit 00)
+        const DTS = 1 << 0;
+        /// Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLE[38]). (Bit 01)
+        const TURBO_BOOST = 1 << 1;
+        /// ARAT. APIC-Timer-always-running feature is supported if set. (Bit 02)
+        const ARAT = 1 << 2;
+        /// Bit 3: Reserved.
+        const RESERVED_3 = 1 << 3;
+        /// PLN. Power limit notification controls are supported if set. (Bit 04)
+        const PLN = 1 << 4;
+        /// ECMD. Clock modulation duty cycle extension is supported if set. (Bit 05)
+        const ECMD = 1 << 5;
+        /// PTM. Package thermal management is supported if set. (Bit 06)
+        const PTM = 1 << 6;
+        /// Bit 07: HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.
+        const HWP = 1 << 7;
+        /// Bit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
+        const HWP_NOTIFICATION = 1 << 8;
+        /// Bit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
+        const HWP_ACTIVITY_WINDOW = 1 << 9;
+        /// Bit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
+        const HWP_ENERGY_PERFORMANCE_PREFERENCE = 1 << 10;
+        /// Bit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
+        const HWP_PACKAGE_LEVEL_REQUEST = 1 << 11;
+        /// Bit 12: Reserved.
+        const RESERVED_12 = 1 << 12;
+        /// Bit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
+        const HDC = 1 << 13;
+        /// Bit 14: Intel® Turbo Boost Max Technology 3.0 available.
+        const TURBO_BOOST_3 = 1 << 14;
+        /// Bit 15: HWP Capabilities. Highest Performance change is supported if set.
+        const HWP_CAPABILITIES = 1 << 15;
+        /// Bit 16: HWP PECI override is supported if set.
+        const HWP_PECI_OVERRIDE = 1 << 16;
+        /// Bit 17: Flexible HWP is supported if set.
+        const FLEXIBLE_HWP = 1 << 17;
+        /// Bit 18: Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
+        const HWP_REQUEST_MSR_FAST_ACCESS = 1 << 18;
+        /// Bit 19: Reserved.
+        const RESERVED_19 = 1 << 19;
+        /// Bit 20: Ignoring Idle Logical Processor HWP request is supported if set.
+        const IGNORE_IDLE_PROCESSOR_HWP_REQUEST = 1 << 20;
+        // Bits 31 - 21: Reserved
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ThermalPowerFeaturesEcx: u32 {
+        /// Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a measure of delivered processor performance (since last reset of the counters), as a percentage of expected processor performance at frequency specified in CPUID Brand String Bits 02 - 01
+        const HW_COORD_FEEDBACK = 1 << 0;
+
+        /// The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)
+        const ENERGY_BIAS_PREF = 1 << 3;
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedFeatures {
+    eax: u32,
+    ebx: ExtendedFeaturesEbx,
+    ecx: ExtendedFeaturesEcx,
+    edx: u32,
+}
+
+impl ExtendedFeatures {
+    check_flag!(
+        doc = "FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.",
+        has_fsgsbase,
+        ebx,
+        ExtendedFeaturesEbx::FSGSBASE
+    );
+
+    check_flag!(
+        doc = "IA32_TSC_ADJUST MSR is supported if 1.",
+        has_tsc_adjust_msr,
+        ebx,
+        ExtendedFeaturesEbx::ADJUST_MSR
+    );
+
+    check_flag!(doc = "BMI1", has_bmi1, ebx, ExtendedFeaturesEbx::BMI1);
+
+    check_flag!(doc = "HLE", has_hle, ebx, ExtendedFeaturesEbx::HLE);
+
+    check_flag!(doc = "AVX2", has_avx2, ebx, ExtendedFeaturesEbx::AVX2);
+
+    check_flag!(
+        doc = "FDP_EXCPTN_ONLY. x87 FPU Data Pointer updated only on x87 exceptions if 1.",
+        has_fdp,
+        ebx,
+        ExtendedFeaturesEbx::FDP
+    );
+
+    check_flag!(
+        doc = "SMEP. Supports Supervisor-Mode Execution Prevention if 1.",
+        has_smep,
+        ebx,
+        ExtendedFeaturesEbx::SMEP
+    );
+
+    check_flag!(doc = "BMI2", has_bmi2, ebx, ExtendedFeaturesEbx::BMI2);
+
+    check_flag!(
+        doc = "Supports Enhanced REP MOVSB/STOSB if 1.",
+        has_rep_movsb_stosb,
+        ebx,
+        ExtendedFeaturesEbx::REP_MOVSB_STOSB
+    );
+
+    check_flag!(
+        doc = "INVPCID. If 1, supports INVPCID instruction for system software that \
+               manages process-context identifiers.",
+        has_invpcid,
+        ebx,
+        ExtendedFeaturesEbx::INVPCID
+    );
+
+    check_flag!(doc = "RTM", has_rtm, ebx, ExtendedFeaturesEbx::RTM);
+
+    check_flag!(
+        doc = "Supports Intel Resource Director Technology (RDT) Monitoring capability.",
+        has_rdtm,
+        ebx,
+        ExtendedFeaturesEbx::RDTM
+    );
+
+    check_flag!(
+        doc = "Deprecates FPU CS and FPU DS values if 1.",
+        has_fpu_cs_ds_deprecated,
+        ebx,
+        ExtendedFeaturesEbx::DEPRECATE_FPU_CS_DS
+    );
+
+    check_flag!(
+        doc = "MPX. Supports Intel Memory Protection Extensions if 1.",
+        has_mpx,
+        ebx,
+        ExtendedFeaturesEbx::MPX
+    );
+
+    check_flag!(
+        doc = "Supports Intel Resource Director Technology (RDT) Allocation capability.",
+        has_rdta,
+        ebx,
+        ExtendedFeaturesEbx::RDTA
+    );
+
+    check_flag!(
+        doc = "Supports RDSEED.",
+        has_rdseed,
+        ebx,
+        ExtendedFeaturesEbx::RDSEED
+    );
+
+    #[deprecated(
+        since = "3.2",
+        note = "Deprecated due to typo in name, users should use has_rdseed() instead."
+    )]
+    check_flag!(
+        doc = "Supports RDSEED (deprecated alias).",
+        has_rdseet,
+        ebx,
+        ExtendedFeaturesEbx::RDSEED
+    );
+
+    check_flag!(
+        doc = "Supports ADX.",
+        has_adx,
+        ebx,
+        ExtendedFeaturesEbx::ADX
+    );
+
+    check_flag!(doc = "SMAP. Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.",
+                has_smap,
+                ebx,
+                ExtendedFeaturesEbx::SMAP);
+
+    check_flag!(
+        doc = "Supports CLFLUSHOPT.",
+        has_clflushopt,
+        ebx,
+        ExtendedFeaturesEbx::CLFLUSHOPT
+    );
+
+    check_flag!(
+        doc = "Supports Intel Processor Trace.",
+        has_processor_trace,
+        ebx,
+        ExtendedFeaturesEbx::PROCESSOR_TRACE
+    );
+
+    check_flag!(
+        doc = "Supports SHA Instructions.",
+        has_sha,
+        ebx,
+        ExtendedFeaturesEbx::SHA
+    );
+
+    check_flag!(
+        doc = "Supports Intel® Software Guard Extensions (Intel® SGX Extensions).",
+        has_sgx,
+        ebx,
+        ExtendedFeaturesEbx::SGX
+    );
+
+    check_flag!(
+        doc = "Supports AVX512F.",
+        has_avx512f,
+        ebx,
+        ExtendedFeaturesEbx::AVX512F
+    );
+
+    check_flag!(
+        doc = "Supports AVX512DQ.",
+        has_avx512dq,
+        ebx,
+        ExtendedFeaturesEbx::AVX512DQ
+    );
+
+    check_flag!(
+        doc = "AVX512_IFMA",
+        has_avx512_ifma,
+        ebx,
+        ExtendedFeaturesEbx::AVX512_IFMA
+    );
+
+    check_flag!(
+        doc = "AVX512PF",
+        has_avx512pf,
+        ebx,
+        ExtendedFeaturesEbx::AVX512PF
+    );
+    check_flag!(
+        doc = "AVX512ER",
+        has_avx512er,
+        ebx,
+        ExtendedFeaturesEbx::AVX512ER
+    );
+
+    check_flag!(
+        doc = "AVX512CD",
+        has_avx512cd,
+        ebx,
+        ExtendedFeaturesEbx::AVX512CD
+    );
+
+    check_flag!(
+        doc = "AVX512BW",
+        has_avx512bw,
+        ebx,
+        ExtendedFeaturesEbx::AVX512BW
+    );
+
+    check_flag!(
+        doc = "AVX512VL",
+        has_avx512vl,
+        ebx,
+        ExtendedFeaturesEbx::AVX512VL
+    );
+
+    check_flag!(doc = "CLWB", has_clwb, ebx, ExtendedFeaturesEbx::CLWB);
+
+    check_flag!(
+        doc = "Has PREFETCHWT1 (Intel® Xeon Phi™ only).",
+        has_prefetchwt1,
+        ecx,
+        ExtendedFeaturesEcx::PREFETCHWT1
+    );
+
+    check_flag!(
+        doc = "Supports user-mode instruction prevention if 1.",
+        has_umip,
+        ecx,
+        ExtendedFeaturesEcx::UMIP
+    );
+
+    check_flag!(
+        doc = "Supports protection keys for user-mode pages.",
+        has_pku,
+        ecx,
+        ExtendedFeaturesEcx::PKU
+    );
+
+    check_flag!(
+        doc = "OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions.",
+        has_ospke,
+        ecx,
+        ExtendedFeaturesEcx::OSPKE
+    );
+
+    check_flag!(
+        doc = "RDPID and IA32_TSC_AUX are available.",
+        has_rdpid,
+        ecx,
+        ExtendedFeaturesEcx::RDPID
+    );
+
+    check_flag!(
+        doc = "Supports SGX Launch Configuration.",
+        has_sgx_lc,
+        ecx,
+        ExtendedFeaturesEcx::SGX_LC
+    );
+
+    /// The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
+    pub fn mawau_value(&self) -> u8 {
+        get_bits(self.ecx.bits(), 17, 21) as u8
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedFeaturesEbx: u32 {
+        /// FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1. (Bit 00)
+        const FSGSBASE = 1 << 0;
+        /// IA32_TSC_ADJUST MSR is supported if 1. (Bit 01)
+        const ADJUST_MSR = 1 << 1;
+        /// Bit 02: SGX. Supports Intel® Software Guard Extensions (Intel® SGX Extensions) if 1.
+        const SGX = 1 << 2;
+        /// BMI1 (Bit 03)
+        const BMI1 = 1 << 3;
+        /// HLE (Bit 04)
+        const HLE = 1 << 4;
+        /// AVX2 (Bit 05)
+        const AVX2 = 1 << 5;
+        /// FDP_EXCPTN_ONLY. x87 FPU Data Pointer updated only on x87 exceptions if 1.
+        const FDP = 1 << 6;
+        /// SMEP. Supports Supervisor-Mode Execution Prevention if 1. (Bit 07)
+        const SMEP = 1 << 7;
+        /// BMI2 (Bit 08)
+        const BMI2 = 1 << 8;
+        /// Supports Enhanced REP MOVSB/STOSB if 1. (Bit 09)
+        const REP_MOVSB_STOSB = 1 << 9;
+        /// INVPCID. If 1, supports INVPCID instruction for system software that manages process-context identifiers. (Bit 10)
+        const INVPCID = 1 << 10;
+        /// RTM (Bit 11)
+        const RTM = 1 << 11;
+        /// Supports Intel Resource Director Technology (RDT) Monitoring. (Bit 12)
+        const RDTM = 1 << 12;
+        /// Deprecates FPU CS and FPU DS values if 1. (Bit 13)
+        const DEPRECATE_FPU_CS_DS = 1 << 13;
+        /// Deprecates FPU CS and FPU DS values if 1. (Bit 14)
+        const MPX = 1 << 14;
+        /// Supports Intel Resource Director Technology (RDT) Allocation capability if 1.
+        const RDTA = 1 << 15;
+        /// Bit 16: AVX512F.
+        const AVX512F = 1 << 16;
+        /// Bit 17: AVX512DQ.
+        const AVX512DQ = 1 << 17;
+        /// Supports RDSEED.
+        const RDSEED = 1 << 18;
+        /// Supports ADX.
+        const ADX = 1 << 19;
+        /// SMAP. Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
+        const SMAP = 1 << 20;
+        /// Bit 21: AVX512_IFMA.
+        const AVX512_IFMA = 1 << 21;
+        // Bit 22: Reserved.
+        /// Bit 23: CLFLUSHOPT
+        const CLFLUSHOPT = 1 << 23;
+        /// Bit 24: CLWB.
+        const CLWB = 1 << 24;
+        /// Bit 25: Intel Processor Trace
+        const PROCESSOR_TRACE = 1 << 25;
+        /// Bit 26: AVX512PF. (Intel® Xeon Phi™ only.)
+        const AVX512PF = 1 << 26;
+        /// Bit 27: AVX512ER. (Intel® Xeon Phi™ only.)
+        const AVX512ER = 1 << 27;
+        /// Bit 28: AVX512CD.
+        const AVX512CD = 1 << 28;
+        /// Bit 29: Intel SHA Extensions
+        const SHA = 1 << 29;
+        /// Bit 30: AVX512BW.
+        const AVX512BW = 1 << 30;
+        /// Bit 31: AVX512VL.
+        const AVX512VL = 1 << 31;
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedFeaturesEcx: u32 {
+        /// Bit 0: Prefetch WT1. (Intel® Xeon Phi™ only).
+        const PREFETCHWT1 = 1 << 0;
+
+        // Bit 01: AVX512_VBMI
+        const AVX512VBMI = 1 << 1;
+
+        /// Bit 02: UMIP. Supports user-mode instruction prevention if 1.
+        const UMIP = 1 << 2;
+
+        /// Bit 03: PKU. Supports protection keys for user-mode pages if 1.
+        const PKU = 1 << 3;
+
+        /// Bit 04: OSPKE. If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instruc-tions).
+        const OSPKE = 1 << 4;
+
+        // Bits 16 - 5: Reserved.
+        // Bits 21 - 17: The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
+
+
+        /// Bit 22: RDPID. RDPID and IA32_TSC_AUX are available if 1.
+        const RDPID = 1 << 22;
+
+        // Bits 29 - 23: Reserved.
+
+        /// Bit 30: SGX_LC. Supports SGX Launch Configuration if 1.
+        const SGX_LC = 1 << 30;
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct DirectCacheAccessInfo {
+    eax: u32,
+}
+
+impl DirectCacheAccessInfo {
+    /// Value of bits \[31:0\] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)
+    pub fn get_dca_cap_value(&self) -> u32 {
+        self.eax
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct PerformanceMonitoringInfo {
+    eax: u32,
+    ebx: PerformanceMonitoringFeaturesEbx,
+    ecx: u32,
+    edx: u32,
+}
+
+impl PerformanceMonitoringInfo {
+    /// Version ID of architectural performance monitoring. (Bits 07 - 00)
+    pub fn version_id(&self) -> u8 {
+        get_bits(self.eax, 0, 7) as u8
+    }
+
+    /// Number of general-purpose performance monitoring counter per logical processor. (Bits 15- 08)
+    pub fn number_of_counters(&self) -> u8 {
+        get_bits(self.eax, 8, 15) as u8
+    }
+
+    /// Bit width of general-purpose, performance monitoring counter. (Bits 23 - 16)
+    pub fn counter_bit_width(&self) -> u8 {
+        get_bits(self.eax, 16, 23) as u8
+    }
+
+    /// Length of EBX bit vector to enumerate architectural performance monitoring events. (Bits 31 - 24)
+    pub fn ebx_length(&self) -> u8 {
+        get_bits(self.eax, 24, 31) as u8
+    }
+
+    /// Number of fixed-function performance counters (if Version ID > 1). (Bits 04 - 00)
+    pub fn fixed_function_counters(&self) -> u8 {
+        get_bits(self.edx, 0, 4) as u8
+    }
+
+    /// Bit width of fixed-function performance counters (if Version ID > 1). (Bits 12- 05)
+    pub fn fixed_function_counters_bit_width(&self) -> u8 {
+        get_bits(self.edx, 5, 12) as u8
+    }
+
+    check_bit_fn!(
+        doc = "AnyThread deprecation",
+        has_any_thread_deprecation,
+        edx,
+        15
+    );
+
+    check_flag!(
+        doc = "Core cycle event not available if 1.",
+        is_core_cyc_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::CORE_CYC_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Instruction retired event not available if 1.",
+        is_inst_ret_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::INST_RET_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Reference cycles event not available if 1.",
+        is_ref_cycle_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::REF_CYC_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Last-level cache reference event not available if 1.",
+        is_cache_ref_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::CACHE_REF_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Last-level cache misses event not available if 1.",
+        is_ll_cache_miss_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::LL_CACHE_MISS_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Branch instruction retired event not available if 1.",
+        is_branch_inst_ret_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::BRANCH_INST_RET_EV_UNAVAILABLE
+    );
+
+    check_flag!(
+        doc = "Branch mispredict retired event not available if 1.",
+        is_branch_midpred_ev_unavailable,
+        ebx,
+        PerformanceMonitoringFeaturesEbx::BRANCH_MISPRED_EV_UNAVAILABLE
+    );
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct PerformanceMonitoringFeaturesEbx: u32 {
+        /// Core cycle event not available if 1. (Bit 0)
+        const CORE_CYC_EV_UNAVAILABLE = 1 << 0;
+        /// Instruction retired event not available if 1. (Bit 01)
+        const INST_RET_EV_UNAVAILABLE = 1 << 1;
+        /// Reference cycles event not available if 1. (Bit 02)
+        const REF_CYC_EV_UNAVAILABLE = 1 << 2;
+        /// Last-level cache reference event not available if 1. (Bit 03)
+        const CACHE_REF_EV_UNAVAILABLE = 1 << 3;
+        /// Last-level cache misses event not available if 1. (Bit 04)
+        const LL_CACHE_MISS_EV_UNAVAILABLE = 1 << 4;
+        /// Branch instruction retired event not available if 1. (Bit 05)
+        const BRANCH_INST_RET_EV_UNAVAILABLE = 1 << 5;
+        /// Branch mispredict retired event not available if 1. (Bit 06)
+        const BRANCH_MISPRED_EV_UNAVAILABLE = 1 << 6;
+    }
+}
+
+/// Iterates over the system topology in order to retrieve more
+/// system information at each level of the topology.
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedTopologyIter {
+    level: u32,
+}
+
+/// Gives detailed information about the current level in the topology
+/// (how many cores, what type etc.).
+#[derive(Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedTopologyLevel {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl fmt::Debug for ExtendedTopologyLevel {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("ExtendedTopologyLevel")
+            .field("processors", &self.processors())
+            .field("number", &self.level_number())
+            .field("type", &self.level_type())
+            .field("x2apic_id", &self.x2apic_id())
+            .field("next_apic_id", &self.shift_right_for_next_apic_id())
+            .finish()
+    }
+}
+
+impl ExtendedTopologyLevel {
+    /// Number of logical processors at this level type.
+    /// The number reflects configuration as shipped.
+    pub fn processors(&self) -> u16 {
+        get_bits(self.ebx, 0, 15) as u16
+    }
+
+    /// Level number.
+    pub fn level_number(&self) -> u8 {
+        get_bits(self.ecx, 0, 7) as u8
+    }
+
+    // Level type.
+    pub fn level_type(&self) -> TopologyType {
+        match get_bits(self.ecx, 8, 15) {
+            0 => TopologyType::Invalid,
+            1 => TopologyType::SMT,
+            2 => TopologyType::Core,
+            _ => unreachable!(),
+        }
+    }
+
+    /// x2APIC ID the current logical processor. (Bits 31-00)
+    pub fn x2apic_id(&self) -> u32 {
+        self.edx
+    }
+
+    /// Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. (Bits 04-00)
+    /// All logical processors with the same next level ID share current level.
+    pub fn shift_right_for_next_apic_id(&self) -> u32 {
+        get_bits(self.eax, 0, 4)
+    }
+}
+
+/// What type of core we have at this level in the topology (real CPU or hyper-threaded).
+#[derive(PartialEq, Eq, Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum TopologyType {
+    Invalid = 0,
+    /// Hyper-thread (Simultaneous multithreading)
+    SMT = 1,
+    Core = 2,
+}
+
+impl Default for TopologyType {
+    fn default() -> TopologyType {
+        TopologyType::Invalid
+    }
+}
+
+impl Iterator for ExtendedTopologyIter {
+    type Item = ExtendedTopologyLevel;
+
+    fn next(&mut self) -> Option<ExtendedTopologyLevel> {
+        let res = cpuid!(EAX_EXTENDED_TOPOLOGY_INFO, self.level);
+        self.level += 1;
+
+        let et = ExtendedTopologyLevel {
+            eax: res.eax,
+            ebx: res.ebx,
+            ecx: res.ecx,
+            edx: res.edx,
+        };
+
+        match et.level_type() {
+            TopologyType::Invalid => None,
+            _ => Some(et),
+        }
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedStateInfoXCR0Flags: u32 {
+        /// legacy x87 (Bit 00).
+        const LEGACY_X87 = 1 << 0;
+
+        /// 128-bit SSE (Bit 01).
+        const SSE128 = 1 << 1;
+
+        /// 256-bit AVX (Bit 02).
+        const AVX256 = 1 << 2;
+
+        /// MPX BNDREGS (Bit 03).
+        const MPX_BNDREGS = 1 << 3;
+
+        /// MPX BNDCSR (Bit 04).
+        const MPX_BNDCSR = 1 << 4;
+
+        /// AVX512 OPMASK (Bit 05).
+        const AVX512_OPMASK = 1 << 5;
+
+        /// AVX ZMM Hi256 (Bit 06).
+        const AVX512_ZMM_HI256 = 1 << 6;
+
+        /// AVX 512 ZMM Hi16 (Bit 07).
+        const AVX512_ZMM_HI16 = 1 << 7;
+
+        /// PKRU state (Bit 09).
+        const PKRU = 1 << 9;
+
+        /// IA32_XSS HDC State (Bit 13).
+        const IA32_XSS_HDC = 1 << 13;
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedStateInfoXSSFlags: u32 {
+        /// IA32_XSS PT (Trace Packet) State (Bit 08).
+        const PT = 1 << 8;
+
+        /// IA32_XSS HDC State (Bit 13).
+        const HDC = 1 << 13;
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedStateInfo {
+    eax: ExtendedStateInfoXCR0Flags,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+    eax1: u32,
+    ebx1: u32,
+    ecx1: ExtendedStateInfoXSSFlags,
+    edx1: u32,
+}
+
+impl ExtendedStateInfo {
+    check_flag!(
+        doc = "Support for legacy x87 in XCR0.",
+        xcr0_supports_legacy_x87,
+        eax,
+        ExtendedStateInfoXCR0Flags::LEGACY_X87
+    );
+
+    check_flag!(
+        doc = "Support for SSE 128-bit in XCR0.",
+        xcr0_supports_sse_128,
+        eax,
+        ExtendedStateInfoXCR0Flags::SSE128
+    );
+
+    check_flag!(
+        doc = "Support for AVX 256-bit in XCR0.",
+        xcr0_supports_avx_256,
+        eax,
+        ExtendedStateInfoXCR0Flags::AVX256
+    );
+
+    check_flag!(
+        doc = "Support for MPX BNDREGS in XCR0.",
+        xcr0_supports_mpx_bndregs,
+        eax,
+        ExtendedStateInfoXCR0Flags::MPX_BNDREGS
+    );
+
+    check_flag!(
+        doc = "Support for MPX BNDCSR in XCR0.",
+        xcr0_supports_mpx_bndcsr,
+        eax,
+        ExtendedStateInfoXCR0Flags::MPX_BNDCSR
+    );
+
+    check_flag!(
+        doc = "Support for AVX512 OPMASK in XCR0.",
+        xcr0_supports_avx512_opmask,
+        eax,
+        ExtendedStateInfoXCR0Flags::AVX512_OPMASK
+    );
+
+    check_flag!(
+        doc = "Support for AVX512 ZMM Hi256 XCR0.",
+        xcr0_supports_avx512_zmm_hi256,
+        eax,
+        ExtendedStateInfoXCR0Flags::AVX512_ZMM_HI256
+    );
+
+    check_flag!(
+        doc = "Support for AVX512 ZMM Hi16 in XCR0.",
+        xcr0_supports_avx512_zmm_hi16,
+        eax,
+        ExtendedStateInfoXCR0Flags::AVX512_ZMM_HI16
+    );
+
+    check_flag!(
+        doc = "Support for PKRU in XCR0.",
+        xcr0_supports_pkru,
+        eax,
+        ExtendedStateInfoXCR0Flags::PKRU
+    );
+
+    check_flag!(
+        doc = "Support for PT in IA32_XSS.",
+        ia32_xss_supports_pt,
+        ecx1,
+        ExtendedStateInfoXSSFlags::PT
+    );
+
+    check_flag!(
+        doc = "Support for HDC in IA32_XSS.",
+        ia32_xss_supports_hdc,
+        ecx1,
+        ExtendedStateInfoXSSFlags::HDC
+    );
+
+    /// Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by
+    /// enabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save area
+    /// are not enabled.
+    pub fn xsave_area_size_enabled_features(&self) -> u32 {
+        self.ebx
+    }
+
+    /// Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the
+    /// XSAVE/XRSTOR save area required by all supported features in the processor,
+    /// i.e all the valid bit fields in XCR0.
+    pub fn xsave_area_size_supported_features(&self) -> u32 {
+        self.ecx
+    }
+
+    /// CPU has xsaveopt feature.
+    pub fn has_xsaveopt(&self) -> bool {
+        self.eax1 & 0x1 > 0
+    }
+
+    /// Supports XSAVEC and the compacted form of XRSTOR if set.
+    pub fn has_xsavec(&self) -> bool {
+        self.eax1 & 0b10 > 0
+    }
+
+    /// Supports XGETBV with ECX = 1 if set.
+    pub fn has_xgetbv(&self) -> bool {
+        self.eax1 & 0b100 > 0
+    }
+
+    /// Supports XSAVES/XRSTORS and IA32_XSS if set.
+    pub fn has_xsaves_xrstors(&self) -> bool {
+        self.eax1 & 0b1000 > 0
+    }
+
+    /// The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
+    pub fn xsave_size(&self) -> u32 {
+        self.ebx1
+    }
+
+    /// Iterator over extended state enumeration levels >= 2.
+    pub fn iter(&self) -> ExtendedStateIter {
+        ExtendedStateIter {
+            level: 1,
+            supported_xcr0: self.eax.bits(),
+            supported_xss: self.ecx1.bits(),
+        }
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedStateIter {
+    level: u32,
+    supported_xcr0: u32,
+    supported_xss: u32,
+}
+
+/// When CPUID executes with EAX set to 0DH and ECX = n (n > 1,
+/// and is a valid sub-leaf index), the processor returns information
+/// about the size and offset of each processor extended state save area
+/// within the XSAVE/XRSTOR area. Software can use the forward-extendable
+/// technique depicted below to query the valid sub-leaves and obtain size
+/// and offset information for each processor extended state save area:///
+///
+/// For i = 2 to 62 // sub-leaf 1 is reserved
+///   IF (CPUID.(EAX=0DH, ECX=0):VECTOR\[i\] = 1 ) // VECTOR is the 64-bit value of EDX:EAX
+///     Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i;
+/// FI;
+impl Iterator for ExtendedStateIter {
+    type Item = ExtendedState;
+
+    fn next(&mut self) -> Option<ExtendedState> {
+        self.level += 1;
+        if self.level > 31 {
+            return None;
+        }
+
+        let bit = 1 << self.level;
+        if (self.supported_xcr0 & bit > 0) || (self.supported_xss & bit > 0) {
+            let res = cpuid!(EAX_EXTENDED_STATE_INFO, self.level);
+            return Some(ExtendedState {
+                subleaf: self.level,
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+            });
+        }
+
+        self.next()
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedState {
+    pub subleaf: u32,
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+}
+
+impl ExtendedState {
+    /// The size in bytes (from the offset specified in EBX) of the save area
+    /// for an extended state feature associated with a valid sub-leaf index, n.
+    /// This field reports 0 if the sub-leaf index, n, is invalid.
+    pub fn size(&self) -> u32 {
+        self.eax
+    }
+
+    /// The offset in bytes of this extended state components save area
+    /// from the beginning of the XSAVE/XRSTOR area.
+    pub fn offset(&self) -> u32 {
+        self.ebx
+    }
+
+    /// True if the bit n (corresponding to the sub-leaf index)
+    /// is supported in the IA32_XSS MSR;
+    pub fn is_in_ia32_xss(&self) -> bool {
+        self.ecx & 0b1 > 0
+    }
+
+    /// True if bit n is supported in XCR0.
+    pub fn is_in_xcr0(&self) -> bool {
+        self.ecx & 0b1 == 0
+    }
+
+    /// Returns true when the compacted format of an XSAVE area is used,
+    /// this extended state component located on the next 64-byte
+    /// boundary following the preceding state component
+    /// (otherwise, it is located immediately following the preceding state component).
+    pub fn is_compacted_format(&self) -> bool {
+        self.ecx & 0b10 > 0
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct RdtMonitoringInfo {
+    ebx: u32,
+    edx: u32,
+}
+
+/// Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0 and ECX = 1)
+impl RdtMonitoringInfo {
+    /// Maximum range (zero-based) of RMID within this physical processor of all types.
+    pub fn rmid_range(&self) -> u32 {
+        self.ebx
+    }
+
+    check_bit_fn!(
+        doc = "Supports L3 Cache Intel RDT Monitoring.",
+        has_l3_monitoring,
+        edx,
+        1
+    );
+
+    /// L3 Cache Monitoring.
+    pub fn l3_monitoring(&self) -> Option<L3MonitoringInfo> {
+        if self.has_l3_monitoring() {
+            let res = cpuid!(EAX_RDT_MONITORING, 1);
+            return Some(L3MonitoringInfo {
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            });
+        } else {
+            return None;
+        }
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct L3MonitoringInfo {
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl L3MonitoringInfo {
+    /// Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
+    pub fn conversion_factor(&self) -> u32 {
+        self.ebx
+    }
+
+    /// Maximum range (zero-based) of RMID of L3.
+    pub fn maximum_rmid_range(&self) -> u32 {
+        self.ecx
+    }
+
+    check_bit_fn!(
+        doc = "Supports occupancy monitoring.",
+        has_occupancy_monitoring,
+        edx,
+        0
+    );
+
+    check_bit_fn!(
+        doc = "Supports total bandwidth monitoring.",
+        has_total_bandwidth_monitoring,
+        edx,
+        1
+    );
+
+    check_bit_fn!(
+        doc = "Supports local bandwidth monitoring.",
+        has_local_bandwidth_monitoring,
+        edx,
+        2
+    );
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct RdtAllocationInfo {
+    ebx: u32,
+}
+
+impl RdtAllocationInfo {
+    check_bit_fn!(doc = "Supports L3 Cache Allocation.", has_l3_cat, ebx, 1);
+
+    check_bit_fn!(doc = "Supports L2 Cache Allocation.", has_l2_cat, ebx, 2);
+
+    check_bit_fn!(
+        doc = "Supports Memory Bandwidth Allocation.",
+        has_memory_bandwidth_allocation,
+        ebx,
+        1
+    );
+
+    /// L3 Cache Allocation Information.
+    pub fn l3_cat(&self) -> Option<L3CatInfo> {
+        if self.has_l3_cat() {
+            let res = cpuid!(EAX_RDT_ALLOCATION, 1);
+            return Some(L3CatInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            });
+        } else {
+            return None;
+        }
+    }
+
+    /// L2 Cache Allocation Information.
+    pub fn l2_cat(&self) -> Option<L2CatInfo> {
+        if self.has_l2_cat() {
+            let res = cpuid!(EAX_RDT_ALLOCATION, 2);
+            return Some(L2CatInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                edx: res.edx,
+            });
+        } else {
+            return None;
+        }
+    }
+
+    /// Memory Bandwidth Allocation Information.
+    pub fn memory_bandwidth_allocation(&self) -> Option<MemBwAllocationInfo> {
+        if self.has_l2_cat() {
+            let res = cpuid!(EAX_RDT_ALLOCATION, 3);
+            return Some(MemBwAllocationInfo {
+                eax: res.eax,
+                ecx: res.ecx,
+                edx: res.edx,
+            });
+        } else {
+            return None;
+        }
+    }
+}
+
+/// L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1).
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct L3CatInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl L3CatInfo {
+    /// Length of the capacity bit mask using minus-one notation.
+    pub fn capacity_mask_length(&self) -> u8 {
+        get_bits(self.eax, 0, 4) as u8
+    }
+
+    /// Bit-granular map of isolation/contention of allocation units.
+    pub fn isolation_bitmap(&self) -> u32 {
+        self.ebx
+    }
+
+    /// Highest COS number supported for this Leaf.
+    pub fn highest_cos(&self) -> u16 {
+        get_bits(self.edx, 0, 15) as u16
+    }
+
+    check_bit_fn!(
+        doc = "Is Code and Data Prioritization Technology supported?",
+        has_code_data_prioritization,
+        ecx,
+        2
+    );
+}
+
+/// L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2).
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct L2CatInfo {
+    eax: u32,
+    ebx: u32,
+    edx: u32,
+}
+
+impl L2CatInfo {
+    /// Length of the capacity bit mask using minus-one notation.
+    pub fn capacity_mask_length(&self) -> u8 {
+        get_bits(self.eax, 0, 4) as u8
+    }
+
+    /// Bit-granular map of isolation/contention of allocation units.
+    pub fn isolation_bitmap(&self) -> u32 {
+        self.ebx
+    }
+
+    /// Highest COS number supported for this Leaf.
+    pub fn highest_cos(&self) -> u16 {
+        get_bits(self.edx, 0, 15) as u16
+    }
+}
+
+/// Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3).
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct MemBwAllocationInfo {
+    eax: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl MemBwAllocationInfo {
+    /// Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
+    pub fn max_hba_throttling(&self) -> u16 {
+        get_bits(self.eax, 0, 11) as u16
+    }
+
+    /// Highest COS number supported for this Leaf.
+    pub fn highest_cos(&self) -> u16 {
+        get_bits(self.edx, 0, 15) as u16
+    }
+
+    check_bit_fn!(
+        doc = "Reports whether the response of the delay values is linear.",
+        has_linear_response_delay,
+        ecx,
+        2
+    );
+}
+
+/// Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0 and ECX = 1)
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct SgxInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+    eax1: u32,
+    ebx1: u32,
+    ecx1: u32,
+    edx1: u32,
+}
+
+impl SgxInfo {
+    check_bit_fn!(doc = "Has SGX1 support.", has_sgx1, eax, 0);
+    check_bit_fn!(doc = "Has SGX2 support.", has_sgx2, eax, 1);
+
+    check_bit_fn!(
+        doc = "Supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.",
+        has_enclv_leaves_einvirtchild_edecvirtchild_esetcontext,
+        eax,
+        5
+    );
+
+    check_bit_fn!(
+        doc = "Supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.",
+        has_encls_leaves_etrackc_erdinfo_eldbc_elduc,
+        eax,
+        6
+    );
+
+    /// Bit vector of supported extended SGX features.
+    pub fn miscselect(&self) -> u32 {
+        self.ebx
+    }
+
+    ///  The maximum supported enclave size in non-64-bit mode is 2^retval.
+    pub fn max_enclave_size_non_64bit(&self) -> u8 {
+        get_bits(self.edx, 0, 7) as u8
+    }
+
+    ///  The maximum supported enclave size in 64-bit mode is 2^retval.
+    pub fn max_enclave_size_64bit(&self) -> u8 {
+        get_bits(self.edx, 8, 15) as u8
+    }
+
+    /// Reports the valid bits of SECS.ATTRIBUTES\[127:0\] that software can set with ECREATE.
+    pub fn secs_attributes(&self) -> (u64, u64) {
+        let lower = self.eax1 as u64 | (self.ebx1 as u64) << 32;
+        let upper = self.ecx1 as u64 | (self.edx1 as u64) << 32;
+        (lower, upper)
+    }
+    /// Iterator over SGX sub-leafs.
+    pub fn iter(&self) -> SgxSectionIter {
+        SgxSectionIter { current: 2 }
+    }
+}
+
+/// Iterator over the SGX sub-leafs (ECX >= 2).
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct SgxSectionIter {
+    current: u32,
+}
+
+impl Iterator for SgxSectionIter {
+    type Item = SgxSectionInfo;
+
+    fn next(&mut self) -> Option<SgxSectionInfo> {
+        self.current += 1;
+        let res = cpuid!(EAX_SGX, self.current);
+        match get_bits(res.eax, 0, 3) {
+            0b0001 => Some(SgxSectionInfo::Epc(EpcSection {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            })),
+            _ => None,
+        }
+    }
+}
+
+/// Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
+#[derive(Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum SgxSectionInfo {
+    // This would be nice: https://github.com/rust-lang/rfcs/pull/1450
+    Epc(EpcSection),
+}
+
+impl Default for SgxSectionInfo {
+    fn default() -> SgxSectionInfo {
+        SgxSectionInfo::Epc(Default::default())
+    }
+}
+
+/// EBX:EAX and EDX:ECX provide information on the Enclave Page Cache (EPC) section
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct EpcSection {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl EpcSection {
+    /// The physical address of the base of the EPC section
+    pub fn physical_base(&self) -> u64 {
+        let lower = (get_bits(self.eax, 12, 31) << 12) as u64;
+        let upper = (get_bits(self.ebx, 0, 19) as u64) << 32;
+        lower | upper
+    }
+
+    /// Size of the corresponding EPC section within the Processor Reserved Memory.
+    pub fn size(&self) -> u64 {
+        let lower = (get_bits(self.ecx, 12, 31) << 12) as u64;
+        let upper = (get_bits(self.edx, 0, 19) as u64) << 32;
+        lower | upper
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ProcessorTraceInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+    leaf1: Option<CpuIdResult>,
+}
+
+impl ProcessorTraceInfo {
+    // EBX features
+    check_bit_fn!(
+        doc = "If true, Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and \
+               that IA32_RTIT_CR3_MATCH MSR can be accessed.",
+        has_rtit_cr3_match,
+        ebx,
+        0
+    );
+    check_bit_fn!(
+        doc = "If true, Indicates support of Configurable PSB and Cycle-Accurate Mode.",
+        has_configurable_psb_and_cycle_accurate_mode,
+        ebx,
+        1
+    );
+    check_bit_fn!(
+        doc = "If true, Indicates support of IP Filtering, TraceStop filtering, and \
+               preservation of Intel PT MSRs across warm reset.",
+        has_ip_tracestop_filtering,
+        ebx,
+        2
+    );
+    check_bit_fn!(
+        doc = "If true, Indicates support of MTC timing packet and suppression of \
+               COFI-based packets.",
+        has_mtc_timing_packet_coefi_suppression,
+        ebx,
+        3
+    );
+
+    check_bit_fn!(
+        doc = "Indicates support of PTWRITE. Writes can set IA32_RTIT_CTL\\[12\\] (PTWEn \
+               and IA32_RTIT_CTL\\[5\\] (FUPonPTW), and PTWRITE can generate packets",
+        has_ptwrite,
+        ebx,
+        4
+    );
+
+    check_bit_fn!(
+        doc = "Support of Power Event Trace. Writes can set IA32_RTIT_CTL\\[4\\] (PwrEvtEn) \
+               enabling Power Event Trace packet generation.",
+        has_power_event_trace,
+        ebx,
+        5
+    );
+
+    // ECX features
+    check_bit_fn!(
+        doc = "If true, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence \
+               utilizing the ToPA output scheme; IA32_RTIT_OUTPUT_BASE and \
+               IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.",
+        has_topa,
+        ecx,
+        0
+    );
+    check_bit_fn!(
+        doc = "If true, ToPA tables can hold any number of output entries, up to the \
+               maximum allowed by the MaskOrTableOffset field of \
+               IA32_RTIT_OUTPUT_MASK_PTRS.",
+        has_topa_maximum_entries,
+        ecx,
+        1
+    );
+    check_bit_fn!(
+        doc = "If true, Indicates support of Single-Range Output scheme.",
+        has_single_range_output_scheme,
+        ecx,
+        2
+    );
+    check_bit_fn!(
+        doc = "If true, Indicates support of output to Trace Transport subsystem.",
+        has_trace_transport_subsystem,
+        ecx,
+        3
+    );
+    check_bit_fn!(
+        doc = "If true, Generated packets which contain IP payloads have LIP values, \
+               which include the CS base component.",
+        has_lip_with_cs_base,
+        ecx,
+        31
+    );
+
+    /// Number of configurable Address Ranges for filtering (Bits 2:0).
+    pub fn configurable_address_ranges(&self) -> u8 {
+        self.leaf1.map_or(0, |res| get_bits(res.eax, 0, 2) as u8)
+    }
+
+    /// Bitmap of supported MTC period encodings (Bit 31:16).
+    pub fn supported_mtc_period_encodings(&self) -> u16 {
+        self.leaf1.map_or(0, |res| get_bits(res.eax, 16, 31) as u16)
+    }
+
+    /// Bitmap of supported Cycle Threshold value encodings (Bits 15-0).
+    pub fn supported_cycle_threshold_value_encodings(&self) -> u16 {
+        self.leaf1.map_or(0, |res| get_bits(res.ebx, 0, 15) as u16)
+    }
+
+    /// Bitmap of supported Configurable PSB frequency encodings (Bit 31:16)
+    pub fn supported_psb_frequency_encodings(&self) -> u16 {
+        self.leaf1.map_or(0, |res| get_bits(res.ebx, 16, 31) as u16)
+    }
+}
+
+/// Time Stamp Counter and Nominal Core Crystal Clock Information Leaf.
+#[derive(Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct TscInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+}
+
+impl fmt::Debug for TscInfo {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("TscInfo")
+            .field("denominator/eax", &self.denominator())
+            .field("numerator/ebx", &self.numerator())
+            .field("nominal_frequency/ecx", &self.nominal_frequency())
+            .finish()
+    }
+}
+
+impl TscInfo {
+    /// An unsigned integer which is the denominator of the TSC/”core crystal clock” ratio.
+    pub fn denominator(&self) -> u32 {
+        self.eax
+    }
+
+    /// An unsigned integer which is the numerator of the TSC/”core crystal clock” ratio.
+    ///
+    /// If this is 0, the TSC/”core crystal clock” ratio is not enumerated.
+    pub fn numerator(&self) -> u32 {
+        self.ebx
+    }
+
+    /// An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
+    ///
+    /// If this is 0, the nominal core crystal clock frequency is not enumerated.
+    pub fn nominal_frequency(&self) -> u32 {
+        self.ecx
+    }
+
+    /// “TSC frequency” = “core crystal clock frequency” * EBX/EAX.
+    pub fn tsc_frequency(&self) -> u64 {
+        self.nominal_frequency() as u64 * self.numerator() as u64 / self.denominator() as u64
+    }
+}
+
+/// Processor Frequency Information
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ProcessorFrequencyInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+}
+
+impl ProcessorFrequencyInfo {
+    /// Processor Base Frequency (in MHz).
+    pub fn processor_base_frequency(&self) -> u16 {
+        get_bits(self.eax, 0, 15) as u16
+    }
+
+    /// Maximum Frequency (in MHz).
+    pub fn processor_max_frequency(&self) -> u16 {
+        get_bits(self.ebx, 0, 15) as u16
+    }
+
+    /// Bus (Reference) Frequency (in MHz).
+    pub fn bus_frequency(&self) -> u16 {
+        get_bits(self.ecx, 0, 15) as u16
+    }
+}
+
+/// Deterministic Address Translation Structure Iterator
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct DatIter {
+    current: u32,
+    count: u32,
+}
+
+impl Iterator for DatIter {
+    type Item = DatInfo;
+
+    /// Iterate over each sub-leaf with an  address translation structure.
+    fn next(&mut self) -> Option<DatInfo> {
+        loop {
+            // Sub-leaf index n is invalid if n exceeds the value that sub-leaf 0 returns in EAX
+            if self.current > self.count {
+                return None;
+            }
+
+            let res = cpuid!(EAX_DETERMINISTIC_ADDRESS_TRANSLATION_INFO, self.current);
+            self.current += 1;
+
+            // A sub-leaf index is also invalid if EDX[4:0] returns 0.
+            if get_bits(res.edx, 0, 4) == 0 {
+                // Valid sub-leaves do not need to be contiguous or in any particular order.
+                // A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
+                // or than a valid sub-leaf of a higher or lower-level struc-ture
+                continue;
+            }
+
+            return Some(DatInfo {
+                eax: res.eax,
+                ebx: res.ebx,
+                ecx: res.ecx,
+                edx: res.edx,
+            });
+        }
+    }
+}
+
+/// Deterministic Address Translation Structure
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct DatInfo {
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl DatInfo {
+    check_bit_fn!(
+        doc = "4K page size entries supported by this structure",
+        has_4k_entries,
+        ebx,
+        0
+    );
+
+    check_bit_fn!(
+        doc = "2MB page size entries supported by this structure",
+        has_2mb_entries,
+        ebx,
+        1
+    );
+
+    check_bit_fn!(
+        doc = "4MB page size entries supported by this structure",
+        has_4mb_entries,
+        ebx,
+        2
+    );
+
+    check_bit_fn!(
+        doc = "1GB page size entries supported by this structure",
+        has_1gb_entries,
+        ebx,
+        3
+    );
+
+    check_bit_fn!(
+        doc = "Fully associative structure",
+        is_fully_associative,
+        edx,
+        8
+    );
+
+    /// Partitioning (0: Soft partitioning between the logical processors sharing this structure).
+    pub fn partitioning(&self) -> u8 {
+        get_bits(self.ebx, 8, 10) as u8
+    }
+
+    /// Ways of associativity.
+    pub fn ways(&self) -> u16 {
+        get_bits(self.ebx, 16, 31) as u16
+    }
+
+    /// Number of Sets.
+    pub fn sets(&self) -> u32 {
+        self.ecx
+    }
+
+    /// Translation cache type field.
+    pub fn cache_type(&self) -> DatType {
+        match get_bits(self.edx, 0, 4) as u8 {
+            0b00001 => DatType::DataTLB,
+            0b00010 => DatType::InstructionTLB,
+            0b00011 => DatType::UnifiedTLB,
+            0b00000 => DatType::Null, // should never be returned as this indicates invalid struct!
+            _ => DatType::Unknown,
+        }
+    }
+
+    /// Translation cache level (starts at 1)
+    pub fn cache_level(&self) -> u8 {
+        get_bits(self.edx, 5, 7) as u8
+    }
+
+    /// Maximum number of addressable IDs for logical processors sharing this translation cache
+    pub fn max_addressable_ids(&self) -> u16 {
+        // Add one to the return value to get the result:
+        (get_bits(self.edx, 14, 25) + 1) as u16
+    }
+}
+
+/// Deterministic Address Translation cache type (EDX bits 04 -- 00)
+#[derive(Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum DatType {
+    /// Null (indicates this sub-leaf is not valid).
+    Null = 0b00000,
+    DataTLB = 0b00001,
+    InstructionTLB = 0b00010,
+    /// Some unified TLBs will allow a single TLB entry to satisfy data read/write
+    /// and instruction fetches. Others will require separate entries (e.g., one
+    /// loaded on data read/write and another loaded on an instruction fetch) .
+    /// Please see the Intel® 64 and IA-32 Architectures Optimization Reference Manual
+    /// for details of a particular product.
+    UnifiedTLB = 0b00011,
+    Unknown,
+}
+
+impl Default for DatType {
+    fn default() -> DatType {
+        DatType::Null
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct SoCVendorInfo {
+    /// MaxSOCID_Index
+    eax: u32,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl SoCVendorInfo {
+    pub fn get_soc_vendor_id(&self) -> u16 {
+        get_bits(self.ebx, 0, 15) as u16
+    }
+
+    pub fn get_project_id(&self) -> u32 {
+        self.ecx
+    }
+
+    pub fn get_stepping_id(&self) -> u32 {
+        self.edx
+    }
+
+    pub fn get_vendor_brand(&self) -> SoCVendorBrand {
+        assert!(self.eax >= 3); // Leaf 17H is valid if MaxSOCID_Index >= 3.
+        let r1 = cpuid!(EAX_SOC_VENDOR_INFO, 1);
+        let r2 = cpuid!(EAX_SOC_VENDOR_INFO, 2);
+        let r3 = cpuid!(EAX_SOC_VENDOR_INFO, 3);
+        SoCVendorBrand { data: [r1, r2, r3] }
+    }
+
+    pub fn get_vendor_attributes(&self) -> Option<SoCVendorAttributesIter> {
+        if self.eax > 3 {
+            Some(SoCVendorAttributesIter {
+                count: self.eax,
+                current: 3,
+            })
+        } else {
+            None
+        }
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct SoCVendorAttributesIter {
+    count: u32,
+    current: u32,
+}
+
+impl Iterator for SoCVendorAttributesIter {
+    type Item = CpuIdResult;
+
+    /// Iterate over all SoC vendor specific attributes.
+    fn next(&mut self) -> Option<CpuIdResult> {
+        if self.current > self.count {
+            return None;
+        }
+        self.count += 1;
+        Some(cpuid!(EAX_SOC_VENDOR_INFO, self.count))
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct SoCVendorBrand {
+    #[allow(dead_code)]
+    data: [CpuIdResult; 3],
+}
+
+impl SoCVendorBrand {
+    pub fn as_string<'a>(&'a self) -> &'a str {
+        unsafe {
+            let brand_string_start = self as *const SoCVendorBrand as *const u8;
+            let slice =
+                slice::from_raw_parts(brand_string_start, core::mem::size_of::<SoCVendorBrand>());
+            let byte_array: &'a [u8] = transmute(slice);
+            str::from_utf8_unchecked(byte_array)
+        }
+    }
+}
+
+impl fmt::Display for SoCVendorBrand {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(f, "{}", self.as_string())
+    }
+}
+
+/// Information about Hypervisor (https://lwn.net/Articles/301888/)
+pub struct HypervisorInfo {
+    res: CpuIdResult,
+}
+
+impl fmt::Debug for HypervisorInfo {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("HypervisorInfo")
+            .field("type", &self.identify())
+            .field("tsc_frequency", &self.tsc_frequency())
+            .field("apic_frequency", &self.apic_frequency())
+            .finish()
+    }
+}
+
+/// Identifies the different Hypervisor products.
+#[derive(Debug, Eq, PartialEq)]
+pub enum Hypervisor {
+    Xen,
+    VMware,
+    HyperV,
+    KVM,
+    Unknown(u32, u32, u32),
+}
+
+impl HypervisorInfo {
+    pub fn identify(&self) -> Hypervisor {
+        match (self.res.ebx, self.res.ecx, self.res.edx) {
+            // "VMwareVMware"
+            (0x61774d56, 0x4d566572, 0x65726177) => Hypervisor::VMware,
+            // "XenVMMXenVMM"
+            (0x566e6558, 0x65584d4d, 0x4d4d566e) => Hypervisor::Xen,
+            // "Microsoft Hv"
+            (0x7263694d, 0x666f736f, 0x76482074) => Hypervisor::HyperV,
+            // "KVMKVMKVM\0\0\0"
+            (0x4b4d564b, 0x564b4d56, 0x0000004d) => Hypervisor::KVM,
+            (ebx, ecx, edx) => Hypervisor::Unknown(ebx, ecx, edx),
+        }
+    }
+
+    /// TSC frequency in kHz.
+    pub fn tsc_frequency(&self) -> Option<u32> {
+        // vm aware tsc frequency retrieval:
+        // # EAX: (Virtual) TSC frequency in kHz.
+        if self.res.eax >= 0x40000010 {
+            let virt_tinfo = cpuid!(0x40000010, 0);
+            Some(virt_tinfo.eax)
+        } else {
+            None
+        }
+    }
+
+    /// (Virtual) Bus (local apic timer) frequency in kHz.
+    pub fn apic_frequency(&self) -> Option<u32> {
+        // # EBX: (Virtual) Bus (local apic timer) frequency in kHz.
+        if self.res.eax >= 0x40000010 {
+            let virt_tinfo = cpuid!(0x40000010, 0);
+            Some(virt_tinfo.ebx)
+        } else {
+            None
+        }
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct ExtendedFunctionInfo {
+    max_eax_value: u32,
+    data: [CpuIdResult; 9],
+}
+
+#[derive(PartialEq, Eq, Debug)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum L2Associativity {
+    Disabled = 0x0,
+    DirectMapped = 0x1,
+    TwoWay = 0x2,
+    FourWay = 0x4,
+    EightWay = 0x6,
+    SixteenWay = 0x8,
+    FullyAssiciative = 0xF,
+    Unknown,
+}
+
+impl Default for L2Associativity {
+    fn default() -> L2Associativity {
+        L2Associativity::Unknown
+    }
+}
+
+const EAX_EXTENDED_PROC_SIGNATURE: u32 = 0x1;
+const EAX_EXTENDED_BRAND_STRING: u32 = 0x4;
+const EAX_EXTENDED_CACHE_INFO: u32 = 0x6;
+
+impl ExtendedFunctionInfo {
+    fn leaf_is_supported(&self, val: u32) -> bool {
+        val <= self.max_eax_value
+    }
+
+    /// Retrieve processor brand string.
+    pub fn processor_brand_string<'a>(&'a self) -> Option<&'a str> {
+        if self.leaf_is_supported(EAX_EXTENDED_BRAND_STRING) {
+            Some(unsafe {
+                let brand_string_start = &self.data[2] as *const CpuIdResult as *const u8;
+                let mut slice = slice::from_raw_parts(brand_string_start, 3 * 4 * 4);
+
+                match slice.iter().position(|&x| x == 0) {
+                    Some(index) => slice = slice::from_raw_parts(brand_string_start, index),
+                    None => (),
+                }
+
+                let byte_array: &'a [u8] = transmute(slice);
+                str::from_utf8_unchecked(byte_array)
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Extended Processor Signature and Feature Bits.
+    pub fn extended_signature(&self) -> Option<u32> {
+        if self.leaf_is_supported(EAX_EXTENDED_PROC_SIGNATURE) {
+            Some(self.data[1].eax)
+        } else {
+            None
+        }
+    }
+
+    /// Cache Line size in bytes
+    pub fn cache_line_size(&self) -> Option<u8> {
+        if self.leaf_is_supported(EAX_EXTENDED_CACHE_INFO) {
+            Some(get_bits(self.data[6].ecx, 0, 7) as u8)
+        } else {
+            None
+        }
+    }
+
+    /// L2 Associativity field
+    pub fn l2_associativity(&self) -> Option<L2Associativity> {
+        if self.leaf_is_supported(EAX_EXTENDED_CACHE_INFO) {
+            Some(match get_bits(self.data[6].ecx, 12, 15) {
+                0x0 => L2Associativity::Disabled,
+                0x1 => L2Associativity::DirectMapped,
+                0x2 => L2Associativity::TwoWay,
+                0x4 => L2Associativity::FourWay,
+                0x6 => L2Associativity::EightWay,
+                0x8 => L2Associativity::SixteenWay,
+                0xF => L2Associativity::FullyAssiciative,
+                _ => L2Associativity::Unknown,
+            })
+        } else {
+            None
+        }
+    }
+
+    /// Cache size in 1K units
+    pub fn cache_size(&self) -> Option<u16> {
+        if self.leaf_is_supported(EAX_EXTENDED_CACHE_INFO) {
+            Some(get_bits(self.data[6].ecx, 16, 31) as u16)
+        } else {
+            None
+        }
+    }
+
+    /// #Physical Address Bits
+    pub fn physical_address_bits(&self) -> Option<u8> {
+        if self.leaf_is_supported(8) {
+            Some(get_bits(self.data[8].eax, 0, 7) as u8)
+        } else {
+            None
+        }
+    }
+
+    /// #Linear Address Bits
+    pub fn linear_address_bits(&self) -> Option<u8> {
+        if self.leaf_is_supported(8) {
+            Some(get_bits(self.data[8].eax, 8, 15) as u8)
+        } else {
+            None
+        }
+    }
+
+    /// Is Invariant TSC available?
+    pub fn has_invariant_tsc(&self) -> bool {
+        self.leaf_is_supported(7) && self.data[7].edx & (1 << 8) > 0
+    }
+
+    /// Is LAHF/SAHF available in 64-bit mode?
+    pub fn has_lahf_sahf(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEcx {
+                bits: self.data[1].ecx,
+            }
+            .contains(ExtendedFunctionInfoEcx::LAHF_SAHF)
+    }
+
+    /// Is LZCNT available?
+    pub fn has_lzcnt(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEcx {
+                bits: self.data[1].ecx,
+            }
+            .contains(ExtendedFunctionInfoEcx::LZCNT)
+    }
+
+    /// Is PREFETCHW available?
+    pub fn has_prefetchw(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEcx {
+                bits: self.data[1].ecx,
+            }
+            .contains(ExtendedFunctionInfoEcx::PREFETCHW)
+    }
+
+    /// Are fast system calls available.
+    pub fn has_syscall_sysret(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEdx {
+                bits: self.data[1].edx,
+            }
+            .contains(ExtendedFunctionInfoEdx::SYSCALL_SYSRET)
+    }
+
+    /// Is there support for execute disable bit.
+    pub fn has_execute_disable(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEdx {
+                bits: self.data[1].edx,
+            }
+            .contains(ExtendedFunctionInfoEdx::EXECUTE_DISABLE)
+    }
+
+    /// Is there support for 1GiB pages.
+    pub fn has_1gib_pages(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEdx {
+                bits: self.data[1].edx,
+            }
+            .contains(ExtendedFunctionInfoEdx::GIB_PAGES)
+    }
+
+    /// Check support for rdtscp instruction.
+    pub fn has_rdtscp(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEdx {
+                bits: self.data[1].edx,
+            }
+            .contains(ExtendedFunctionInfoEdx::RDTSCP)
+    }
+
+    /// Check support for 64-bit mode.
+    pub fn has_64bit_mode(&self) -> bool {
+        self.leaf_is_supported(1)
+            && ExtendedFunctionInfoEdx {
+                bits: self.data[1].edx,
+            }
+            .contains(ExtendedFunctionInfoEdx::I64BIT_MODE)
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedFunctionInfoEcx: u32 {
+        /// LAHF/SAHF available in 64-bit mode.
+        const LAHF_SAHF = 1 << 0;
+        /// Bit 05: LZCNT
+        const LZCNT = 1 << 5;
+        /// Bit 08: PREFETCHW
+        const PREFETCHW = 1 << 8;
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct ExtendedFunctionInfoEdx: u32 {
+        /// SYSCALL/SYSRET available in 64-bit mode (Bit 11).
+        const SYSCALL_SYSRET = 1 << 11;
+        /// Execute Disable Bit available (Bit 20).
+        const EXECUTE_DISABLE = 1 << 20;
+        /// 1-GByte pages are available if 1 (Bit 26).
+        const GIB_PAGES = 1 << 26;
+        /// RDTSCP and IA32_TSC_AUX are available if 1 (Bit 27).
+        const RDTSCP = 1 << 27;
+        /// Intel ® 64 Architecture available if 1 (Bit 29).
+        const I64BIT_MODE = 1 << 29;
+    }
+}
+
+#[derive(Debug, Default)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct MemoryEncryptionInfo {
+    eax: MemoryEncryptionInfoEax,
+    ebx: u32,
+    ecx: u32,
+    edx: u32,
+}
+
+impl MemoryEncryptionInfo {
+    check_flag!(
+        doc = "Secure Memory Encryption is supported if set.",
+        has_sme,
+        eax,
+        MemoryEncryptionInfoEax::SME
+    );
+
+    check_flag!(
+        doc = "Secure Encrypted Virtualization is supported if set.",
+        has_sev,
+        eax,
+        MemoryEncryptionInfoEax::SEV
+    );
+
+    check_flag!(
+        doc = "The Page Flush MSR is available if set.",
+        has_page_flush_msr,
+        eax,
+        MemoryEncryptionInfoEax::PAGE_FLUSH_MSR
+    );
+
+    check_flag!(
+        doc = "SEV Encrypted State is supported if set.",
+        has_sev_es,
+        eax,
+        MemoryEncryptionInfoEax::SEV_ES
+    );
+
+    pub fn physical_address_reduction(&self) -> u8 {
+        get_bits(self.ebx, 6, 11) as u8
+    }
+
+    pub fn c_bit_position(&self) -> u8 {
+        get_bits(self.ebx, 0, 5) as u8
+    }
+
+    pub fn max_encrypted_guests(&self) -> u32 {
+        self.ecx
+    }
+
+    pub fn min_sev_no_es_asid(&self) -> u32 {
+        self.edx
+    }
+}
+
+bitflags! {
+    #[derive(Default)]
+    #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+    struct MemoryEncryptionInfoEax: u32 {
+        /// Bit 00: SME supported
+        const SME = 1 << 0;
+        /// Bit 01: SEV supported
+        const SEV = 1 << 1;
+        /// Bit 02: Page Flush MSR available
+        const PAGE_FLUSH_MSR = 1 << 2;
+        /// Bit 03: SEV-ES supported
+        const SEV_ES = 1 << 3;
+    }
+}
diff --git a/third_party/rust/raw-cpuid/src/tests.rs b/third_party/rust/raw-cpuid/src/tests.rs
new file mode 100644
index 000000000000..de73c07841f5
--- /dev/null
+++ b/third_party/rust/raw-cpuid/src/tests.rs
@@ -0,0 +1,828 @@
+use *;
+
+#[test]
+fn genuine_intel() {
+    let vf = VendorInfo {
+        ebx: 1970169159,
+        edx: 1231384169,
+        ecx: 1818588270,
+    };
+    assert!(vf.as_string() == "GenuineIntel");
+}
+
+#[test]
+fn feature_info() {
+    let finfo = FeatureInfo {
+        eax: 198313,
+        ebx: 34605056,
+        edx_ecx: FeatureInfoFlags {
+            bits: 2109399999 | 3219913727 << 32,
+        },
+    };
+
+    assert!(finfo.model_id() == 10);
+    assert!(finfo.extended_model_id() == 3);
+    assert!(finfo.stepping_id() == 9);
+    assert!(finfo.extended_family_id() == 0);
+    assert!(finfo.family_id() == 6);
+    assert!(finfo.stepping_id() == 9);
+    assert!(finfo.brand_index() == 0);
+
+    assert!(finfo.edx_ecx.contains(FeatureInfoFlags::SSE2));
+    assert!(finfo.edx_ecx.contains(FeatureInfoFlags::SSE41));
+}
+
+#[test]
+fn cache_info() {
+    let cinfos = CacheInfoIter {
+        current: 1,
+        eax: 1979931137,
+        ebx: 15774463,
+        ecx: 0,
+        edx: 13238272,
+    };
+    for (idx, cache) in cinfos.enumerate() {
+        match idx {
+            0 => assert!(cache.num == 0xff),
+            1 => assert!(cache.num == 0x5a),
+            2 => assert!(cache.num == 0xb2),
+            3 => assert!(cache.num == 0x03),
+            4 => assert!(cache.num == 0xf0),
+            5 => assert!(cache.num == 0xca),
+            6 => assert!(cache.num == 0x76),
+            _ => unreachable!(),
+        }
+    }
+}
+
+#[test]
+fn cache_parameters() {
+    let caches: [CacheParameter; 4] = [
+        CacheParameter {
+            eax: 469778721,
+            ebx: 29360191,
+            ecx: 63,
+            edx: 0,
+        },
+        CacheParameter {
+            eax: 469778722,
+            ebx: 29360191,
+            ecx: 63,
+            edx: 0,
+        },
+        CacheParameter {
+            eax: 469778755,
+            ebx: 29360191,
+            ecx: 511,
+            edx: 0,
+        },
+        CacheParameter {
+            eax: 470008163,
+            ebx: 46137407,
+            ecx: 4095,
+            edx: 6,
+        },
+    ];
+
+    for (idx, cache) in caches.into_iter().enumerate() {
+        match idx {
+            0 => {
+                assert!(cache.cache_type() == CacheType::Data);
+                assert!(cache.level() == 1);
+                assert!(cache.is_self_initializing());
+                assert!(!cache.is_fully_associative());
+                assert!(cache.max_cores_for_cache() == 2);
+                assert!(cache.max_cores_for_package() == 8);
+                assert!(cache.coherency_line_size() == 64);
+                assert!(cache.physical_line_partitions() == 1);
+                assert!(cache.associativity() == 8);
+                assert!(!cache.is_write_back_invalidate());
+                assert!(!cache.is_inclusive());
+                assert!(!cache.has_complex_indexing());
+                assert!(cache.sets() == 64);
+            }
+            1 => {
+                assert!(cache.cache_type() == CacheType::Instruction);
+                assert!(cache.level() == 1);
+                assert!(cache.is_self_initializing());
+                assert!(!cache.is_fully_associative());
+                assert!(cache.max_cores_for_cache() == 2);
+                assert!(cache.max_cores_for_package() == 8);
+                assert!(cache.coherency_line_size() == 64);
+                assert!(cache.physical_line_partitions() == 1);
+                assert!(cache.associativity() == 8);
+                assert!(!cache.is_write_back_invalidate());
+                assert!(!cache.is_inclusive());
+                assert!(!cache.has_complex_indexing());
+                assert!(cache.sets() == 64);
+            }
+            2 => {
+                assert!(cache.cache_type() == CacheType::Unified);
+                assert!(cache.level() == 2);
+                assert!(cache.is_self_initializing());
+                assert!(!cache.is_fully_associative());
+                assert!(cache.max_cores_for_cache() == 2);
+                assert!(cache.max_cores_for_package() == 8);
+                assert!(cache.coherency_line_size() == 64);
+                assert!(cache.physical_line_partitions() == 1);
+                assert!(cache.associativity() == 8);
+                assert!(!cache.is_write_back_invalidate());
+                assert!(!cache.is_inclusive());
+                assert!(!cache.has_complex_indexing());
+                assert!(cache.sets() == 512);
+            }
+            3 => {
+                assert!(cache.cache_type() == CacheType::Unified);
+                assert!(cache.level() == 3);
+                assert!(cache.is_self_initializing());
+                assert!(!cache.is_fully_associative());
+                assert!(cache.max_cores_for_cache() == 16);
+                assert!(cache.max_cores_for_package() == 8);
+                assert!(cache.coherency_line_size() == 64);
+                assert!(cache.physical_line_partitions() == 1);
+                assert!(cache.associativity() == 12);
+                assert!(!cache.is_write_back_invalidate());
+                assert!(cache.is_inclusive());
+                assert!(cache.has_complex_indexing());
+                assert!(cache.sets() == 4096);
+            }
+            _ => unreachable!(),
+        }
+    }
+}
+
+#[test]
+fn monitor_mwait_features() {
+    let mmfeatures = MonitorMwaitInfo {
+        eax: 64,
+        ebx: 64,
+        ecx: 3,
+        edx: 135456,
+    };
+    assert!(mmfeatures.smallest_monitor_line() == 64);
+    assert!(mmfeatures.largest_monitor_line() == 64);
+    assert!(mmfeatures.extensions_supported());
+    assert!(mmfeatures.interrupts_as_break_event());
+    assert!(mmfeatures.supported_c0_states() == 0);
+    assert!(mmfeatures.supported_c1_states() == 2);
+    assert!(mmfeatures.supported_c2_states() == 1);
+    assert!(mmfeatures.supported_c3_states() == 1);
+    assert!(mmfeatures.supported_c4_states() == 2);
+    assert!(mmfeatures.supported_c5_states() == 0);
+    assert!(mmfeatures.supported_c6_states() == 0);
+    assert!(mmfeatures.supported_c7_states() == 0);
+}
+
+#[test]
+fn thermal_power_features() {
+    let tpfeatures = ThermalPowerInfo {
+        eax: ThermalPowerFeaturesEax { bits: 119 },
+        ebx: 2,
+        ecx: ThermalPowerFeaturesEcx { bits: 9 },
+        edx: 0,
+    };
+
+    assert!(tpfeatures.eax.contains(ThermalPowerFeaturesEax::DTS));
+    assert!(tpfeatures
+        .eax
+        .contains(ThermalPowerFeaturesEax::TURBO_BOOST));
+    assert!(tpfeatures.eax.contains(ThermalPowerFeaturesEax::ARAT));
+    assert!(tpfeatures.eax.contains(ThermalPowerFeaturesEax::PLN));
+    assert!(tpfeatures.eax.contains(ThermalPowerFeaturesEax::ECMD));
+    assert!(tpfeatures.eax.contains(ThermalPowerFeaturesEax::PTM));
+
+    assert!(tpfeatures
+        .ecx
+        .contains(ThermalPowerFeaturesEcx::HW_COORD_FEEDBACK));
+    assert!(tpfeatures
+        .ecx
+        .contains(ThermalPowerFeaturesEcx::ENERGY_BIAS_PREF));
+
+    assert!(tpfeatures.dts_irq_threshold() == 0x2);
+    let tpfeatures = ThermalPowerInfo {
+        eax: ThermalPowerFeaturesEax::DTS
+            | ThermalPowerFeaturesEax::TURBO_BOOST
+            | ThermalPowerFeaturesEax::ARAT
+            | ThermalPowerFeaturesEax::PLN
+            | ThermalPowerFeaturesEax::ECMD
+            | ThermalPowerFeaturesEax::PTM
+            | ThermalPowerFeaturesEax::HWP
+            | ThermalPowerFeaturesEax::HWP_NOTIFICATION
+            | ThermalPowerFeaturesEax::HWP_ACTIVITY_WINDOW
+            | ThermalPowerFeaturesEax::HWP_ENERGY_PERFORMANCE_PREFERENCE
+            | ThermalPowerFeaturesEax::HDC,
+        ebx: 2,
+        ecx: ThermalPowerFeaturesEcx::HW_COORD_FEEDBACK | ThermalPowerFeaturesEcx::ENERGY_BIAS_PREF,
+        edx: 0,
+    };
+
+    assert!(tpfeatures.has_dts());
+    assert!(!tpfeatures.has_turbo_boost3());
+    assert!(tpfeatures.has_turbo_boost());
+    assert!(tpfeatures.has_arat());
+    assert!(tpfeatures.has_pln());
+    assert!(tpfeatures.has_ecmd());
+    assert!(tpfeatures.has_ptm());
+    assert!(tpfeatures.has_hwp());
+    assert!(tpfeatures.has_hwp_notification());
+    assert!(tpfeatures.has_hwp_activity_window());
+    assert!(tpfeatures.has_hwp_energy_performance_preference());
+    assert!(!tpfeatures.has_hwp_package_level_request());
+    assert!(tpfeatures.has_hdc());
+    assert!(tpfeatures.has_hw_coord_feedback());
+    assert!(tpfeatures.has_energy_bias_pref());
+    assert!(tpfeatures.dts_irq_threshold() == 0x2);
+}
+
+#[test]
+fn extended_features() {
+    let tpfeatures = ExtendedFeatures {
+        eax: 0,
+        ebx: ExtendedFeaturesEbx { bits: 641 },
+        ecx: ExtendedFeaturesEcx { bits: 0 },
+        edx: 0,
+    };
+    assert!(tpfeatures.eax == 0);
+    assert!(tpfeatures.has_fsgsbase());
+    assert!(!tpfeatures.has_tsc_adjust_msr());
+    assert!(!tpfeatures.has_bmi1());
+    assert!(!tpfeatures.has_hle());
+    assert!(!tpfeatures.has_avx2());
+    assert!(tpfeatures.has_smep());
+    assert!(!tpfeatures.has_bmi2());
+    assert!(tpfeatures.has_rep_movsb_stosb());
+    assert!(!tpfeatures.has_invpcid());
+    assert!(!tpfeatures.has_rtm());
+    assert!(!tpfeatures.has_rdtm());
+    assert!(!tpfeatures.has_fpu_cs_ds_deprecated());
+
+    let tpfeatures2 = ExtendedFeatures {
+        eax: 0,
+        ebx: ExtendedFeaturesEbx::FSGSBASE
+            | ExtendedFeaturesEbx::ADJUST_MSR
+            | ExtendedFeaturesEbx::BMI1
+            | ExtendedFeaturesEbx::AVX2
+            | ExtendedFeaturesEbx::SMEP
+            | ExtendedFeaturesEbx::BMI2
+            | ExtendedFeaturesEbx::REP_MOVSB_STOSB
+            | ExtendedFeaturesEbx::INVPCID
+            | ExtendedFeaturesEbx::DEPRECATE_FPU_CS_DS
+            | ExtendedFeaturesEbx::MPX
+            | ExtendedFeaturesEbx::RDSEED
+            | ExtendedFeaturesEbx::ADX
+            | ExtendedFeaturesEbx::SMAP
+            | ExtendedFeaturesEbx::CLFLUSHOPT
+            | ExtendedFeaturesEbx::PROCESSOR_TRACE,
+        ecx: ExtendedFeaturesEcx { bits: 0 },
+        edx: 201326592,
+    };
+
+    assert!(tpfeatures2.has_fsgsbase());
+    assert!(tpfeatures2.has_tsc_adjust_msr());
+    assert!(tpfeatures2.has_bmi1());
+    assert!(tpfeatures2.has_avx2());
+    assert!(tpfeatures2.has_smep());
+    assert!(tpfeatures2.has_bmi2());
+    assert!(tpfeatures2.has_rep_movsb_stosb());
+    assert!(tpfeatures2.has_invpcid());
+    assert!(tpfeatures2.has_fpu_cs_ds_deprecated());
+    assert!(tpfeatures2.has_mpx());
+    assert!(tpfeatures2.has_rdseed());
+    assert!(tpfeatures2.has_adx());
+    assert!(tpfeatures2.has_smap());
+    assert!(tpfeatures2.has_clflushopt());
+    assert!(tpfeatures2.has_processor_trace());
+}
+
+#[test]
+fn direct_cache_access_info() {
+    let dca = DirectCacheAccessInfo { eax: 0x1 };
+    assert!(dca.get_dca_cap_value() == 0x1);
+}
+
+#[test]
+fn performance_monitoring_info() {
+    let pm = PerformanceMonitoringInfo {
+        eax: 120587267,
+        ebx: PerformanceMonitoringFeaturesEbx { bits: 0 },
+        ecx: 0,
+        edx: 1539,
+    };
+
+    assert!(pm.version_id() == 3);
+    assert!(pm.number_of_counters() == 4);
+    assert!(pm.counter_bit_width() == 48);
+    assert!(pm.ebx_length() == 7);
+    assert!(pm.fixed_function_counters() == 3);
+    assert!(pm.fixed_function_counters_bit_width() == 48);
+
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::CORE_CYC_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::INST_RET_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::REF_CYC_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::CACHE_REF_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::LL_CACHE_MISS_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::BRANCH_INST_RET_EV_UNAVAILABLE));
+    assert!(!pm
+        .ebx
+        .contains(PerformanceMonitoringFeaturesEbx::BRANCH_MISPRED_EV_UNAVAILABLE));
+}
+
+#[cfg(test)]
+#[test]
+fn extended_topology_info() {
+    let l1 = ExtendedTopologyLevel {
+        eax: 1,
+        ebx: 2,
+        ecx: 256,
+        edx: 3,
+    };
+    let l2 = ExtendedTopologyLevel {
+        eax: 4,
+        ebx: 4,
+        ecx: 513,
+        edx: 3,
+    };
+
+    assert!(l1.processors() == 2);
+    assert!(l1.level_number() == 0);
+    assert!(l1.level_type() == TopologyType::SMT);
+    assert!(l1.x2apic_id() == 3);
+    assert!(l1.shift_right_for_next_apic_id() == 1);
+
+    assert!(l2.processors() == 4);
+    assert!(l2.level_number() == 1);
+    assert!(l2.level_type() == TopologyType::Core);
+    assert!(l2.x2apic_id() == 3);
+    assert!(l2.shift_right_for_next_apic_id() == 4);
+}
+
+#[test]
+fn extended_state_info() {
+    let es = ExtendedStateInfo {
+        eax: ExtendedStateInfoXCR0Flags { bits: 7 },
+        ebx: 832,
+        ecx: 832,
+        edx: 0,
+        eax1: 1,
+        ebx1: 0,
+        ecx1: ExtendedStateInfoXSSFlags { bits: 0 },
+        edx1: 0,
+    };
+
+    assert!(es.xsave_area_size_enabled_features() == 832);
+    assert!(es.xsave_area_size_supported_features() == 832);
+    assert!(es.has_xsaveopt());
+}
+
+#[test]
+fn extended_state_info3() {
+    /*let cpuid = CpuId::new();
+    cpuid.get_extended_state_info().map(|info| {
+        println!("{:?}", info);
+        use std::vec::Vec;
+        let es: Vec<ExtendedState> = info.iter().collect();
+        println!("{:?}", es);
+    });*/
+
+    let esi = ExtendedStateInfo {
+        eax: ExtendedStateInfoXCR0Flags::LEGACY_X87
+            | ExtendedStateInfoXCR0Flags::SSE128
+            | ExtendedStateInfoXCR0Flags::AVX256
+            | ExtendedStateInfoXCR0Flags::MPX_BNDREGS
+            | ExtendedStateInfoXCR0Flags::MPX_BNDCSR
+            | ExtendedStateInfoXCR0Flags::AVX512_OPMASK
+            | ExtendedStateInfoXCR0Flags::AVX512_ZMM_HI256
+            | ExtendedStateInfoXCR0Flags::AVX512_ZMM_HI16
+            | ExtendedStateInfoXCR0Flags::PKRU,
+        ebx: 2688,
+        ecx: 2696,
+        edx: 0,
+        eax1: 15,
+        ebx1: 2560,
+        ecx1: ExtendedStateInfoXSSFlags::PT,
+        edx1: 0,
+    };
+
+    assert!(esi.xcr0_supports_legacy_x87());
+    assert!(esi.xcr0_supports_sse_128());
+    assert!(esi.xcr0_supports_avx_256());
+    assert!(esi.xcr0_supports_mpx_bndregs());
+    assert!(esi.xcr0_supports_mpx_bndcsr());
+    assert!(esi.xcr0_supports_avx512_opmask());
+    assert!(esi.xcr0_supports_avx512_zmm_hi256());
+    assert!(esi.xcr0_supports_avx512_zmm_hi16());
+    assert!(esi.xcr0_supports_pkru());
+    assert!(esi.ia32_xss_supports_pt());
+    assert!(!esi.ia32_xss_supports_hdc());
+
+    assert!(esi.xsave_area_size_enabled_features() == 2688);
+    assert!(esi.xsave_area_size_supported_features() == 2696);
+
+    assert!(esi.has_xsaveopt());
+    assert!(esi.has_xsavec());
+    assert!(esi.has_xgetbv());
+    assert!(esi.has_xsaves_xrstors());
+    assert!(esi.xsave_size() == 2560);
+
+    let es = [
+        ExtendedState {
+            subleaf: 2,
+            eax: 256,
+            ebx: 576,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 3,
+            eax: 64,
+            ebx: 960,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 4,
+            eax: 64,
+            ebx: 1024,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 5,
+            eax: 64,
+            ebx: 1088,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 6,
+            eax: 512,
+            ebx: 1152,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 7,
+            eax: 1024,
+            ebx: 1664,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 8,
+            eax: 128,
+            ebx: 0,
+            ecx: 1,
+        },
+        ExtendedState {
+            subleaf: 9,
+            eax: 8,
+            ebx: 2688,
+            ecx: 0,
+        },
+    ];
+
+    let e = &es[0];
+    assert!(e.subleaf == 2);
+    assert!(e.size() == 256);
+    assert!(e.offset() == 576);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[1];
+    assert!(e.subleaf == 3);
+    assert!(e.size() == 64);
+    assert!(e.offset() == 960);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[2];
+    assert!(e.subleaf == 4);
+    assert!(e.size() == 64);
+    assert!(e.offset() == 1024);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[3];
+    assert!(e.subleaf == 5);
+    assert!(e.size() == 64);
+    assert!(e.offset() == 1088);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[4];
+    assert!(e.subleaf == 6);
+    assert!(e.size() == 512);
+    assert!(e.offset() == 1152);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[5];
+    assert!(e.subleaf == 7);
+    assert!(e.size() == 1024);
+    assert!(e.offset() == 1664);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[6];
+    assert!(e.subleaf == 8);
+    assert!(e.size() == 128);
+    assert!(e.offset() == 0);
+    assert!(!e.is_in_xcr0());
+    assert!(e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+
+    let e = &es[7];
+    assert!(e.subleaf == 9);
+    assert!(e.size() == 8);
+    assert!(e.offset() == 2688);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+    assert!(!e.is_compacted_format());
+}
+
+#[test]
+fn extended_state_info2() {
+    let es = ExtendedStateInfo {
+        eax: ExtendedStateInfoXCR0Flags { bits: 31 },
+        ebx: 1088,
+        ecx: 1088,
+        edx: 0,
+        eax1: 15,
+        ebx1: 960,
+        ecx1: ExtendedStateInfoXSSFlags { bits: 256 },
+        edx1: 0,
+    };
+
+    assert!(es.xcr0_supports_legacy_x87());
+    assert!(es.xcr0_supports_sse_128());
+    assert!(es.xcr0_supports_avx_256());
+    assert!(es.xcr0_supports_mpx_bndregs());
+    assert!(es.xcr0_supports_mpx_bndcsr());
+    assert!(!es.xcr0_supports_avx512_opmask());
+    assert!(!es.xcr0_supports_pkru());
+    assert!(es.ia32_xss_supports_pt());
+
+    assert!(es.xsave_area_size_enabled_features() == 0x440);
+    assert!(es.xsave_area_size_supported_features() == 0x440);
+
+    assert!(es.has_xsaveopt());
+    assert!(es.has_xsavec());
+    assert!(es.has_xgetbv());
+    assert!(es.has_xsaves_xrstors());
+    assert!(es.xsave_size() == 0x3c0);
+
+    let esiter: [ExtendedState; 3] = [
+        ExtendedState {
+            subleaf: 2,
+            eax: 256,
+            ebx: 576,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 3,
+            eax: 64,
+            ebx: 960,
+            ecx: 0,
+        },
+        ExtendedState {
+            subleaf: 4,
+            eax: 64,
+            ebx: 1024,
+            ecx: 0,
+        },
+    ];
+
+    let e = &esiter[0];
+    assert!(e.subleaf == 2);
+    assert!(e.size() == 256);
+    assert!(e.offset() == 576);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+
+    let e = &esiter[1];
+    assert!(e.subleaf == 3);
+    assert!(e.size() == 64);
+    assert!(e.offset() == 960);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+
+    let e = &esiter[2];
+    assert!(e.subleaf == 4);
+    assert!(e.size() == 64);
+    assert!(e.offset() == 1024);
+    assert!(e.is_in_xcr0());
+    assert!(!e.is_in_ia32_xss());
+}
+
+#[test]
+fn quality_of_service_info() {
+    let qos = RdtMonitoringInfo { ebx: 832, edx: 0 };
+
+    assert!(qos.rmid_range() == 832);
+    assert!(!qos.has_l3_monitoring());
+}
+
+#[test]
+fn extended_functions() {
+    let ef = ExtendedFunctionInfo {
+        max_eax_value: 8,
+        data: [
+            CpuIdResult {
+                eax: 2147483656,
+                ebx: 0,
+                ecx: 0,
+                edx: 0,
+            },
+            CpuIdResult {
+                eax: 0,
+                ebx: 0,
+                ecx: 1,
+                edx: 672139264,
+            },
+            CpuIdResult {
+                eax: 538976288,
+                ebx: 1226842144,
+                ecx: 1818588270,
+                edx: 539578920,
+            },
+            CpuIdResult {
+                eax: 1701998403,
+                ebx: 692933672,
+                ecx: 758475040,
+                edx: 926102323,
+            },
+            CpuIdResult {
+                eax: 1346576469,
+                ebx: 541073493,
+                ecx: 808988209,
+                edx: 8013895,
+            },
+            CpuIdResult {
+                eax: 0,
+                ebx: 0,
+                ecx: 0,
+                edx: 0,
+            },
+            CpuIdResult {
+                eax: 0,
+                ebx: 0,
+                ecx: 16801856,
+                edx: 0,
+            },
+            CpuIdResult {
+                eax: 0,
+                ebx: 0,
+                ecx: 0,
+                edx: 256,
+            },
+            CpuIdResult {
+                eax: 12324,
+                ebx: 0,
+                ecx: 0,
+                edx: 0,
+            },
+        ],
+    };
+
+    assert_eq!(
+        ef.processor_brand_string().unwrap(),
+        "       Intel(R) Core(TM) i5-3337U CPU @ 1.80GHz"
+    );
+    assert!(ef.has_lahf_sahf());
+    assert!(!ef.has_lzcnt());
+    assert!(!ef.has_prefetchw());
+    assert!(ef.has_syscall_sysret());
+    assert!(ef.has_execute_disable());
+    assert!(!ef.has_1gib_pages());
+    assert!(ef.has_rdtscp());
+    assert!(ef.has_64bit_mode());
+    assert!(ef.has_invariant_tsc());
+
+    assert!(ef.extended_signature().unwrap() == 0x0);
+    assert!(ef.cache_line_size().unwrap() == 64);
+    assert!(ef.l2_associativity().unwrap() == L2Associativity::EightWay);
+    assert!(ef.cache_size().unwrap() == 256);
+    assert!(ef.physical_address_bits().unwrap() == 36);
+    assert!(ef.linear_address_bits().unwrap() == 48);
+}
+
+#[cfg(test)]
+#[test]
+fn sgx_test() {
+    let sgx = SgxInfo {
+        eax: 1,
+        ebx: 0,
+        ecx: 0,
+        edx: 9247,
+        eax1: 54,
+        ebx1: 0,
+        ecx1: 31,
+        edx1: 0,
+    };
+
+    assert!(sgx.max_enclave_size_64bit() == 0x24);
+    assert!(sgx.max_enclave_size_non_64bit() == 0x1f);
+    assert!(sgx.has_sgx1());
+    assert!(!sgx.has_sgx2());
+    assert!(sgx.miscselect() == 0x0);
+    assert!(sgx.secs_attributes() == (0x0000000000000036, 0x000000000000001f));
+}
+
+#[cfg(test)]
+#[test]
+fn readme_test() {
+    // let cpuid = CpuId::new();
+    //
+    // match cpuid.get_vendor_info() {
+    // Some(vf) => assert!(vf.as_string() == "GenuineIntel"),
+    // None => ()
+    // }
+    //
+    // let has_sse = match cpuid.get_feature_info() {
+    // Some(finfo) => finfo.has_sse(),
+    // None => false
+    // };
+    //
+    // if has_sse {
+    // println!("CPU supports SSE!");
+    // }
+    //
+    // match cpuid.get_cache_parameters() {
+    // Some(cparams) => {
+    // for cache in cparams {
+    // let size = cache.associativity() * cache.physical_line_partitions() * cache.coherency_line_size() * cache.sets();
+    // println!("L{}-Cache size is {}", cache.level(), size);
+    // }
+    // },
+    // None => println!("No cache parameter information available"),
+    // }
+    //
+}
+
+/*
+extern crate serde_json;
+
+#[cfg(test)]
+#[test]
+fn test_serializability() {
+    #[derive(Debug, Default, Serialize, Deserialize)]
+    struct SerializeDeserializeTest {
+        _x1: CpuId,
+        _x2: CpuIdResult,
+        _x3: VendorInfo,
+        _x4: CacheInfoIter,
+        _x5: CacheInfo,
+        _x6: ProcessorSerial,
+        _x7: FeatureInfo,
+        _x8: CacheParametersIter,
+        _x9: CacheParameter,
+        _x10: MonitorMwaitInfo,
+        _x11: ThermalPowerInfo,
+        _x12: ExtendedFeatures,
+        _x13: DirectCacheAccessInfo,
+        _x14: PerformanceMonitoringInfo,
+        _x15: ExtendedTopologyIter,
+        _x16: ExtendedTopologyLevel,
+        _x17: ExtendedStateInfo,
+        _x18: ExtendedStateIter,
+        _x19: ExtendedState,
+        _x20: RdtAllocationInfo,
+        _x21: RdtMonitoringInfo,
+        _x22: L3CatInfo,
+        _x23: L2CatInfo,
+        _x24: ProcessorTraceInfo,
+        _x25: ProcessorTraceIter,
+        _x26: ProcessorTrace,
+        _x27: TscInfo,
+        _x28: ProcessorFrequencyInfo,
+        _x29: SoCVendorInfo,
+        _x30: SoCVendorAttributesIter,
+        _x31: SoCVendorBrand,
+        _x32: ExtendedFunctionInfo,
+        _x33: MemBwAllocationInfo,
+        _x34: L3MonitoringInfo,
+        _x35: SgxSectionInfo,
+        _x36: EpcSection,
+        _x37: SgxInfo,
+        _x38: SgxSectionIter,
+        _x39: DatInfo,
+        _x40: DatIter,
+        _x41: DatType,
+    }
+
+    let st: SerializeDeserializeTest = Default::default();
+    let test = serde_json::to_string(&st).unwrap();
+    let _st: SerializeDeserializeTest = serde_json::from_str(&test).unwrap();
+}*/
diff --git a/third_party/rust/rlbox_lucet_sandbox/.cargo-checksum.json b/third_party/rust/rlbox_lucet_sandbox/.cargo-checksum.json
index 538b00843f6b..764ab0a3055f 100644
--- a/third_party/rust/rlbox_lucet_sandbox/.cargo-checksum.json
+++ b/third_party/rust/rlbox_lucet_sandbox/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{".clang-format":"ff4e345608f7674dd1ee1f37b24d4030b260d82516a747093af141b3076a4164",".clang-tidy":"861bc5b367dc85f5fa103f2de9460e158de97f48c59c51a26784b7c2c481e3b7","CMakeLists.txt":"36037a5fb56279891de224657a92705dab8e9ea248883f7373761a477d0c128a","Cargo.toml":"c4b37b1c6fc94626cfc44a935268110af90d8f750b05879d1723804a7fec2e6a","LICENSE":"891d419ba95ab39090775820f4178421dbdcd241c080003aa44f62445a48615a","README.md":"3f19110120d1b6b9de0d879183f1968a6f2e597bf86c84394a496b20245afb5b","c_src/CMakeLists.txt":"ba917a45a37dc9b8b5a7b6f314ccaa4e5117407886945e6e8508f008e6348a98","c_src/lucet_sandbox_wrapper.c":"08b2ab265127aca42b02c8a36e5450284d6794d86867a5808f854588183ab9d9","include/lucet_sandbox.h":"8d4fd6e15c645d7f785eb66bd580774229fffb77908419d28acb947d0893e3e0","include/rlbox_lucet_sandbox.hpp":"b8a4b86460e9b666ec92bf23db37578639a368005ccf4aa722032aaca8ae59db","src/callback.rs":"c40f92e017bc8f2f3136304c1f2d3ca683fe80a1bb505c0fa750cc372305020d","src/create.rs":"25b7920e894209bdaf5029a05b51615d862fa42fafa63de0a6ed27dd1d30dd3b","src/invoke.rs":"d47b167c6048a3221f5e66a4acb5154bc5306bd1053acee56bfb87bb66c78879","src/lib.rs":"677f45b275101c116ea7acf2dafa77f9f1c5e3f379d4da3a9512c71a71878595","src/memory.rs":"8b27396ec4ddba18ac760052e9d11564fdc8c4e68271b817dfd13cefc97cf1a3","src/types.rs":"85907840c233aae0e234bcb5c1e107e76231b6518cc70a1c18be73edc2720742","test/test_lucet_sandbox_glue.cpp":"ea4eb3ace8e9a87550db44f61d065b45f31f1f5b774b4a3e0383e62962c0abf2","test/test_lucet_sandbox_glue_embedder_vars.cpp":"be6abfae367719b12edc5fd8f1de840abed9bb4a2efdebb19ed59e8796fb47b8","test/test_lucet_sandbox_glue_main.cpp":"fde2081cd8b0df3fd73fee1e36dfa5eccfb5bc825072c55a57fcf3048858dbd9","test/test_lucet_sandbox_glue_preload.cpp":"c986ac617327305fcc3ea33114667d4c833ee685c740e482ffde97de4f203e35"},"package":null}
\ No newline at end of file
+{"files":{".clang-format":"ff4e345608f7674dd1ee1f37b24d4030b260d82516a747093af141b3076a4164",".clang-tidy":"861bc5b367dc85f5fa103f2de9460e158de97f48c59c51a26784b7c2c481e3b7",".travis.yml":"a49b61a394520c39bb20c420b587e92ea9c8008764fef0368c4747b71b8f1561","CMakeLists.txt":"be1746d5161db062c96ec2f2060a514229498c0fa7cf20d5ae01e81736320681","Cargo.toml":"242bf8b59ba672cb9888ece9f676d263224fe1836ce486dda02a0e28b5afd187","LICENSE":"891d419ba95ab39090775820f4178421dbdcd241c080003aa44f62445a48615a","README.md":"53315d2de00f7a8e932af5ad3267bf56027d22790bb09182e250b9b35fbe0758","c_src/CMakeLists.txt":"41f6338bb8aef5c0a7a6db53f3ed699ae027f0c008e67c9bb344fe0b75513d3f","c_src/lucet_sandbox_wrapper.c":"08b2ab265127aca42b02c8a36e5450284d6794d86867a5808f854588183ab9d9","include/lucet_sandbox.h":"8d24bd5fbd4f717f0bb90b238a7b7fbdd212207297ddf1a723cc98ee13180c5b","include/rlbox_lucet_sandbox.hpp":"b8a4b86460e9b666ec92bf23db37578639a368005ccf4aa722032aaca8ae59db","src/callback.rs":"c40f92e017bc8f2f3136304c1f2d3ca683fe80a1bb505c0fa750cc372305020d","src/create.rs":"5d620a050c1990e7215346fe144a7be7c0e4bb396068ac81ae8b21fb1fdb3dca","src/invoke.rs":"d47b167c6048a3221f5e66a4acb5154bc5306bd1053acee56bfb87bb66c78879","src/lib.rs":"677f45b275101c116ea7acf2dafa77f9f1c5e3f379d4da3a9512c71a71878595","src/memory.rs":"8b27396ec4ddba18ac760052e9d11564fdc8c4e68271b817dfd13cefc97cf1a3","src/types.rs":"85907840c233aae0e234bcb5c1e107e76231b6518cc70a1c18be73edc2720742","test/test_lucet_sandbox_glue.cpp":"ea4eb3ace8e9a87550db44f61d065b45f31f1f5b774b4a3e0383e62962c0abf2","test/test_lucet_sandbox_glue_embedder_vars.cpp":"be6abfae367719b12edc5fd8f1de840abed9bb4a2efdebb19ed59e8796fb47b8","test/test_lucet_sandbox_glue_main.cpp":"fde2081cd8b0df3fd73fee1e36dfa5eccfb5bc825072c55a57fcf3048858dbd9","test/test_lucet_sandbox_glue_preload.cpp":"c986ac617327305fcc3ea33114667d4c833ee685c740e482ffde97de4f203e35"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/rlbox_lucet_sandbox/.travis.yml b/third_party/rust/rlbox_lucet_sandbox/.travis.yml
new file mode 100644
index 000000000000..0c4a38fc281e
--- /dev/null
+++ b/third_party/rust/rlbox_lucet_sandbox/.travis.yml
@@ -0,0 +1,12 @@
+dist: bionic
+language: rust
+
+script:
+  # Install a more recent cmake
+  - wget https://cmake.org/files/v3.16/cmake-3.16.0-Linux-x86_64.tar.gz
+  - tar xzvf cmake-3.16.0-Linux-x86_64.tar.gz
+  - mkdir ./build
+  - cd ./build
+  - ../cmake-3.16.0-Linux-x86_64/bin/cmake -S ..
+  - make
+  - make test
diff --git a/third_party/rust/rlbox_lucet_sandbox/CMakeLists.txt b/third_party/rust/rlbox_lucet_sandbox/CMakeLists.txt
index 47fdbcb92ffb..781dc8cfe202 100644
--- a/third_party/rust/rlbox_lucet_sandbox/CMakeLists.txt
+++ b/third_party/rust/rlbox_lucet_sandbox/CMakeLists.txt
@@ -45,8 +45,8 @@ if(DEV)
     add_compile_options(-Werror) # warnings as errors
     add_compile_options(-fsanitize=address)
     add_link_options(-fsanitize=address)
-    # add_compile_options(-fsanitize=undefined)
-    # add_link_options(-fsanitize=undefined)
+    add_compile_options(-fsanitize=undefined)
+    add_link_options(-fsanitize=undefined)
   endif()
 
   find_program(CLANG_TIDY "clang-tidy")
@@ -83,7 +83,7 @@ FetchContent_Declare(
   rlbox
   GIT_REPOSITORY https://github.com/PLSysSec/rlbox_api_cpp17.git)
 FetchContent_GetProperties(rlbox)
-if(NOT catch2_POPULATED)
+if(NOT rlbox_POPULATED)
   FetchContent_Populate(rlbox)
 endif()
 
@@ -98,11 +98,19 @@ endif()
 add_subdirectory("${catch2_SOURCE_DIR}")
 list(APPEND CMAKE_MODULE_PATH "${catch2_SOURCE_DIR}/contrib")
 
-FetchContent_Declare(
-  wasiclang
-  URL
-    https://github.com/CraneStation/wasi-sdk/releases/download/wasi-sdk-6/wasi-sdk-6.0-linux.tar.gz
-  )
+if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+  FetchContent_Declare(
+    wasiclang
+    URL
+      https://github.com/CraneStation/wasi-sdk/releases/download/wasi-sdk-6/wasi-sdk-6.0-macos.tar.gz
+    )
+else()
+  FetchContent_Declare(
+    wasiclang
+    URL
+      https://github.com/CraneStation/wasi-sdk/releases/download/wasi-sdk-6/wasi-sdk-6.0-linux.tar.gz
+    )
+endif()
 FetchContent_GetProperties(wasiclang)
 if(NOT wasiclang_POPULATED)
   FetchContent_Populate(wasiclang)
@@ -118,6 +126,11 @@ endif()
 
 # Rust Lib ###################
 
+if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+  set(DYLIB_EXT "dylib")
+else()
+  set(DYLIB_EXT "so")
+endif()
 set(LUCET_DIR "${CMAKE_BINARY_DIR}/cargo/release/")
 set(LUCET_PATH "${LUCET_DIR}/lucetc")
 file(GLOB_RECURSE LUCET_SOURCE_FILES ${mod_lucet_SOURCE_DIR}/*.rs ${mod_lucet_SOURCE_DIR}/*.S)
@@ -139,11 +152,8 @@ add_custom_target(lucet_release ALL DEPENDS ${LUCET_PATH})
 
 file(GLOB_RECURSE RUST_SOURCE_FILES src/*.rs)
 
-# Use the dynamic library as wasi symbols needed by the wasm module are hosted
-# in it. If we include the static version, we need to make the main executable
-# expose symbols through rdynamic
 set(RUST_LIB_DEBUG_PATH
-    "${CMAKE_BINARY_DIR}/cargo/debug/librlbox_lucet_sandbox.so")
+    "${CMAKE_BINARY_DIR}/cargo/debug/librlbox_lucet_sandbox.a")
 add_custom_command(OUTPUT ${RUST_LIB_DEBUG_PATH}
                    DEPENDS ${RUST_SOURCE_FILES} ${LUCET_SOURCE_FILES} Cargo.toml
                    COMMAND CARGO_TARGET_DIR=${CMAKE_BINARY_DIR}/cargo ${CARGO}
@@ -153,7 +163,7 @@ add_custom_target(lucet_sandbox_rustlib_debug ALL
                   DEPENDS ${RUST_LIB_DEBUG_PATH})
 
 set(RUST_LIB_RELEASE_PATH
-    "${CMAKE_BINARY_DIR}/cargo/release/librlbox_lucet_sandbox.so")
+    "${CMAKE_BINARY_DIR}/cargo/release/librlbox_lucet_sandbox.a")
 add_custom_command(OUTPUT ${RUST_LIB_RELEASE_PATH}
                    DEPENDS ${RUST_SOURCE_FILES} ${LUCET_SOURCE_FILES} Cargo.toml
                    COMMAND CARGO_TARGET_DIR=${CMAKE_BINARY_DIR}/cargo
@@ -172,7 +182,14 @@ set_target_properties(lucet_sandbox_rustlib
 set_target_properties(lucet_sandbox_rustlib
                       PROPERTIES IMPORTED_LOCATION_RELEASE
                                  ${RUST_LIB_RELEASE_PATH})
-
+# The wasi symbols needed by the wasm module are in this static lib, but must
+# be part of the symbol table (locatable through dlsym). We need the following
+# flag for this.
+if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+target_link_options(lucet_sandbox_rustlib INTERFACE "-framework" "Security" "-rdynamic")
+else()
+target_link_options(lucet_sandbox_rustlib INTERFACE "-rdynamic")
+endif()
 # Tests ###################
 
 include(CTest)
@@ -189,7 +206,7 @@ endif()
 
 file(GLOB_RECURSE C_SOURCE_FILES c_src/*)
 set(GLUE_LIB_WASM "${CMAKE_BINARY_DIR}/wasm/glue_lib_lucet.wasm")
-set(GLUE_LIB_SO "${CMAKE_BINARY_DIR}/wasm/glue_lib_lucet.so")
+set(GLUE_LIB_SO "${CMAKE_BINARY_DIR}/wasm/glue_lib_lucet.${DYLIB_EXT}")
 
 add_custom_command(OUTPUT ${GLUE_LIB_WASM} ${GLUE_LIB_SO}
                    DEPENDS ${C_SOURCE_FILES}
@@ -198,20 +215,20 @@ add_custom_command(OUTPUT ${GLUE_LIB_WASM} ${GLUE_LIB_SO}
                            wasiclang_SOURCE_DIR=${wasiclang_SOURCE_DIR}
                            LUCET_DIR=${LUCET_DIR}
                            LUCET_WASI_DIR=${mod_lucet_SOURCE_DIR}/lucet-wasi
-                           cmake
+                           ${CMAKE_COMMAND}
                            -S
                            .
                            -B
                            ${CMAKE_BINARY_DIR}/wasm
                    COMMAND VERBOSE=1
-                           cmake
+                           ${CMAKE_COMMAND}
                            --build
                            ${CMAKE_BINARY_DIR}/wasm
                            --target
                            all
                    COMMENT "Building wasm library")
 
-add_custom_target(glue_lib_wasm ALL DEPENDS ${GLUE_LIB_WASM} ${GLUE_LIB_SO})
+add_custom_target(glue_lib_wasm ALL DEPENDS lucet_release ${GLUE_LIB_WASM} ${GLUE_LIB_SO})
 
 add_executable(test_rlbox_glue test/test_lucet_sandbox_glue_main.cpp
                                test/test_lucet_sandbox_glue.cpp
@@ -230,6 +247,8 @@ find_package(Threads REQUIRED)
 target_compile_definitions(test_rlbox_glue PUBLIC
                            GLUE_LIB_LUCET_PATH="${GLUE_LIB_SO}")
 
+add_dependencies(test_rlbox_glue lucet_sandbox_rustlib_debug lucet_sandbox_rustlib_release)
+
 target_link_libraries(test_rlbox_glue
                       Catch2::Catch2
                       lucet_sandbox_rustlib
@@ -238,7 +257,7 @@ target_link_libraries(test_rlbox_glue
                       # glue_lib_lucet
                       )
 
-if(UNIX)
+if(UNIX AND NOT (${CMAKE_SYSTEM_NAME} MATCHES "Darwin"))
   target_link_libraries(test_rlbox_glue rt)
 endif()
 catch_discover_tests(test_rlbox_glue)
diff --git a/third_party/rust/rlbox_lucet_sandbox/Cargo.toml b/third_party/rust/rlbox_lucet_sandbox/Cargo.toml
index 1c8921e9f127..64d8d288d6d8 100644
--- a/third_party/rust/rlbox_lucet_sandbox/Cargo.toml
+++ b/third_party/rust/rlbox_lucet_sandbox/Cargo.toml
@@ -8,10 +8,10 @@ license = "MIT"
 [dependencies]
 failure = ">=0.1.3"                    # Experimental error handling abstraction.
 goblin = ">=0.0.17"                    # An impish, cross-platform, ELF, Mach-o, and PE binary parsing and loading crate
-lucet-wasi = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="58498599272e23ef797bb4304d0f181d7455ca57" }
-lucet-runtime = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="58498599272e23ef797bb4304d0f181d7455ca57" }
-lucet-runtime-internals = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="58498599272e23ef797bb4304d0f181d7455ca57" }
-lucet-module = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="58498599272e23ef797bb4304d0f181d7455ca57" }
+lucet-wasi = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="5e870faf6f95d79d11efc813e56370ad124bbed5" }
+lucet-runtime = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="5e870faf6f95d79d11efc813e56370ad124bbed5" }
+lucet-runtime-internals = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="5e870faf6f95d79d11efc813e56370ad124bbed5" }
+lucet-module = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev="5e870faf6f95d79d11efc813e56370ad124bbed5" }
 # lucet-wasi = { path = "../lucet_sandbox_compiler/lucet-wasi" }
 # lucet-runtime = { path = "../lucet_sandbox_compiler/lucet-runtime" }
 # lucet-runtime-internals = { path = "../lucet_sandbox_compiler/lucet-runtime/lucet-runtime-internals" }
@@ -19,4 +19,4 @@ lucet-module = { git = "https://github.com/PLSysSec/lucet_sandbox_compiler", rev
 
 [lib]
 name = "rlbox_lucet_sandbox"
-crate-type = ["rlib", "staticlib", "cdylib"]
\ No newline at end of file
+crate-type = ["rlib", "staticlib"]
\ No newline at end of file
diff --git a/third_party/rust/rlbox_lucet_sandbox/README.md b/third_party/rust/rlbox_lucet_sandbox/README.md
index 68f1ff22dde5..3927c7d52f90 100644
--- a/third_party/rust/rlbox_lucet_sandbox/README.md
+++ b/third_party/rust/rlbox_lucet_sandbox/README.md
@@ -1,9 +1,16 @@
+[![Build Status](https://travis-ci.com/PLSysSec/rlbox_lucet_sandbox.svg?branch=master)](https://travis-ci.com/PLSysSec/rlbox_lucet_sandbox)
+
 # RLBOX Lucet Sandbox Integration
 Integration with RLBox sandboxing API to leverage the sandboxing in WASM modules compiled with lucet compiler.
 
 For details about the RLBox sandboxing APIs, see [here](https://github.com/PLSysSec/rlbox_api_cpp17).
 
-Currently lucet supports only Linux x64, therefore this repo will only work in this environment.
+This code has been tested on 64-bit versions of Ubuntu and Mac OSX.
+The lucet compiler does not currently support Windows.
+
+## Reporting security bugs
+
+If you find a security bug, please do not create a public issue. Instead, file a security bug on bugzilla using the [following template link](https://bugzilla.mozilla.org/enter_bug.cgi?cc=tom%40mozilla.com&cc=nfroyd%40mozilla.com&cc=deian%40cs.ucsd.edu&cc=shravanrn%40gmail.com&component=Security%3A%20Process%20Sandboxing&defined_groups=1&groups=core-security&product=Core&bug_type=defect).
 
 ## Building/Running the tests
 
@@ -15,6 +22,8 @@ cmake --build ./build --target all
 cmake --build ./build --target test
 ```
 
+On Arch Linux you'll need to install [ncurses5-compat-libs](https://aur.archlinux.org/packages/ncurses5-compat-libs/).
+
 ## Using this library
 
 First, build the rlbox_lucet_sandbox repo with
diff --git a/third_party/rust/rlbox_lucet_sandbox/c_src/CMakeLists.txt b/third_party/rust/rlbox_lucet_sandbox/c_src/CMakeLists.txt
index 2d45882e3362..b993fb46fbc6 100644
--- a/third_party/rust/rlbox_lucet_sandbox/c_src/CMakeLists.txt
+++ b/third_party/rust/rlbox_lucet_sandbox/c_src/CMakeLists.txt
@@ -1,5 +1,8 @@
 cmake_minimum_required(VERSION 3.13)
 
+# Mac adds extra flags 
+set(HAVE_FLAG_SEARCH_PATHS_FIRST 0)
+
 project(rlbox_lucet_testlib
         VERSION 0.1
         DESCRIPTION "RLBox integration with WASM modules compiled with lucet")
@@ -32,13 +35,20 @@ set(CMAKE_BUILD_TYPE Release)
 # Apply settings suitable for wasm module compilation
 set(CMAKE_C_FLAGS
     "--sysroot ${wasiclang_SOURCE_DIR}/opt/wasi-sdk/share/wasi-sysroot/")
+# Link flags are set by default on Mac - clearing this
+set(CMAKE_C_LINK_FLAGS "")
 set(CMAKE_EXE_LINKER_FLAGS "-Wl,--export-all")
 
 add_executable(glue_lib_lucet.wasm
                lucet_sandbox_wrapper.c
                ${rlbox_SOURCE_DIR}/code/tests/rlbox_glue/lib/libtest.c)
 
-set(GLUE_LIB_PATH "${CMAKE_BINARY_DIR}/glue_lib_lucet.so")
+if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+  set(DYLIB_EXT "dylib")
+else()
+  set(DYLIB_EXT "so")
+endif()
+set(GLUE_LIB_PATH "${CMAKE_BINARY_DIR}/glue_lib_lucet.${DYLIB_EXT}")
 
 add_custom_command(OUTPUT ${GLUE_LIB_PATH}
                    DEPENDS glue_lib_lucet.wasm
diff --git a/third_party/rust/rlbox_lucet_sandbox/include/lucet_sandbox.h b/third_party/rust/rlbox_lucet_sandbox/include/lucet_sandbox.h
index 506b8e5aa03a..822a862d0fde 100644
--- a/third_party/rust/rlbox_lucet_sandbox/include/lucet_sandbox.h
+++ b/third_party/rust/rlbox_lucet_sandbox/include/lucet_sandbox.h
@@ -1,13 +1,13 @@
 #ifndef LUCET_SANDBOX_H
 #define LUCET_SANDBOX_H
 
+#include <stdint.h>
+#include <stdlib.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <stdint.h>
-#include <stdlib.h>
-
 struct LucetSandboxInstance;
 typedef struct LucetSandboxInstance LucetSandboxInstance;
 
diff --git a/third_party/rust/rlbox_lucet_sandbox/src/create.rs b/third_party/rust/rlbox_lucet_sandbox/src/create.rs
index 9bd57073e306..e7701003e83e 100644
--- a/third_party/rust/rlbox_lucet_sandbox/src/create.rs
+++ b/third_party/rust/rlbox_lucet_sandbox/src/create.rs
@@ -62,6 +62,7 @@ fn lucet_load_module_helper(module_path: &String, allow_stdio: bool) -> Result<L
             heap_address_space_size: 8 * 1024 * 1024 * 1024, // 8GB
             stack_size: 8 * 1024 * 1024,                     // 8MB - pthread default
             globals_size: globals_size,
+            ..Limits::default()
         },
         4 * 1024 * 1024 * 1024,                              // 4GB heap alignment
     )?;
-- 
2.25.1

